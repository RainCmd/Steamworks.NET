// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
	#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

﻿namespace Steamworks
{
	/// Network-routable identifier for a service.  This is an intentionally
	/// opaque byte blob.  The relays know how to use this to forward it on
	/// to the intended destination, but otherwise clients really should not
	/// need to know what's inside.  (Indeed, we don't really want them to
	/// know, as it could reveal information useful to an attacker.)
	/// 服务的网络可路由标识符。这是一个故意不透明的字节团。
	/// 中继器知道如何使用它将其转发到预期的目的地，
	/// 但除此之外，客户端真的不需要知道里面有什么。
	/// （事实上，我们并不想让他们知道，因为这可能会泄露对攻击者有用的信息。）
	[System.Serializable]
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	public struct SteamDatagramRelayAuthTicket
	{
		/// Identity of the gameserver we want to talk to.  This is required.
		/// 我们想要交谈的游戏服务器的身份。这是必需的。
		SteamNetworkingIdentity m_identityGameserver;

		/// Identity of the person who was authorized.  This is required.
		/// 被授权人的身份。这是必需的。
		SteamNetworkingIdentity m_identityAuthorizedClient;

		/// SteamID is authorized to send from a particular public IP.  If this
		/// is 0, then the sender is not restricted to a particular IP.
		/// 授权SteamID从特定的公共IP发送。如果该值为0，则发送方不受特定IP的限制。
		///
		/// Recommend to leave this set to zero.
		/// 建议将此设置为零。
		uint m_unPublicIP;

		/// Time when the ticket expires.  Recommended: take the current
		/// time and add 6 hours, or maybe a bit longer if your gameplay
		/// sessions are longer.
		/// 车票到期的时间。建议：利用目前的时间，增加6个小时，
		/// 或者如果你的游戏时间更长，可以增加更长的时间。
		///
		/// NOTE: relays may reject tickets with expiry times excessively
		/// far in the future, so contact us if you wish to use an expiry
		/// longer than, say, 24 hours.
		/// 注意：继电器可能会拒绝过期时间过长的门票，
		/// 所以如果您希望使用超过，比如说，24小时的有效期，请联系我们。
		RTime32 m_rtimeTicketExpiry;

		/// Routing information where the gameserver is listening for
		/// relayed traffic.  You should fill this in when generating
		/// a ticket.
		/// 路由信息，其中游戏服务器正在监听中继通信。您应该在生成票据时填写此信息。
		///
		/// When generating tickets on your backend:
		/// - In production: The gameserver knows the proper routing
		///   information, so you need to call
		///   ISteamNetworkingSockets::GetHostedDedicatedServerAddress
		///   and send the info to your backend.
		/// - In development, you will need to provide public IP
		///   of the server using SteamDatagramServiceNetID::SetDevAddress.
		///   Relays need to be able to send UDP
		///   packets to this server.  Since it's very likely that
		///   your server is behind a firewall/NAT, make sure that
		///   the address is the one that the outside world can use.
		///   The traffic from the relays will be "unsolicited", so
		///   stateful firewalls won't work -- you will probably have
		///   to set up an explicit port forward.
		/// On the client:
		/// - this field will always be blank.
		/// 在后台生成票据时：
		/// - 在生产中：游戏服务器知道正确的路由信息，所以你需要调用
		///   ISteamNetworkingSockets::GetHostedDedicatedServerAddress
		///   并将信息发送到你的后端。
		/// - 在开发中，您需要使用SteamDatagramServiceNetID::SetDevAddress提供服务器的公共IP。
		///   中继需要能够向该服务器发送UDP数据包。由于您的服务器很可能位于防火墙/NAT后面，
		///   因此请确保该地址是外部世界可以使用的地址。来自中继的流量将是“未经请求的”，
		///   因此有状态防火墙将不起作用——您可能必须设置一个显式的端口转发。
		/// 在客户端：
		/// - 该字段将始终为空。
		SteamDatagramHostedAddress m_routing;

		/// App ID this is for.  This is required, and should be the
		/// App ID the client is running.  (Even if your gameserver
		/// uses a different App ID.)
		/// 这是用于App ID的。这是必需的，并且应该是客户端正在运行的应用程序ID。
		/// （即使你的游戏服务器使用不同的App ID。）
		uint m_nAppID;

		/// Restrict this ticket to be used for a particular virtual port?
		/// Set to -1 to allow any virtual port.
		/// 限制此票证仅用于特定的虚拟端口？设置为-1表示允许任何虚拟端口。
		///
		/// This is useful as a security measure, and also so the client will
		/// use the right ticket (which might have extra fields that are useful
		/// for proper analytics), if the client happens to have more than one
		/// appropriate ticket.
		/// 这作为一种安全措施是有用的，并且如果客户端碰巧有多个适当的票据，
		/// 那么客户端将使用正确的票据（它可能具有对正确分析有用的额外字段）。
		///
		/// Note: if a client has more that one acceptable ticket, they will
		/// always use the one expiring the latest.
		/// 注意：如果客户端有多个可接受的票证，他们将始终使用过期最晚的票证。
		int m_nRestrictToVirtualPort;

		//
		// Extra fields.
		// 额外的字段。
		//
		// These are collected for backend analytics.  For example, you might
		// send a MatchID so that all of the records for a particular match can
		// be located.  Or send a game mode field so that you can compare
		// the network characteristics of different game modes.
		// 收集这些信息用于后端分析。例如，您可以发送一个MatchID，
		// 以便可以定位特定匹配的所有记录。或者发送一个游戏模式字段，
		// 这样可以比较不同游戏模式的网络特性。
		//
		// (At the time of this writing we don't have a way to expose the data
		// we collect to partners, but we hope to in the future so that you can
		// get visibility into network conditions.)
		// （在撰写本文时，我们还没有办法向合作伙伴公开我们收集的数据，
		// 但我们希望将来能够这样做，以便您可以了解网络状况。）
		//
		[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
		struct ExtraField
		{
			enum EType
			{
				k_EType_String,
				// For most small integral values.  Uses google protobuf sint64, so it's small on the wire.  WARNING: In some places this value may be transmitted in JSON, in which case precision may be lost in backend analytics.  Don't use this for an "identifier", use it for a scalar quantity.
				// 对于大多数小整数值。使用谷歌protobuf sint64，所以它在电线上很小。警告：在某些地方，此值可能以JSON传输，在这种情况下，后端分析可能会丢失精度。不要将它用于“标识符”，而是用于标量。
				k_EType_Int, 
				// 64 arbitrary bits.  This value is treated as an "identifier".  In places where JSON format is used, it will be serialized as a string.  No aggregation / analytics can be performed on this value.
				// 64位任意位。该值被视为“标识符”。在使用JSON格式的地方，它将被序列化为字符串。不能对该值执行聚合/分析。
				k_EType_Fixed64, 
			};
			EType m_eType;

			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 28)]
			byte[] m_szName;

			[StructLayout(LayoutKind.Explicit)]
			struct OptionValue
			{
				[FieldOffset(0)]
				[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
				byte[] m_szStringValue;

				[FieldOffset(0)]
				long m_nIntValue;

				[FieldOffset(0)]
				ulong m_nFixed64Value;
			}
			OptionValue m_val;
		};

		const int k_nMaxExtraFields = 16;

		int m_nExtraFields;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = k_nMaxExtraFields)]
		ExtraField[] m_vecExtraFields;

		// Reset all fields
		public void Clear()
		{
		}
	}
}

#endif // !DISABLESTEAMWORKS