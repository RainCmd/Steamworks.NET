// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

// Unity 32bit Mono on Windows crashes with ThisCall for some reason, StdCall without the 'this' ptr is the only thing that works..?
// 在 Windows 系统上运行的 32 位 Unity Mono 版本由于某种原因会出现崩溃现象，
// 而使用“ThisCall”调用方式时会出现错误，而使用“StdCall”且不包含“this”指针的调用方式则是唯一可行的方法……？
#if (UNITY_EDITOR_WIN && !UNITY_EDITOR_64) || (!UNITY_EDITOR && UNITY_STANDALONE_WIN && !UNITY_64)
	#define NOTHISPTR
#endif

using System;
using System.Runtime.InteropServices;

namespace Steamworks {
	//-----------------------------------------------------------------------------
	// Purpose: Callback interface for receiving responses after a server list refresh
	// or an individual server update.
	// 用途：用于在服务器列表刷新或单个服务器更新后接收响应的回调接口。
	//
	// Since you get these callbacks after requesting full list refreshes you will
	// usually implement this interface inside an object like CServerBrowser.  If that
	// object is getting destructed you should use ISteamMatchMakingServers()->CancelQuery()
	// to cancel any in-progress queries so you don't get a callback into the destructed
	// object and crash.
	// 由于您是在请求完成列表刷新后接收到这些回调，因此通常会在类似于 CServerBrowser 的对象内部实现此接口。
	// 如果该对象即将被销毁，您应该使用 ISteamMatchMakingServers()->CancelQuery() 来取消任何正在进行的查询，
	// 以免在已销毁的对象中接收到回调并导致程序崩溃。
	//-----------------------------------------------------------------------------
	public class ISteamMatchmakingServerListResponse {
		// Server has responded ok with updated data
		// 服务器已成功响应，并提供了更新的数据。
		public delegate void ServerResponded(HServerListRequest hRequest, int iServer);
		// Server has failed to respond
		// 服务器未能响应。
		public delegate void ServerFailedToRespond(HServerListRequest hRequest, int iServer);
		// A list refresh you had initiated is now 100% completed
		// 您所发起的列表更新现已 100% 完成。
		public delegate void RefreshComplete(HServerListRequest hRequest, EMatchMakingServerResponse response);

		private VTable m_VTable;
		private IntPtr m_pVTable;
		private GCHandle m_pGCHandle;
		private ServerResponded m_ServerResponded;
		private ServerFailedToRespond m_ServerFailedToRespond;
		private RefreshComplete m_RefreshComplete;

		public ISteamMatchmakingServerListResponse(ServerResponded onServerResponded, ServerFailedToRespond onServerFailedToRespond, RefreshComplete onRefreshComplete) {
			if (onServerResponded == null || onServerFailedToRespond == null || onRefreshComplete == null) {
				throw new ArgumentNullException();
			}
			m_ServerResponded = onServerResponded;
			m_ServerFailedToRespond = onServerFailedToRespond;
			m_RefreshComplete = onRefreshComplete;

			m_VTable = new VTable() {
				m_VTServerResponded = InternalOnServerResponded,
				m_VTServerFailedToRespond = InternalOnServerFailedToRespond,
				m_VTRefreshComplete = InternalOnRefreshComplete
			};
			m_pVTable = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(VTable)));
			Marshal.StructureToPtr(m_VTable, m_pVTable, false);

			m_pGCHandle = GCHandle.Alloc(m_pVTable, GCHandleType.Pinned);
		}

		~ISteamMatchmakingServerListResponse() {
			if (m_pVTable != IntPtr.Zero) {
				Marshal.FreeHGlobal(m_pVTable);
			}

			if (m_pGCHandle.IsAllocated) {
				m_pGCHandle.Free();
			}
		}

#if NOTHISPTR
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		private delegate void InternalServerResponded(HServerListRequest hRequest, int iServer);
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		private delegate void InternalServerFailedToRespond(HServerListRequest hRequest, int iServer);
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		private delegate void InternalRefreshComplete(HServerListRequest hRequest, EMatchMakingServerResponse response);
		private void InternalOnServerResponded(HServerListRequest hRequest, int iServer) {
			try
			{
				m_ServerResponded(hRequest, iServer);
			}
			catch (Exception e)
			{
				CallbackDispatcher.ExceptionHandler(e);
			}
		}
		private void InternalOnServerFailedToRespond(HServerListRequest hRequest, int iServer) {
			try
			{
				m_ServerFailedToRespond(hRequest, iServer);
			}
			catch (Exception e)
			{
				CallbackDispatcher.ExceptionHandler(e);
			}
		}
		private void InternalOnRefreshComplete(HServerListRequest hRequest, EMatchMakingServerResponse response) {
			try
			{
				m_RefreshComplete(hRequest, response);
			}
			catch (Exception e)
			{
				CallbackDispatcher.ExceptionHandler(e);
			}
		}
#else
		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		private delegate void InternalServerResponded(IntPtr thisptr, HServerListRequest hRequest, int iServer);
		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		private delegate void InternalServerFailedToRespond(IntPtr thisptr, HServerListRequest hRequest, int iServer);
		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		private delegate void InternalRefreshComplete(IntPtr thisptr, HServerListRequest hRequest, EMatchMakingServerResponse response);
		private void InternalOnServerResponded(IntPtr thisptr, HServerListRequest hRequest, int iServer) {
			try
			{
				m_ServerResponded(hRequest, iServer);
			}
			catch (Exception e)
			{
				CallbackDispatcher.ExceptionHandler(e);
			}
		}
		private void InternalOnServerFailedToRespond(IntPtr thisptr, HServerListRequest hRequest, int iServer) {
			try
			{
				m_ServerFailedToRespond(hRequest, iServer);
			}
			catch (Exception e)
			{
				CallbackDispatcher.ExceptionHandler(e);
			}
		}
		private void InternalOnRefreshComplete(IntPtr thisptr, HServerListRequest hRequest, EMatchMakingServerResponse response) {
			try
			{
				m_RefreshComplete(hRequest, response);
			}
			catch (Exception e)
			{
				CallbackDispatcher.ExceptionHandler(e);
			}
		}
#endif

		[StructLayout(LayoutKind.Sequential)]
		private class VTable {
			[NonSerialized]
			[MarshalAs(UnmanagedType.FunctionPtr)]
			public InternalServerResponded m_VTServerResponded;

			[NonSerialized]
			[MarshalAs(UnmanagedType.FunctionPtr)]
			public InternalServerFailedToRespond m_VTServerFailedToRespond;

			[NonSerialized]
			[MarshalAs(UnmanagedType.FunctionPtr)]
			public InternalRefreshComplete m_VTRefreshComplete;
		}

		public static explicit operator System.IntPtr(ISteamMatchmakingServerListResponse that) {
			return that.m_pGCHandle.AddrOfPinnedObject();
		}
	};

	//-----------------------------------------------------------------------------
	// Purpose: Callback interface for receiving responses after pinging an individual server
	// 目的：用于接收对单个服务器进行ping操作后的响应的回调接口
	//
	// These callbacks all occur in response to querying an individual server
	// via the ISteamMatchmakingServers()->PingServer() call below.  If you are
	// destructing an object that implements this interface then you should call
	// ISteamMatchmakingServers()->CancelServerQuery() passing in the handle to the query
	// which is in progress.  Failure to cancel in progress queries when destructing
	// a callback handler may result in a crash when a callback later occurs.
	// 这些回调操作都是在通过下面的 ISteamMatchmakingServers()->PingServer() 调用查询单个服务器的过程中发生的。
	// 如果您正在销毁一个实现了此接口的对象，那么您应当调用 ISteamMatchmakingServers()->CancelServerQuery() 函数，
	// 并传入正在进行中的查询的句柄。如果在销毁回调处理程序时未能取消正在进行的查询，可能会导致后续回调发生时出现崩溃。
	//-----------------------------------------------------------------------------
	public class ISteamMatchmakingPingResponse {
		// Server has responded successfully and has updated data
		// 服务器已成功响应并更新了数据。
		public delegate void ServerResponded(gameserveritem_t server);

		// Server failed to respond to the ping request
		// 服务器未能响应ping请求
		public delegate void ServerFailedToRespond();

		private VTable m_VTable;
		private IntPtr m_pVTable;
		private GCHandle m_pGCHandle;
		private ServerResponded m_ServerResponded;
		private ServerFailedToRespond m_ServerFailedToRespond;

		public ISteamMatchmakingPingResponse(ServerResponded onServerResponded, ServerFailedToRespond onServerFailedToRespond) {
			if (onServerResponded == null || onServerFailedToRespond == null) {
				throw new ArgumentNullException();
			}
			m_ServerResponded = onServerResponded;
			m_ServerFailedToRespond = onServerFailedToRespond;

			m_VTable = new VTable() {
				m_VTServerResponded = InternalOnServerResponded,
				m_VTServerFailedToRespond = InternalOnServerFailedToRespond,
			};
			m_pVTable = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(VTable)));
			Marshal.StructureToPtr(m_VTable, m_pVTable, false);

			m_pGCHandle = GCHandle.Alloc(m_pVTable, GCHandleType.Pinned);
		}

		~ISteamMatchmakingPingResponse() {
			if (m_pVTable != IntPtr.Zero) {
				Marshal.FreeHGlobal(m_pVTable);
			}

			if (m_pGCHandle.IsAllocated) {
				m_pGCHandle.Free();
			}
		}

#if NOTHISPTR
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		private delegate void InternalServerResponded(gameserveritem_t server);
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		private delegate void InternalServerFailedToRespond();
		private void InternalOnServerResponded(gameserveritem_t server) {
			m_ServerResponded(server);
		}
		private void InternalOnServerFailedToRespond() {
			m_ServerFailedToRespond();
		}
#else
		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		private delegate void InternalServerResponded(IntPtr thisptr, gameserveritem_t server);
		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		private delegate void InternalServerFailedToRespond(IntPtr thisptr);
		private void InternalOnServerResponded(IntPtr thisptr, gameserveritem_t server) {
			m_ServerResponded(server);
		}
		private void InternalOnServerFailedToRespond(IntPtr thisptr) {
			m_ServerFailedToRespond();
		}
#endif

		[StructLayout(LayoutKind.Sequential)]
		private class VTable {
			[NonSerialized]
			[MarshalAs(UnmanagedType.FunctionPtr)]
			public InternalServerResponded m_VTServerResponded;

			[NonSerialized]
			[MarshalAs(UnmanagedType.FunctionPtr)]
			public InternalServerFailedToRespond m_VTServerFailedToRespond;
		}

		public static explicit operator System.IntPtr(ISteamMatchmakingPingResponse that) {
			return that.m_pGCHandle.AddrOfPinnedObject();
		}
	};

	//-----------------------------------------------------------------------------
	// Purpose: Callback interface for receiving responses after requesting details on
	// who is playing on a particular server.
	// 目的：用于接收响应的回调接口，该接口用于在请求有关特定服务器上正在运行的玩家信息时接收响应结果。
	//
	// These callbacks all occur in response to querying an individual server
	// via the ISteamMatchmakingServers()->PlayerDetails() call below.  If you are
	// destructing an object that implements this interface then you should call
	// ISteamMatchmakingServers()->CancelServerQuery() passing in the handle to the query
	// which is in progress.  Failure to cancel in progress queries when destructing
	// a callback handler may result in a crash when a callback later occurs.
	// 这些回调操作都是在通过以下的 ISteamMatchmakingServers()->PlayerDetails() 调用查询单个服务器的过程中发生的。
	// 如果您正在销毁一个实现了此接口的对象，那么您应当调用 ISteamMatchmakingServers()->CancelServerQuery() 函数，
	// 并传入正在进行中的查询的句柄。如果在销毁回调处理程序时未能取消正在进行的查询，可能会导致后续回调发生时出现崩溃。
	//-----------------------------------------------------------------------------
	public class ISteamMatchmakingPlayersResponse {
		// Got data on a new player on the server -- you'll get this callback once per player
		// on the server which you have requested player data on.
		// 获取到了服务器上一位新玩家的相关信息——您每次请求获取某位玩家的数据时，
		// 服务器都会向您发送此回调信息，而您所请求获取数据的玩家数量是有限定的。
		public delegate void AddPlayerToList(string pchName, int nScore, float flTimePlayed);

		// The server failed to respond to the request for player details
		// 服务器未能响应获取玩家详细信息的请求。
		public delegate void PlayersFailedToRespond();

		// The server has finished responding to the player details request
		// (ie, you won't get anymore AddPlayerToList callbacks)
		// 服务器已完成对玩家详细信息请求的响应（也就是说，您将不再收到“添加玩家到列表”回调消息）
		public delegate void PlayersRefreshComplete();

		private VTable m_VTable;
		private IntPtr m_pVTable;
		private GCHandle m_pGCHandle;
		private AddPlayerToList m_AddPlayerToList;
		private PlayersFailedToRespond m_PlayersFailedToRespond;
		private PlayersRefreshComplete m_PlayersRefreshComplete;

		public ISteamMatchmakingPlayersResponse(AddPlayerToList onAddPlayerToList, PlayersFailedToRespond onPlayersFailedToRespond, PlayersRefreshComplete onPlayersRefreshComplete) {
			if (onAddPlayerToList == null || onPlayersFailedToRespond == null || onPlayersRefreshComplete == null) {
				throw new ArgumentNullException();
			}
			m_AddPlayerToList = onAddPlayerToList;
			m_PlayersFailedToRespond = onPlayersFailedToRespond;
			m_PlayersRefreshComplete = onPlayersRefreshComplete;

			m_VTable = new VTable() {
				m_VTAddPlayerToList = InternalOnAddPlayerToList,
				m_VTPlayersFailedToRespond = InternalOnPlayersFailedToRespond,
				m_VTPlayersRefreshComplete = InternalOnPlayersRefreshComplete
			};
			m_pVTable = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(VTable)));
			Marshal.StructureToPtr(m_VTable, m_pVTable, false);

			m_pGCHandle = GCHandle.Alloc(m_pVTable, GCHandleType.Pinned);
		}

		~ISteamMatchmakingPlayersResponse() {
			if (m_pVTable != IntPtr.Zero) {
				Marshal.FreeHGlobal(m_pVTable);
			}

			if (m_pGCHandle.IsAllocated) {
				m_pGCHandle.Free();
			}
		}

#if NOTHISPTR
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void InternalAddPlayerToList(IntPtr pchName, int nScore, float flTimePlayed);
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void InternalPlayersFailedToRespond();
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void InternalPlayersRefreshComplete();
		private void InternalOnAddPlayerToList(IntPtr pchName, int nScore, float flTimePlayed) {
			m_AddPlayerToList(InteropHelp.PtrToStringUTF8(pchName), nScore, flTimePlayed);
		}
		private void InternalOnPlayersFailedToRespond() {
			m_PlayersFailedToRespond();
		}
		private void InternalOnPlayersRefreshComplete() {
			m_PlayersRefreshComplete();
		}
#else
		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		public delegate void InternalAddPlayerToList(IntPtr thisptr, IntPtr pchName, int nScore, float flTimePlayed);
		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		public delegate void InternalPlayersFailedToRespond(IntPtr thisptr);
		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		public delegate void InternalPlayersRefreshComplete(IntPtr thisptr);
		private void InternalOnAddPlayerToList(IntPtr thisptr, IntPtr pchName, int nScore, float flTimePlayed) {
			m_AddPlayerToList(InteropHelp.PtrToStringUTF8(pchName), nScore, flTimePlayed);
		}
		private void InternalOnPlayersFailedToRespond(IntPtr thisptr) {
			m_PlayersFailedToRespond();
		}
		private void InternalOnPlayersRefreshComplete(IntPtr thisptr) {
			m_PlayersRefreshComplete();
		}
#endif

		[StructLayout(LayoutKind.Sequential)]
		private class VTable {
			[NonSerialized]
			[MarshalAs(UnmanagedType.FunctionPtr)]
			public InternalAddPlayerToList m_VTAddPlayerToList;

			[NonSerialized]
			[MarshalAs(UnmanagedType.FunctionPtr)]
			public InternalPlayersFailedToRespond m_VTPlayersFailedToRespond;

			[NonSerialized]
			[MarshalAs(UnmanagedType.FunctionPtr)]
			public InternalPlayersRefreshComplete m_VTPlayersRefreshComplete;
		}

		public static explicit operator System.IntPtr(ISteamMatchmakingPlayersResponse that) {
			return that.m_pGCHandle.AddrOfPinnedObject();
		}
	};

	//-----------------------------------------------------------------------------
	// Purpose: Callback interface for receiving responses after requesting rules
	// details on a particular server.
	// 目的：用于在请求特定服务器的规则详情后接收响应的回调接口。
	//
	// These callbacks all occur in response to querying an individual server
	// via the ISteamMatchmakingServers()->ServerRules() call below.  If you are
	// destructing an object that implements this interface then you should call
	// ISteamMatchmakingServers()->CancelServerQuery() passing in the handle to the query
	// which is in progress.  Failure to cancel in progress queries when destructing
	// a callback handler may result in a crash when a callback later occurs.
	// 这些回调操作都是在通过以下的 ISteamMatchmakingServers()->ServerRules() 调用查询单个服务器的过程中发生的。
	// 如果您正在销毁一个实现了此接口的对象，那么您应当调用 ISteamMatchmakingServers()->CancelServerQuery() 函数，
	// 并传入正在进行中的查询的句柄。如果在销毁回调处理程序时未能取消正在进行的查询，可能会导致后续回调发生时出现崩溃。
	//-----------------------------------------------------------------------------
	public class ISteamMatchmakingRulesResponse {
		// Got data on a rule on the server -- you'll get one of these per rule defined on
		// the server you are querying
		// 在服务器上获取了有关某项规则的数据——您将根据所查询的服务器上定义的每项规则获得此类数据。
		public delegate void RulesResponded(string pchRule, string pchValue);

		// The server failed to respond to the request for rule details
		// 服务器未能响应关于规则详情的请求。
		public delegate void RulesFailedToRespond();

		// The server has finished responding to the rule details request
		// (ie, you won't get anymore RulesResponded callbacks)
		// 服务器已完成对规则详情请求的响应（也就是说，您将不再收到 RulesResponded 回调消息）
		public delegate void RulesRefreshComplete();

		private VTable m_VTable;
		private IntPtr m_pVTable;
		private GCHandle m_pGCHandle;
		private RulesResponded m_RulesResponded;
		private RulesFailedToRespond m_RulesFailedToRespond;
		private RulesRefreshComplete m_RulesRefreshComplete;

		public ISteamMatchmakingRulesResponse(RulesResponded onRulesResponded, RulesFailedToRespond onRulesFailedToRespond, RulesRefreshComplete onRulesRefreshComplete) {
			if (onRulesResponded == null || onRulesFailedToRespond == null || onRulesRefreshComplete == null) {
				throw new ArgumentNullException();
			}
			m_RulesResponded = onRulesResponded;
			m_RulesFailedToRespond = onRulesFailedToRespond;
			m_RulesRefreshComplete = onRulesRefreshComplete;

			m_VTable = new VTable() {
				m_VTRulesResponded = InternalOnRulesResponded,
				m_VTRulesFailedToRespond = InternalOnRulesFailedToRespond,
				m_VTRulesRefreshComplete = InternalOnRulesRefreshComplete
			};
			m_pVTable = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(VTable)));
			Marshal.StructureToPtr(m_VTable, m_pVTable, false);

			m_pGCHandle = GCHandle.Alloc(m_pVTable, GCHandleType.Pinned);
		}

		~ISteamMatchmakingRulesResponse() {
			if (m_pVTable != IntPtr.Zero) {
				Marshal.FreeHGlobal(m_pVTable);
			}

			if (m_pGCHandle.IsAllocated) {
				m_pGCHandle.Free();
			}
		}

#if NOTHISPTR
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void InternalRulesResponded(IntPtr pchRule, IntPtr pchValue);
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void InternalRulesFailedToRespond();
		[UnmanagedFunctionPointer(CallingConvention.StdCall)]
		public delegate void InternalRulesRefreshComplete();
		private void InternalOnRulesResponded(IntPtr pchRule, IntPtr pchValue) {
			m_RulesResponded(InteropHelp.PtrToStringUTF8(pchRule), InteropHelp.PtrToStringUTF8(pchValue));
		}
		private void InternalOnRulesFailedToRespond() {
			m_RulesFailedToRespond();
		}
		private void InternalOnRulesRefreshComplete() {
			m_RulesRefreshComplete();
		}
#else
		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		public delegate void InternalRulesResponded(IntPtr thisptr, IntPtr pchRule, IntPtr pchValue);
		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		public delegate void InternalRulesFailedToRespond(IntPtr thisptr);
		[UnmanagedFunctionPointer(CallingConvention.ThisCall)]
		public delegate void InternalRulesRefreshComplete(IntPtr thisptr);
		private void InternalOnRulesResponded(IntPtr thisptr, IntPtr pchRule, IntPtr pchValue) {
			m_RulesResponded(InteropHelp.PtrToStringUTF8(pchRule), InteropHelp.PtrToStringUTF8(pchValue));
		}
		private void InternalOnRulesFailedToRespond(IntPtr thisptr) {
			m_RulesFailedToRespond();
		}
		private void InternalOnRulesRefreshComplete(IntPtr thisptr) {
			m_RulesRefreshComplete();
		}
#endif

		[StructLayout(LayoutKind.Sequential)]
		private class VTable {
			[NonSerialized]
			[MarshalAs(UnmanagedType.FunctionPtr)]
			public InternalRulesResponded m_VTRulesResponded;

			[NonSerialized]
			[MarshalAs(UnmanagedType.FunctionPtr)]
			public InternalRulesFailedToRespond m_VTRulesFailedToRespond;

			[NonSerialized]
			[MarshalAs(UnmanagedType.FunctionPtr)]
			public InternalRulesRefreshComplete m_VTRulesRefreshComplete;
		}

		public static explicit operator System.IntPtr(ISteamMatchmakingRulesResponse that) {
			return that.m_pGCHandle.AddrOfPinnedObject();
		}
	};
}

#endif // !DISABLESTEAMWORKS
