// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	public static class SteamAPI {
		//----------------------------------------------------------------------------------------------------------------------------------------------------------//
		//	Steam API setup & shutdown
		//
		//	These functions manage loading, initializing and shutdown of the steamclient.dll
		//  这些功能负责管理 steamclient.dll 的加载、初始化以及关闭操作。
		//
		//----------------------------------------------------------------------------------------------------------------------------------------------------------//


		// Initializing the Steamworks SDK
		// -----------------------------
		//
		// There are three different methods you can use to initialize the Steamworks SDK, depending on
		// your project's environment. You should only use one method in your project.
		// 有三种不同的方法可供您使用来初始化 Steamworks SDK，具体取决于您的项目环境。在您的项目中，您只能使用其中一种方法。
		//
		// If you are able to include this C++ header in your project, we recommend using the following
		// initialization methods. They will ensure that all ISteam* interfaces defined in other
		// C++ header files have versions that are supported by the user's Steam Client:
		// - SteamAPI_InitEx() for new projects so you can show a detailed error message to the user
		// - SteamAPI_Init() for existing projects that only display a generic error message
		// 如果您能够在项目中引入此 C++ 头文件，我们建议采用以下初始化方法。
		// 这些方法将确保其他 C++ 头文件中定义的所有 ISteam* 接口都有用户 Steam 客户端能够支持的版本：
		// - 对于新项目，使用 SteamAPI_InitEx() 函数可以让您向用户显示详细的错误信息。
		// - 对于那些仅显示通用错误信息的现有项目，使用“SteamAPI_Init()”函数
		//
		// If you are unable to include this C++ header in your project and are dynamically loading
		// Steamworks SDK methods from dll/so, you can use the following method:
		// 如果您无法将此 C++ 头文件包含到您的项目中，并且是通过动态加载 dll 或 so 文件来加载 Steamworks SDK 方法的话，您可以使用以下方法：
		// - SteamAPI_InitFlat()


		// See "Initializing the Steamworks SDK" above for how to choose an init method.
		// On success k_ESteamAPIInitResult_OK is returned. Otherwise, returns a value that can be used
		// to create a localized error message for the user. If pOutErrMsg is non-NULL,
		// it will receive an example error message, in English, that explains the reason for the failure.
		// 请参阅上述“初始化 Steamworks SDK”部分，以了解如何选择初始化方法。
		// 如果操作成功，将返回值 k_ESteamAPIInitResult_OK。
		// 否则，将返回一个可用于为用户创建本地化错误消息的值。
		// 如果 pOutErrMsg 不为 NULL，则它将接收到一个用英语编写的示例错误消息，该消息解释了失败的原因。
		//
		// Example usage:
		//
		//   SteamErrMsg errMsg;
		//   if ( SteamAPI_Init(&errMsg) != k_ESteamAPIInitResult_OK )
		//       FatalError( "Failed to init Steam.  %s", errMsg );

		// See "Initializing the Steamworks SDK" above for how to choose an init method.
		// 请参阅上述“初始化 Steamworks SDK”部分，以了解如何选择初始化方法。
		// Returns true on success
		public static ESteamAPIInitResult InitEx(out string OutSteamErrMsg)
		{
			InteropHelp.TestIfPlatformSupported();

			var pszInternalCheckInterfaceVersions = new System.Text.StringBuilder();
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMUTILS_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMNETWORKINGUTILS_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMAPPS_INTERFACE_VERSION).Append("\0");
			// ISteamController is deprecated in favor of ISteamInput.
			// ISteamController 已被弃用，取而代之的是 ISteamInput。
			//pszInternalCheckInterfaceVersions.Append(Constants.STEAMCONTROLLER_INTERFACE_VERSION).Append("\0"); 
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMFRIENDS_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMGAMESEARCH_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMHTMLSURFACE_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMHTTP_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMINPUT_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMINVENTORY_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMMATCHMAKINGSERVERS_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMMATCHMAKING_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMMUSICREMOTE_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMMUSIC_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMNETWORKINGMESSAGES_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMNETWORKINGSOCKETS_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMNETWORKING_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMPARENTALSETTINGS_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMPARTIES_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMREMOTEPLAY_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMREMOTESTORAGE_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMSCREENSHOTS_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMUGC_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMUSERSTATS_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMUSER_INTERFACE_VERSION).Append("\0");
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMVIDEO_INTERFACE_VERSION).Append("\0");

			using (var pszInternalCheckInterfaceVersions2 = new InteropHelp.UTF8StringHandle(pszInternalCheckInterfaceVersions.ToString())) {
				IntPtr SteamErrorMsgPtr = Marshal.AllocHGlobal(Constants.k_cchMaxSteamErrMsg);
				ESteamAPIInitResult initResult = NativeMethods.SteamInternal_SteamAPI_Init(pszInternalCheckInterfaceVersions2, SteamErrorMsgPtr);
				OutSteamErrMsg = InteropHelp.PtrToStringUTF8(SteamErrorMsgPtr);
				Marshal.FreeHGlobal(SteamErrorMsgPtr);

				// Steamworks.NET specific: We initialize the SteamAPI Context like this for now, but we need to do it
				// every time that Unity reloads binaries, so we also check if the pointers are available and initialized
				// before each call to any interface functions. That is in InteropHelp.cs
				// 针对 Steamworks.NET 特性：目前我们是这样初始化 SteamAPI 上下文的，但每次 Unity 重新加载二进制文件时都需要进行此操作，
				// 所以我们还会在每次调用任何接口函数之前检查指针是否可用且已初始化。这部分内容位于 InteropHelp.cs 文件中。
				if (initResult == ESteamAPIInitResult.k_ESteamAPIInitResult_OK)
				{
					bool ret = CSteamAPIContext.Init();
					if (ret) {
						CallbackDispatcher.Initialize();
					}
					else {
						initResult = ESteamAPIInitResult.k_ESteamAPIInitResult_FailedGeneric;
						OutSteamErrMsg = "[Steamworks.NET] Failed to initialize CSteamAPIContext";
					}
				}

				return initResult;
			}
		}

		public static bool Init() {
			InteropHelp.TestIfPlatformSupported();

			string SteamErrorMsg;
			return InitEx(out SteamErrorMsg) == ESteamAPIInitResult.k_ESteamAPIInitResult_OK;
		}

		// SteamAPI_Shutdown should be called during process shutdown if possible.
		// 如果可能的话，在程序关闭时应调用 SteamAPI_Shutdown 函数。
		public static void Shutdown() {
			InteropHelp.TestIfPlatformSupported();
			NativeMethods.SteamAPI_Shutdown();
			CSteamAPIContext.Clear();
			CallbackDispatcher.Shutdown();
		}

		// SteamAPI_RestartAppIfNecessary ensures that your executable was launched through Steam.
		// “SteamAPI_RestartAppIfNecessary”函数的作用是确保您的可执行文件是通过 Steam 启动的。
		//
		// Returns true if the current process should terminate. Steam is now re-launching your application.
		// 如果当前进程应终止，则返回真值。现在，Steam 正在重新启动您的应用程序。
		//
		// Returns false if no action needs to be taken. This means that your executable was started through
		// the Steam client, or a steam_appid.txt file is present in your game's directory (for development).
		// Your current process should continue if false is returned.
		// 如果无需采取任何操作，则返回 false。这意味着您的可执行文件是通过 Steam 客户端启动的，
		// 或者您的游戏目录中存在 steam_appid.txt 文件（用于开发）。如果返回 false，则您的当前进程应继续运行。
		//
		// NOTE: If you use the Steam DRM wrapper on your primary executable file, this check is unnecessary
		// since the DRM wrapper will ensure that your application was launched properly through Steam.
		// 注意：如果您在主可执行文件中使用了 Steam DRM 封装程序，那么此检查就无需进行，
		// 因为 DRM 封装程序会确保您的应用程序是通过 Steam 正确启动的。
		public static bool RestartAppIfNecessary(AppId_t unOwnAppID) {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamAPI_RestartAppIfNecessary(unOwnAppID);
		}

		// Many Steam API functions allocate a small amount of thread-local memory for parameter storage.
		// SteamAPI_ReleaseCurrentThreadMemory() will free API memory associated with the calling thread.
		// This function is also called automatically by SteamAPI_RunCallbacks(), so a single-threaded
		// program never needs to explicitly call this function.
		// 许多 Steam API 函数会为参数存储分配少量的线程局部内存。而 SteamAPI_ReleaseCurrentThreadMemory() 
		// 函数则会释放与调用线程相关的 API 内存。此函数也会由 SteamAPI_RunCallbacks() 自动调用，因此单线程程序无需显式调用此函数。
		public static void ReleaseCurrentThreadMemory() {
			InteropHelp.TestIfPlatformSupported();
			NativeMethods.SteamAPI_ReleaseCurrentThreadMemory();
		}

		//----------------------------------------------------------------------------------------------------------------------------------------------------------//
		//	steam callback and call-result helpers
		// steam回调和调用结果辅助函数
		//
		//	The following macros and classes are used to register your application for
		//	callbacks and call-results, which are delivered in a predictable manner.
		//  以下的宏和类用于为您的应用程序注册回调和调用结果，并且这些结果将以可预测的方式进行传递。
		//
		//	STEAM_CALLBACK macros are meant for use inside of a C++ class definition.
		//	They map a Steam notification callback directly to a class member function
		//	which is automatically prototyped as "void func( callback_type *pParam )".
		//  STEAM_CALLBACK 宏用于在 C++ 类定义内部使用。他们将 Steam 通知回调直接映射到一个类成员函数上，
		//  该函数会自动被编译为“void func( callback_type *pParam )”的格式。
		//
		//	CCallResult is used with specific Steam APIs that return "result handles".
		//	The handle can be passed to a CCallResult object's Set function, along with
		//	an object pointer and member-function pointer. The member function will
		//	be executed once the results of the Steam API call are available.
		//  CCallResult 与特定的 Steam API 结合使用，这些 API 会返回“结果句柄”。
		//  该句柄可以传递给 CCallResult 对象的 Set 函数，同时还需要提供一个对象指针和成员函数指针。
		//  当 Steam API 调用的结果可用时，该成员函数将被执行。
		//
		//	CCallback and CCallbackManual classes can be used instead of STEAM_CALLBACK
		//	macros if you require finer control over registration and unregistration.
		//  如果您希望对注册和注销操作有更精细的控制，那么可以使用 CCallback 和 CCallbackManual 类，
		//  而无需使用 STEAM_CALLBACK 宏。
		//
		//	Callbacks and call-results are queued automatically and are only
		//	delivered/executed when your application calls SteamAPI_RunCallbacks().
		//  回调函数和回调结果会自动排队，只有在您的应用程序调用 SteamAPI_RunCallbacks() 时才会进行传递/执行。
		//
		//	Note that there is an alternative, lower level callback dispatch mechanism.
		//  请注意，还有一种更低层级的回调调度机制可供选择。
		//	See SteamAPI_ManualDispatch_Init
		//----------------------------------------------------------------------------------------------------------------------------------------------------------//

		// Dispatch all queued Steamworks callbacks.
		// 执行所有排队的 Steamworks 回调操作。
		//
		// This is safe to call from multiple threads simultaneously,
		// but if you choose to do this, callback code could be executed on any thread.
		// One alternative is to call SteamAPI_RunCallbacks from the main thread only,
		// and call SteamAPI_ReleaseCurrentThreadMemory regularly on other threads.
		// 从多个线程同时调用此函数是安全的，但如果您选择这样做，回调代码可能会在任何线程上执行。
		// 一种可行的方法是仅在主线程中调用 SteamAPI_RunCallbacks 函数，
		// 而在其他线程中定期调用 SteamAPI_ReleaseCurrentThreadMemory 函数。
		public static void RunCallbacks() {
			CallbackDispatcher.RunFrame(false);
		}

		//----------------------------------------------------------------------------------------------------------------------------------------------------------//
		//	steamclient.dll private wrapper functions
		//  steamclient.dll 私有包装函数
		//
		//	The following functions are part of abstracting API access to the steamclient.dll, but should only be used in very specific cases
		//  以下功能是将 API 访问抽象化到 steamclient.dll 中的一部分，但仅应在非常特殊的情况下使用。
		//----------------------------------------------------------------------------------------------------------------------------------------------------------//

		// SteamAPI_IsSteamRunning() returns true if Steam is currently running
		// SteamAPI_IsSteamRunning() 函数若检测到 Steam 正在运行，则返回值为真。
		public static bool IsSteamRunning() {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamAPI_IsSteamRunning();
		}

		// returns the pipe we are communicating to Steam with
		// 返回我们用于与 Steam 进行通信的管道
		public static HSteamPipe GetHSteamPipe() {
			InteropHelp.TestIfPlatformSupported();
			return (HSteamPipe)NativeMethods.SteamAPI_GetHSteamPipe();
		}

		public static HSteamUser GetHSteamUser() {
			InteropHelp.TestIfPlatformSupported();
			return (HSteamUser)NativeMethods.SteamAPI_GetHSteamUser();
		}
	}

	public static class GameServer {
		// Initialize SteamGameServer client and interface objects, and set server properties which may not be changed.
		// 初始化 SteamGameServer 客户端和接口对象，并设置一些不可更改的服务器属性。
		//
		// After calling this function, you should set any additional server parameters, and then
		// call ISteamGameServer::LogOnAnonymous() or ISteamGameServer::LogOn()
		// 调用此函数后，您需要设置任何其他服务器参数，
		// 然后调用 ISteamGameServer::LogOnAnonymous() 或 ISteamGameServer::LogOn() 方法。
		//
		// - unIP will usually be zero.  If you are on a machine with multiple IP addresses, you can pass a non-zero
		//   value here and the relevant sockets will be bound to that IP.  This can be used to ensure that
		//   the IP you desire is the one used in the server browser.
		// - usGamePort is the port that clients will connect to for gameplay.  You will usually open up your
		//   own socket bound to this port.
		// - usQueryPort is the port that will manage server browser related duties and info
		//		pings from clients.  If you pass STEAMGAMESERVER_QUERY_PORT_SHARED for usQueryPort, then it
		//		will use "GameSocketShare" mode, which means that the game is responsible for sending and receiving
		//		UDP packets for the master  server updater.  (See ISteamGameServer::HandleIncomingPacket and
		//		ISteamGameServer::GetNextOutgoingPacket.)
		// - The version string should be in the form x.x.x.x, and is used by the master server to detect when the
		//		server is out of date.  (Only servers with the latest version will be listed.)
		// - unIP 通常为零值。如果您所使用的计算机具有多个 IP 地址，您可以在此处输入非零值，
		//   这样相关的套接字就会绑定到该 IP 地址上。此功能可用于确保您所期望的 IP 地址正是服务器浏览器中所使用的那个。
		// - usGamePort 是客户端进行游戏操作时所连接的端口。通常您需要打开自己的套接字，并将其绑定到此端口上。
		// - “usQueryPort”是负责管理服务器浏览器相关任务以及接收客户端信息推送的端口。若将“STEAMGAMESERVER_QUERY_PORT_SHARED”
		//   作为“usQueryPort”的值传递，则系统将采用“GameSocketShare”模式，这意味着游戏将负责为主服务器更新程序发送和接收 UDP 数据包。
		//  （请参阅 ISteamGameServer::HandleIncomingPacket 和 ISteamGameServer::GetNextOutgoingPacket）
		// - 版本字符串应采用“x.x.x.x”的格式，并且由主服务器使用，用于检测服务器是否已过时。（只有拥有最新版本的服务器才会被列出。）
		public static ESteamAPIInitResult InitEx(uint unIP, ushort usGamePort, ushort usQueryPort, EServerMode eServerMode, string pchVersionString, out string OutSteamErrMsg) {
			InteropHelp.TestIfPlatformSupported();

			var pszInternalCheckInterfaceVersions = new System.Text.StringBuilder();
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMUTILS_INTERFACE_VERSION).Append('\0');
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMNETWORKINGUTILS_INTERFACE_VERSION).Append('\0');
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMGAMESERVER_INTERFACE_VERSION).Append('\0');
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMGAMESERVERSTATS_INTERFACE_VERSION).Append('\0');
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMHTTP_INTERFACE_VERSION).Append('\0');
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMINVENTORY_INTERFACE_VERSION).Append('\0');
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMNETWORKING_INTERFACE_VERSION).Append('\0');
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMNETWORKINGMESSAGES_INTERFACE_VERSION).Append('\0');
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMNETWORKINGSOCKETS_INTERFACE_VERSION).Append('\0');
			pszInternalCheckInterfaceVersions.Append(Constants.STEAMUGC_INTERFACE_VERSION).Append('\0');

			using (var pchVersionString2 = new InteropHelp.UTF8StringHandle(pchVersionString))
			using (var pszInternalCheckInterfaceVersions2 = new InteropHelp.UTF8StringHandle(pszInternalCheckInterfaceVersions.ToString())) {
				IntPtr SteamErrorMsgPtr = Marshal.AllocHGlobal(Constants.k_cchMaxSteamErrMsg);
				ESteamAPIInitResult initResult = NativeMethods.SteamInternal_GameServer_Init_V2(unIP, usGamePort, usQueryPort, eServerMode, pchVersionString2, pszInternalCheckInterfaceVersions2, SteamErrorMsgPtr);
				OutSteamErrMsg = InteropHelp.PtrToStringUTF8(SteamErrorMsgPtr);
				Marshal.FreeHGlobal(SteamErrorMsgPtr);

				// Steamworks.NET specific: We initialize the SteamAPI Context like this for now, but we need to do it
				// every time that Unity reloads binaries, so we also check if the pointers are available and initialized
				// before each call to any interface functions. That is in InteropHelp.cs
				// 针对 Steamworks.NET 特性：目前我们是这样初始化 SteamAPI 上下文的，但每次 Unity 重新加载二进制文件时都需要进行此操作，
				// 所以我们还会在每次调用任何接口函数之前检查指针是否可用且已初始化。这在 InteropHelp.cs 文件中有所体现。
				if (initResult == ESteamAPIInitResult.k_ESteamAPIInitResult_OK)
				{
					bool ret = CSteamGameServerAPIContext.Init();
					if (ret) {
						CallbackDispatcher.Initialize();
					}
					else {
						initResult = ESteamAPIInitResult.k_ESteamAPIInitResult_FailedGeneric;
						OutSteamErrMsg = "[Steamworks.NET] Failed to initialize CSteamAPIContext";
					}
				}

				return initResult;
			}
		}

		// This function is included for compatibility with older SDK.
		// You can use it if you don't care about decent error handling
		// 此功能的设置是为了与较旧的 SDK 兼容。如果您不关心良好的错误处理机制，也可以使用它。
		public static bool Init(uint unIP, ushort usGamePort, ushort usQueryPort, EServerMode eServerMode, string pchVersionString) {
			InteropHelp.TestIfPlatformSupported();

			string SteamErrorMsg;
			return InitEx(unIP, usGamePort, usQueryPort, eServerMode, pchVersionString, out SteamErrorMsg) == ESteamAPIInitResult.k_ESteamAPIInitResult_OK;
		}

		// Shutdown SteamGameSeverXxx interfaces, log out, and free resources.
		// 关闭 Steam 游戏服务器 xxx 的接口，退出登录，并释放资源。
		public static void Shutdown() {
			InteropHelp.TestIfPlatformSupported();
			NativeMethods.SteamGameServer_Shutdown();
			CSteamGameServerAPIContext.Clear();
			CallbackDispatcher.Shutdown();
		}

		public static void RunCallbacks() {
			CallbackDispatcher.RunFrame(true);
		}

		// Most Steam API functions allocate some amount of thread-local memory for
		// parameter storage. Calling SteamGameServer_ReleaseCurrentThreadMemory()
		// will free all API-related memory associated with the calling thread.
		// This memory is released automatically by SteamGameServer_RunCallbacks(),
		// so single-threaded servers do not need to explicitly call this function.
		// 大多数 Steam API 函数都会为参数存储分配一定量的线程局部内存。
		// 调用 SteamGameServer_ReleaseCurrentThreadMemory() 
		// 将会释放与调用线程相关的所有与 API 相关的内存。
		// 此内存会由 SteamGameServer_RunCallbacks() 自动释放，
		// 因此单线程服务器无需显式调用此函数。
		public static void ReleaseCurrentThreadMemory() {
			InteropHelp.TestIfPlatformSupported();
			NativeMethods.SteamGameServer_ReleaseCurrentThreadMemory();
		}

		public static bool BSecure() {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamGameServer_BSecure();
		}

		public static CSteamID GetSteamID() {
			InteropHelp.TestIfPlatformSupported();
			return (CSteamID)NativeMethods.SteamGameServer_GetSteamID();
		}

		public static HSteamPipe GetHSteamPipe() {
			InteropHelp.TestIfPlatformSupported();
			return (HSteamPipe)NativeMethods.SteamGameServer_GetHSteamPipe();
		}

		public static HSteamUser GetHSteamUser() {
			InteropHelp.TestIfPlatformSupported();
			return (HSteamUser)NativeMethods.SteamGameServer_GetHSteamUser();
		}
	}

	public static class SteamEncryptedAppTicket {
		public static bool BDecryptTicket(byte[] rgubTicketEncrypted, uint cubTicketEncrypted, byte[] rgubTicketDecrypted, ref uint pcubTicketDecrypted, byte[] rgubKey, int cubKey) {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamEncryptedAppTicket_BDecryptTicket(rgubTicketEncrypted, cubTicketEncrypted, rgubTicketDecrypted, ref pcubTicketDecrypted, rgubKey, cubKey);
		}

		public static bool BIsTicketForApp(byte[] rgubTicketDecrypted, uint cubTicketDecrypted, AppId_t nAppID) {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamEncryptedAppTicket_BIsTicketForApp(rgubTicketDecrypted, cubTicketDecrypted, nAppID);
		}

		public static uint GetTicketIssueTime(byte[] rgubTicketDecrypted, uint cubTicketDecrypted) {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamEncryptedAppTicket_GetTicketIssueTime(rgubTicketDecrypted, cubTicketDecrypted);
		}

		public static void GetTicketSteamID(byte[] rgubTicketDecrypted, uint cubTicketDecrypted, out CSteamID psteamID) {
			InteropHelp.TestIfPlatformSupported();
			NativeMethods.SteamEncryptedAppTicket_GetTicketSteamID(rgubTicketDecrypted, cubTicketDecrypted, out psteamID);
		}

		public static uint GetTicketAppID(byte[] rgubTicketDecrypted, uint cubTicketDecrypted) {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamEncryptedAppTicket_GetTicketAppID(rgubTicketDecrypted, cubTicketDecrypted);
		}

		public static bool BUserOwnsAppInTicket(byte[] rgubTicketDecrypted, uint cubTicketDecrypted, AppId_t nAppID) {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamEncryptedAppTicket_BUserOwnsAppInTicket(rgubTicketDecrypted, cubTicketDecrypted, nAppID);
		}

		public static bool BUserIsVacBanned(byte[] rgubTicketDecrypted, uint cubTicketDecrypted) {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamEncryptedAppTicket_BUserIsVacBanned(rgubTicketDecrypted, cubTicketDecrypted);
		}

		public static byte[] GetUserVariableData(byte[] rgubTicketDecrypted, uint cubTicketDecrypted, out uint pcubUserData) {
			InteropHelp.TestIfPlatformSupported();
			IntPtr punSecretData = NativeMethods.SteamEncryptedAppTicket_GetUserVariableData(rgubTicketDecrypted, cubTicketDecrypted, out pcubUserData);
			byte[] ret = new byte[pcubUserData];
			System.Runtime.InteropServices.Marshal.Copy(punSecretData, ret, 0, (int)pcubUserData);
			return ret;
		}

		public static bool BIsTicketSigned(byte[] rgubTicketDecrypted, uint cubTicketDecrypted, byte[] pubRSAKey, uint cubRSAKey) {
			InteropHelp.TestIfPlatformSupported();
			return NativeMethods.SteamEncryptedAppTicket_BIsTicketSigned(rgubTicketDecrypted, cubTicketDecrypted, pubRSAKey, cubRSAKey);
		}
	}

	internal static class CSteamAPIContext {
		internal static void Clear() {
			m_pSteamClient = IntPtr.Zero;
			m_pSteamUser = IntPtr.Zero;
			m_pSteamFriends = IntPtr.Zero;
			m_pSteamUtils = IntPtr.Zero;
			m_pSteamMatchmaking = IntPtr.Zero;
			m_pSteamUserStats = IntPtr.Zero;
			m_pSteamApps = IntPtr.Zero;
			m_pSteamMatchmakingServers = IntPtr.Zero;
			m_pSteamNetworking = IntPtr.Zero;
			m_pSteamRemoteStorage = IntPtr.Zero;
			m_pSteamHTTP = IntPtr.Zero;
			m_pSteamScreenshots = IntPtr.Zero;
			m_pSteamGameSearch = IntPtr.Zero;
			m_pSteamMusic = IntPtr.Zero;
			m_pController = IntPtr.Zero;
			m_pSteamUGC = IntPtr.Zero;
			m_pSteamMusic = IntPtr.Zero;
			m_pSteamMusicRemote = IntPtr.Zero;
			m_pSteamHTMLSurface = IntPtr.Zero;
			m_pSteamInventory = IntPtr.Zero;
			m_pSteamVideo = IntPtr.Zero;
			m_pSteamParentalSettings = IntPtr.Zero;
			m_pSteamInput = IntPtr.Zero;
			m_pSteamParties = IntPtr.Zero;
			m_pSteamRemotePlay = IntPtr.Zero;
			m_pSteamNetworkingUtils = IntPtr.Zero;
			m_pSteamNetworkingSockets = IntPtr.Zero;
			m_pSteamNetworkingMessages = IntPtr.Zero;
			m_pSteamTimeline = IntPtr.Zero;
		}

		internal static bool Init() {
			HSteamUser hSteamUser = SteamAPI.GetHSteamUser();
			HSteamPipe hSteamPipe = SteamAPI.GetHSteamPipe();
			if (hSteamPipe == (HSteamPipe)0) { return false; }

			using (var pchVersionString = new InteropHelp.UTF8StringHandle(Constants.STEAMCLIENT_INTERFACE_VERSION)) {
				m_pSteamClient = NativeMethods.SteamInternal_CreateInterface(pchVersionString);
			}

			if (m_pSteamClient == IntPtr.Zero) { return false; }

			m_pSteamUser = SteamClient.GetISteamUser(hSteamUser, hSteamPipe, Constants.STEAMUSER_INTERFACE_VERSION);
			if (m_pSteamUser == IntPtr.Zero) { return false; }

			m_pSteamFriends = SteamClient.GetISteamFriends(hSteamUser, hSteamPipe, Constants.STEAMFRIENDS_INTERFACE_VERSION);
			if (m_pSteamFriends == IntPtr.Zero) { return false; }

			m_pSteamUtils = SteamClient.GetISteamUtils(hSteamPipe, Constants.STEAMUTILS_INTERFACE_VERSION);
			if (m_pSteamUtils == IntPtr.Zero) { return false; }

			m_pSteamMatchmaking = SteamClient.GetISteamMatchmaking(hSteamUser, hSteamPipe, Constants.STEAMMATCHMAKING_INTERFACE_VERSION);
			if (m_pSteamMatchmaking == IntPtr.Zero) { return false; }

			m_pSteamMatchmakingServers = SteamClient.GetISteamMatchmakingServers(hSteamUser, hSteamPipe, Constants.STEAMMATCHMAKINGSERVERS_INTERFACE_VERSION);
			if (m_pSteamMatchmakingServers == IntPtr.Zero) { return false; }

			m_pSteamUserStats = SteamClient.GetISteamUserStats(hSteamUser, hSteamPipe, Constants.STEAMUSERSTATS_INTERFACE_VERSION);
			if (m_pSteamUserStats == IntPtr.Zero) { return false; }

			m_pSteamApps = SteamClient.GetISteamApps(hSteamUser, hSteamPipe, Constants.STEAMAPPS_INTERFACE_VERSION);
			if (m_pSteamApps == IntPtr.Zero) { return false; }

			m_pSteamNetworking = SteamClient.GetISteamNetworking(hSteamUser, hSteamPipe, Constants.STEAMNETWORKING_INTERFACE_VERSION);
			if (m_pSteamNetworking == IntPtr.Zero) { return false; }

			m_pSteamRemoteStorage = SteamClient.GetISteamRemoteStorage(hSteamUser, hSteamPipe, Constants.STEAMREMOTESTORAGE_INTERFACE_VERSION);
			if (m_pSteamRemoteStorage == IntPtr.Zero) { return false; }

			m_pSteamScreenshots = SteamClient.GetISteamScreenshots(hSteamUser, hSteamPipe, Constants.STEAMSCREENSHOTS_INTERFACE_VERSION);
			if (m_pSteamScreenshots == IntPtr.Zero) { return false; }

			m_pSteamGameSearch = SteamClient.GetISteamGameSearch(hSteamUser, hSteamPipe, Constants.STEAMGAMESEARCH_INTERFACE_VERSION);
			if (m_pSteamGameSearch == IntPtr.Zero) { return false; }

			m_pSteamHTTP = SteamClient.GetISteamHTTP(hSteamUser, hSteamPipe, Constants.STEAMHTTP_INTERFACE_VERSION);
			if (m_pSteamHTTP == IntPtr.Zero) { return false; }

			m_pSteamUGC = SteamClient.GetISteamUGC(hSteamUser, hSteamPipe, Constants.STEAMUGC_INTERFACE_VERSION);
			if (m_pSteamUGC == IntPtr.Zero) { return false; }

			m_pSteamMusic = SteamClient.GetISteamMusic(hSteamUser, hSteamPipe, Constants.STEAMMUSIC_INTERFACE_VERSION);
			if (m_pSteamMusic == IntPtr.Zero) { return false; }

			m_pSteamMusicRemote = SteamClient.GetISteamMusicRemote(hSteamUser, hSteamPipe, Constants.STEAMMUSICREMOTE_INTERFACE_VERSION);
			if (m_pSteamMusicRemote == IntPtr.Zero) { return false; }

			m_pSteamHTMLSurface = SteamClient.GetISteamHTMLSurface(hSteamUser, hSteamPipe, Constants.STEAMHTMLSURFACE_INTERFACE_VERSION);
			if (m_pSteamHTMLSurface == IntPtr.Zero) { return false; }

			m_pSteamInventory = SteamClient.GetISteamInventory(hSteamUser, hSteamPipe, Constants.STEAMINVENTORY_INTERFACE_VERSION);
			if (m_pSteamInventory == IntPtr.Zero) { return false; }

			m_pSteamVideo = SteamClient.GetISteamVideo(hSteamUser, hSteamPipe, Constants.STEAMVIDEO_INTERFACE_VERSION);
			if (m_pSteamVideo == IntPtr.Zero) { return false; }

			m_pSteamParentalSettings = SteamClient.GetISteamParentalSettings(hSteamUser, hSteamPipe, Constants.STEAMPARENTALSETTINGS_INTERFACE_VERSION);
			if (m_pSteamParentalSettings == IntPtr.Zero) { return false; }

			m_pSteamInput = SteamClient.GetISteamInput(hSteamUser, hSteamPipe, Constants.STEAMINPUT_INTERFACE_VERSION);
			if (m_pSteamInput == IntPtr.Zero) { return false; }

			m_pSteamParties = SteamClient.GetISteamParties(hSteamUser, hSteamPipe, Constants.STEAMPARTIES_INTERFACE_VERSION);
			if (m_pSteamParties == IntPtr.Zero) { return false; }

			m_pSteamRemotePlay = SteamClient.GetISteamRemotePlay(hSteamUser, hSteamPipe, Constants.STEAMREMOTEPLAY_INTERFACE_VERSION);
			if (m_pSteamRemotePlay == IntPtr.Zero) { return false; }

			using (var pchVersionString = new InteropHelp.UTF8StringHandle(Constants.STEAMNETWORKINGUTILS_INTERFACE_VERSION))
			{
				m_pSteamNetworkingUtils =
					NativeMethods.SteamInternal_FindOrCreateUserInterface(hSteamUser, pchVersionString) != IntPtr.Zero ?
					NativeMethods.SteamInternal_FindOrCreateUserInterface(hSteamUser, pchVersionString) :
					NativeMethods.SteamInternal_FindOrCreateGameServerInterface(hSteamUser, pchVersionString);
			}
			if (m_pSteamNetworkingUtils == IntPtr.Zero) { return false; }

			using (var pchVersionString = new InteropHelp.UTF8StringHandle(Constants.STEAMNETWORKINGSOCKETS_INTERFACE_VERSION))
			{
				m_pSteamNetworkingSockets = NativeMethods.SteamInternal_FindOrCreateUserInterface(hSteamUser, pchVersionString);
			}
			if (m_pSteamNetworkingSockets == IntPtr.Zero) { return false; }

			using (var pchVersionString = new InteropHelp.UTF8StringHandle(Constants.STEAMNETWORKINGMESSAGES_INTERFACE_VERSION))
			{
				m_pSteamNetworkingMessages = NativeMethods.SteamInternal_FindOrCreateUserInterface(hSteamUser, pchVersionString);
			}
			if (m_pSteamNetworkingMessages == IntPtr.Zero) { return false; }

			using (var pchVersionString = new InteropHelp.UTF8StringHandle(Constants.STEAMTIMELINE_INTERFACE_VERSION))
			{
				m_pSteamTimeline = NativeMethods.SteamInternal_FindOrCreateUserInterface(hSteamUser, pchVersionString);
			}
			if (m_pSteamTimeline == IntPtr.Zero) { return false; }

			return true;
		}

		internal static IntPtr GetSteamClient() { return m_pSteamClient; }
		internal static IntPtr GetSteamUser() { return m_pSteamUser; }
		internal static IntPtr GetSteamFriends() { return m_pSteamFriends; }
		internal static IntPtr GetSteamUtils() { return m_pSteamUtils; }
		internal static IntPtr GetSteamMatchmaking() { return m_pSteamMatchmaking; }
		internal static IntPtr GetSteamUserStats() { return m_pSteamUserStats; }
		internal static IntPtr GetSteamApps() { return m_pSteamApps; }
		internal static IntPtr GetSteamMatchmakingServers() { return m_pSteamMatchmakingServers; }
		internal static IntPtr GetSteamNetworking() { return m_pSteamNetworking; }
		internal static IntPtr GetSteamRemoteStorage() { return m_pSteamRemoteStorage; }
		internal static IntPtr GetSteamScreenshots() { return m_pSteamScreenshots; }
		internal static IntPtr GetSteamGameSearch() { return m_pSteamGameSearch; }
		internal static IntPtr GetSteamHTTP() { return m_pSteamHTTP; }
		internal static IntPtr GetSteamController() { return m_pController; }
		internal static IntPtr GetSteamUGC() { return m_pSteamUGC; }
		internal static IntPtr GetSteamMusic() { return m_pSteamMusic; }
		internal static IntPtr GetSteamMusicRemote() { return m_pSteamMusicRemote; }
		internal static IntPtr GetSteamHTMLSurface() { return m_pSteamHTMLSurface; }
		internal static IntPtr GetSteamInventory() { return m_pSteamInventory; }
		internal static IntPtr GetSteamVideo() { return m_pSteamVideo; }
		internal static IntPtr GetSteamParentalSettings() { return m_pSteamParentalSettings; }
		internal static IntPtr GetSteamInput() { return m_pSteamInput; }
		internal static IntPtr GetSteamParties() { return m_pSteamParties; }
		internal static IntPtr GetSteamRemotePlay() { return m_pSteamRemotePlay; }
		internal static IntPtr GetSteamNetworkingUtils() { return m_pSteamNetworkingUtils; }
		internal static IntPtr GetSteamNetworkingSockets() { return m_pSteamNetworkingSockets; }
		internal static IntPtr GetSteamNetworkingMessages() { return m_pSteamNetworkingMessages; }
		internal static IntPtr GetSteamTimeline() { return m_pSteamTimeline; }

		private static IntPtr m_pSteamClient;
		private static IntPtr m_pSteamUser;
		private static IntPtr m_pSteamFriends;
		private static IntPtr m_pSteamUtils;
		private static IntPtr m_pSteamMatchmaking;
		private static IntPtr m_pSteamUserStats;
		private static IntPtr m_pSteamApps;
		private static IntPtr m_pSteamMatchmakingServers;
		private static IntPtr m_pSteamNetworking;
		private static IntPtr m_pSteamRemoteStorage;
		private static IntPtr m_pSteamScreenshots;
		private static IntPtr m_pSteamGameSearch;
		private static IntPtr m_pSteamHTTP;
		private static IntPtr m_pController;
		private static IntPtr m_pSteamUGC;
		private static IntPtr m_pSteamMusic;
		private static IntPtr m_pSteamMusicRemote;
		private static IntPtr m_pSteamHTMLSurface;
		private static IntPtr m_pSteamInventory;
		private static IntPtr m_pSteamVideo;
		private static IntPtr m_pSteamParentalSettings;
		private static IntPtr m_pSteamInput;
		private static IntPtr m_pSteamParties;
		private static IntPtr m_pSteamRemotePlay;
		private static IntPtr m_pSteamNetworkingUtils;
		private static IntPtr m_pSteamNetworkingSockets;
		private static IntPtr m_pSteamNetworkingMessages;
		private static IntPtr m_pSteamTimeline;
	}

	internal static class CSteamGameServerAPIContext {
		internal static void Clear() {
			m_pSteamClient = IntPtr.Zero;
			m_pSteamGameServer = IntPtr.Zero;
			m_pSteamUtils = IntPtr.Zero;
			m_pSteamNetworking = IntPtr.Zero;
			m_pSteamGameServerStats = IntPtr.Zero;
			m_pSteamHTTP = IntPtr.Zero;
			m_pSteamInventory = IntPtr.Zero;
			m_pSteamUGC = IntPtr.Zero;
			m_pSteamNetworkingUtils = IntPtr.Zero;
			m_pSteamNetworkingSockets = IntPtr.Zero;
			m_pSteamNetworkingMessages = IntPtr.Zero;
	}

		internal static bool Init() {
			HSteamUser hSteamUser = GameServer.GetHSteamUser();
			HSteamPipe hSteamPipe = GameServer.GetHSteamPipe();
			if (hSteamPipe == (HSteamPipe)0) { return false; }

			using (var pchVersionString = new InteropHelp.UTF8StringHandle(Constants.STEAMCLIENT_INTERFACE_VERSION)) {
				m_pSteamClient = NativeMethods.SteamInternal_CreateInterface(pchVersionString);
			}
			if (m_pSteamClient == IntPtr.Zero) { return false; }

			m_pSteamGameServer = SteamGameServerClient.GetISteamGameServer(hSteamUser, hSteamPipe, Constants.STEAMGAMESERVER_INTERFACE_VERSION);
			if (m_pSteamGameServer == IntPtr.Zero) { return false; }

			m_pSteamUtils = SteamGameServerClient.GetISteamUtils(hSteamPipe, Constants.STEAMUTILS_INTERFACE_VERSION);
			if (m_pSteamUtils == IntPtr.Zero) { return false; }

			m_pSteamNetworking = SteamGameServerClient.GetISteamNetworking(hSteamUser, hSteamPipe, Constants.STEAMNETWORKING_INTERFACE_VERSION);
			if (m_pSteamNetworking == IntPtr.Zero) { return false; }

			m_pSteamGameServerStats = SteamGameServerClient.GetISteamGameServerStats(hSteamUser, hSteamPipe, Constants.STEAMGAMESERVERSTATS_INTERFACE_VERSION);
			if (m_pSteamGameServerStats == IntPtr.Zero) { return false; }

			m_pSteamHTTP = SteamGameServerClient.GetISteamHTTP(hSteamUser, hSteamPipe, Constants.STEAMHTTP_INTERFACE_VERSION);
			if (m_pSteamHTTP == IntPtr.Zero) { return false; }

			m_pSteamInventory = SteamGameServerClient.GetISteamInventory(hSteamUser, hSteamPipe, Constants.STEAMINVENTORY_INTERFACE_VERSION);
			if (m_pSteamInventory == IntPtr.Zero) { return false; }

			m_pSteamUGC = SteamGameServerClient.GetISteamUGC(hSteamUser, hSteamPipe, Constants.STEAMUGC_INTERFACE_VERSION);
			if (m_pSteamUGC == IntPtr.Zero) { return false; }

			using (var pchVersionString = new InteropHelp.UTF8StringHandle(Constants.STEAMNETWORKINGUTILS_INTERFACE_VERSION))
			{
				m_pSteamNetworkingUtils =
					NativeMethods.SteamInternal_FindOrCreateUserInterface(hSteamUser, pchVersionString) != IntPtr.Zero ?
					NativeMethods.SteamInternal_FindOrCreateUserInterface(hSteamUser, pchVersionString) :
					NativeMethods.SteamInternal_FindOrCreateGameServerInterface(hSteamUser, pchVersionString);
			}
			if (m_pSteamNetworkingUtils == IntPtr.Zero) { return false; }

			using (var pchVersionString = new InteropHelp.UTF8StringHandle(Constants.STEAMNETWORKINGSOCKETS_INTERFACE_VERSION))
			{
				m_pSteamNetworkingSockets =
					NativeMethods.SteamInternal_FindOrCreateGameServerInterface(hSteamUser, pchVersionString);
			}
			if (m_pSteamNetworkingSockets == IntPtr.Zero) { return false; }

			using (var pchVersionString = new InteropHelp.UTF8StringHandle(Constants.STEAMNETWORKINGMESSAGES_INTERFACE_VERSION))
			{
				m_pSteamNetworkingMessages =
					NativeMethods.SteamInternal_FindOrCreateGameServerInterface(hSteamUser, pchVersionString);
			}
			if (m_pSteamNetworkingMessages == IntPtr.Zero) { return false; }

			return true;
		}

		internal static IntPtr GetSteamClient() { return m_pSteamClient; }
		internal static IntPtr GetSteamGameServer() { return m_pSteamGameServer; }
		internal static IntPtr GetSteamUtils() { return m_pSteamUtils; }
		internal static IntPtr GetSteamNetworking() { return m_pSteamNetworking; }
		internal static IntPtr GetSteamGameServerStats() { return m_pSteamGameServerStats; }
		internal static IntPtr GetSteamHTTP() { return m_pSteamHTTP; }
		internal static IntPtr GetSteamInventory() { return m_pSteamInventory; }
		internal static IntPtr GetSteamUGC() { return m_pSteamUGC; }
		internal static IntPtr GetSteamNetworkingUtils() { return m_pSteamNetworkingUtils; }
		internal static IntPtr GetSteamNetworkingSockets() { return m_pSteamNetworkingSockets; }
		internal static IntPtr GetSteamNetworkingMessages() { return m_pSteamNetworkingMessages; }

		private static IntPtr m_pSteamClient;
		private static IntPtr m_pSteamGameServer;
		private static IntPtr m_pSteamUtils;
		private static IntPtr m_pSteamNetworking;
		private static IntPtr m_pSteamGameServerStats;
		private static IntPtr m_pSteamHTTP;
		private static IntPtr m_pSteamInventory;
		private static IntPtr m_pSteamUGC;
		private static IntPtr m_pSteamNetworkingUtils;
		private static IntPtr m_pSteamNetworkingSockets;
		private static IntPtr m_pSteamNetworkingMessages;
	}
}

#endif // !DISABLESTEAMWORKS
