// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
	#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	public static class SteamGameServerNetworkingMessages {
		/// <summary>
		/// <para> Sends a message to the specified host.  If we don't already have a session with that user,</para>
		/// <para> a session is implicitly created.  There might be some handshaking that needs to happen</para>
		/// <para> before we can actually begin sending message data.  If this handshaking fails and we can't</para>
		/// <para> get through, an error will be posted via the callback SteamNetworkingMessagesSessionFailed_t.</para>
		/// <para> There is no notification when the operation succeeds.  (You should have the peer send a reply</para>
		/// <para> for this purpose.)</para>
		/// <para> Sending a message to a host will also implicitly accept any incoming connection from that host.</para>
		/// <para> nSendFlags is a bitmask of k_nSteamNetworkingSend_xxx options</para>
		/// <para> nRemoteChannel is a routing number you can use to help route message to different systems.</para>
		/// <para> You'll have to call ReceiveMessagesOnChannel() with the same channel number in order to retrieve</para>
		/// <para> the data on the other end.</para>
		/// <para> Using different channels to talk to the same user will still use the same underlying</para>
		/// <para> connection, saving on resources.  If you don't need this feature, use 0.</para>
		/// <para> Otherwise, small integers are the most efficient.</para>
		/// <para> It is guaranteed that reliable messages to the same host on the same channel</para>
		/// <para> will be be received by the remote host (if they are received at all) exactly once,</para>
		/// <para> and in the same order that they were sent.</para>
		/// <para> NO other order guarantees exist!  In particular, unreliable messages may be dropped,</para>
		/// <para> received out of order with respect to each other and with respect to reliable data,</para>
		/// <para> or may be received multiple times.  Messages on different channels are *not* guaranteed</para>
		/// <para> to be received in the order they were sent.</para>
		/// <para> A note for those familiar with TCP/IP ports, or converting an existing codebase that</para>
		/// <para> opened multiple sockets:  You might notice that there is only one channel, and with</para>
		/// <para> TCP/IP each endpoint has a port number.  You can think of the channel number as the</para>
		/// <para> *destination* port.  If you need each message to also include a "source port" (so the</para>
		/// <para> recipient can route the reply), then just put that in your message.  That is essentially</para>
		/// <para> how UDP works!</para>
		/// <para> Returns:</para>
		/// <para> - k_EREsultOK on success.</para>
		/// <para> - k_EResultNoConnection, if the session has failed or was closed by the peer and</para>
		/// <para>   k_nSteamNetworkingSend_AutoRestartBrokenSession was not specified.  (You can</para>
		/// <para>   use GetSessionConnectionInfo to get the details.)  In order to acknowledge the</para>
		/// <para>   broken session and start a new one, you must call CloseSessionWithUser, or you may</para>
		/// <para>   repeat the call with k_nSteamNetworkingSend_AutoRestartBrokenSession.  See</para>
		/// <para>   k_nSteamNetworkingSend_AutoRestartBrokenSession for more details.</para>
		/// <para> - See ISteamNetworkingSockets::SendMessageToConnection for more possible return values</para>
		/// <para>向指定的主机发送消息。如果我们还没有与该用户的会话，则会隐式创建会话。在我们真正开始发送消息数据之前，可能需要发生一些握手。如果此握手失败并且无法通过，将通过“回调” steamnetworkingmessagessessessionfailed_t发布错误。操作成功时没有通知。（为此，您应该让同行发送答复。） 向主机发送消息还将隐式接受该主机的任何传入连接。 nsendflags是k_nsteamnetworkingsend_xxx选项的bitmask NRemoteChannel是一个路由号，您可以用来帮助将消息路由到不同系统。您必须调用带有相同频道编号的接收仪，以便在另一端检索数据。 使用不同的渠道与同一用户交谈仍将使用相同的基础连接，从而节省资源。如果您不需要此功能，请使用0。否则，小整数是最有效的。 可以保证，远程主机（如果完全收到的话）将收到同一频道上同一频道上同一主机的可靠消息，并且按照与他们发送的顺序相同的顺序。 没有其他订单保证！特别是，可以删除不可靠的消息，相互收到的订单和可靠的数据，也可以多次接收。*不保证以发送的顺序收到不同渠道上的消息。 对于熟悉TCP/IP端口的人的注释，或转换一个打开多个插座的现有代码库：您可能会注意到只有一个通道，并且TCP/IP每个端点都有一个端口号。您可以将频道编号视为 *目标 *端口。如果您需要每条消息以包括一个“源端口”（以便收件人可以路由回复），则只需将其放在您的消息中即可。从本质上讲，这就是UDP的工作方式！ 返回：-K_ERESULTOK成功。-K_eresultNoconnection，如果尚未指定会话失败或被同行关闭，并且未指定k_nsteamnetworkingsend_autorestartbrokensessess。（您可以使用getSessionConnectionInfo获取详细信息。）为了确认损坏的会话并启动新会话，您必须致电ClosSessionWithuser，或者您可以使用K_NSteamNetworkingsEnd_autorworkingsend_autor_autor_autor_autor_autor_autoreStartBrokenSession重复该呼叫。有关更多详细信息，请参见k_nsteamnetworkingsend_autorestartartrokensession。- 有关更多可能的返回值</para>
		/// </summary>
		public static EResult SendMessageToUser(ref SteamNetworkingIdentity identityRemote, IntPtr pubData, uint cubData, int nSendFlags, int nRemoteChannel) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingMessages_SendMessageToUser(CSteamGameServerAPIContext.GetSteamNetworkingMessages(), ref identityRemote, pubData, cubData, nSendFlags, nRemoteChannel);
		}

		/// <summary>
		/// <para> Reads the next message that has been sent from another user via SendMessageToUser() on the given channel.</para>
		/// <para> Returns number of messages returned into your list.  (0 if no message are available on that channel.)</para>
		/// <para> When you're done with the message object(s), make sure and call SteamNetworkingMessage_t::Release()!</para>
		/// <para>读取通过给定频道上的sendmessagetouser（）从另一个用户发送的下一个消息。返回返回列表的消息数。（0如果该频道上没有消息。） 完成消息对象后，请确保并致电STEAMNETWORKINGMESSAGE_T :: REALE REALES（）！</para>
		/// </summary>
		public static int ReceiveMessagesOnChannel(int nLocalChannel, IntPtr[] ppOutMessages, int nMaxMessages) {
			InteropHelp.TestIfAvailableGameServer();
			if (ppOutMessages != null && ppOutMessages.Length != nMaxMessages) {
				throw new System.ArgumentException("ppOutMessages must be the same size as nMaxMessages!");
			}
			return NativeMethods.ISteamNetworkingMessages_ReceiveMessagesOnChannel(CSteamGameServerAPIContext.GetSteamNetworkingMessages(), nLocalChannel, ppOutMessages, nMaxMessages);
		}

		/// <summary>
		/// <para> Call this in response to a SteamNetworkingMessagesSessionRequest_t callback.</para>
		/// <para> SteamNetworkingMessagesSessionRequest_t are posted when a user tries to send you a message,</para>
		/// <para> and you haven't tried to talk to them first.  If you don't want to talk to them, just ignore</para>
		/// <para> the request.  If the user continues to send you messages, SteamNetworkingMessagesSessionRequest_t</para>
		/// <para> callbacks will continue to be posted periodically.</para>
		/// <para> Returns false if there is no session with the user pending or otherwise.  If there is an</para>
		/// <para> existing active session, this function will return true, even if it is not pending.</para>
		/// <para> Calling SendMessageToUser() will implicitly accepts any pending session request to that user.</para>
		/// <para>为此响应SteamnetworkingMessagessessionRequest_t回调。当用户试图向您发送消息时，STEAMNETWORKING MESSAGESSESSINDREQUEST_T会发布，而您尚未尝试先与他们交谈。如果您不想与他们交谈，请忽略请求。如果用户继续向您发送消息，则SteamnetworkingMessagessessionRequest_t回调将继续定期发布。 如果与用户待处理或其他方式没有会话，则返回false。如果存在现有的活动会话，则此功能即使没有待处理，此功能也将返回。 呼叫sendmessagetouser（）将隐式接受该用户的任何待处理会话请求。</para>
		/// </summary>
		public static bool AcceptSessionWithUser(ref SteamNetworkingIdentity identityRemote) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingMessages_AcceptSessionWithUser(CSteamGameServerAPIContext.GetSteamNetworkingMessages(), ref identityRemote);
		}

		/// <summary>
		/// <para> Call this when you're done talking to a user to immediately free up resources under-the-hood.</para>
		/// <para> If the remote user tries to send data to you again, another SteamNetworkingMessagesSessionRequest_t</para>
		/// <para> callback will be posted.</para>
		/// <para> Note that sessions that go unused for a few minutes are automatically timed out.</para>
		/// <para>当您完成与用户交谈以立即释放资源下的资源后，请致电。如果远程用户试图再次向您发送数据，则将发布另一个SteamnetworkingMessagessingRequest_t回调。 请注意，未使用几分钟的会话会自动计时。</para>
		/// </summary>
		public static bool CloseSessionWithUser(ref SteamNetworkingIdentity identityRemote) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingMessages_CloseSessionWithUser(CSteamGameServerAPIContext.GetSteamNetworkingMessages(), ref identityRemote);
		}

		/// <summary>
		/// <para> Call this  when you're done talking to a user on a specific channel.  Once all</para>
		/// <para> open channels to a user have been closed, the open session to the user will be</para>
		/// <para> closed, and any new data from this user will trigger a</para>
		/// <para> SteamSteamNetworkingMessagesSessionRequest_t callback</para>
		/// <para>当您完成在特定频道上与用户交谈后，请致电。一旦关闭了用户的所有打开渠道，将关闭向用户的打开会话，并且该用户的任何新数据都会触发Steam SteamnetworkingMessagessessessionRequest_t callback callback</para>
		/// </summary>
		public static bool CloseChannelWithUser(ref SteamNetworkingIdentity identityRemote, int nLocalChannel) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingMessages_CloseChannelWithUser(CSteamGameServerAPIContext.GetSteamNetworkingMessages(), ref identityRemote, nLocalChannel);
		}

		/// <summary>
		/// <para> Returns information about the latest state of a connection, if any, with the given peer.</para>
		/// <para> Primarily intended for debugging purposes, but can also be used to get more detailed</para>
		/// <para> failure information.  (See SendMessageToUser and k_nSteamNetworkingSend_AutoRestartBrokenSession.)</para>
		/// <para> Returns the value of SteamNetConnectionInfo_t::m_eState, or k_ESteamNetworkingConnectionState_None</para>
		/// <para> if no connection exists with specified peer.  You may pass nullptr for either parameter if</para>
		/// <para> you do not need the corresponding details.  Note that sessions time out after a while,</para>
		/// <para> so if a connection fails, or SendMessageToUser returns k_EResultNoConnection, you cannot wait</para>
		/// <para> indefinitely to obtain the reason for failure.</para>
		/// <para>返回有关给定同行的连接最新状态（如果有）的最新状态的信息。主要用于调试目的，但也可以用于获取更详细的故障信息。（请参阅sendmessagetouser和k_nsteamnetworkingsend_autorestartbrokensession。） 返回SteamnetConnectionInfo_T :: m_estate的值，或者如果与指定的对等方指定的连接不存在连接，则返回k_esteamnetworkingConnectionState_none。如果您不需要相应的详细信息，则可以将NULLPTR传递给任何一个参数。请注意，会议后一段时间后，因此，如果连接失败或sendmessagetouser返回k_eresultNoconnection，则您不能无限期地等待获得失败的原因。</para>
		/// </summary>
		public static ESteamNetworkingConnectionState GetSessionConnectionInfo(ref SteamNetworkingIdentity identityRemote, out SteamNetConnectionInfo_t pConnectionInfo, out SteamNetConnectionRealTimeStatus_t pQuickStatus) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingMessages_GetSessionConnectionInfo(CSteamGameServerAPIContext.GetSteamNetworkingMessages(), ref identityRemote, out pConnectionInfo, out pQuickStatus);
		}
	}
}

#endif // !DISABLESTEAMWORKS
