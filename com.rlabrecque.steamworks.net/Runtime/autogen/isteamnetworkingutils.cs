// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
	#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	public static class SteamNetworkingUtils {
		/// <summary>
		/// <para> Efficient message sending</para>
		/// <para> Allocate and initialize a message object.  Usually the reason</para>
		/// <para> you call this is to pass it to ISteamNetworkingSockets::SendMessages.</para>
		/// <para> The returned object will have all of the relevant fields cleared to zero.</para>
		/// <para> Optionally you can also request that this system allocate space to</para>
		/// <para> hold the payload itself.  If cbAllocateBuffer is nonzero, the system</para>
		/// <para> will allocate memory to hold a payload of at least cbAllocateBuffer bytes.</para>
		/// <para> m_pData will point to the allocated buffer, m_cbSize will be set to the</para>
		/// <para> size, and m_pfnFreeData will be set to the proper function to free up</para>
		/// <para> the buffer.</para>
		/// <para> If cbAllocateBuffer=0, then no buffer is allocated.  m_pData will be NULL,</para>
		/// <para> m_cbSize will be zero, and m_pfnFreeData will be NULL.  You will need to</para>
		/// <para> set each of these.</para>
		/// <para>高效消息发送</para>
		/// <para>分配并初始化一个消息对象。通常你调用这个方法是将其传递给 ISteamNetworkingSockets::SendMessages。返回的对象将所有相关字段清零。</para>
		/// <para>可选地，您还可以要求该系统为自身的数据包分配空间。如果 cbAllocateBuffer 不为零，系统将分配至少 cbAllocateBuffer 字节的内存来存储数据包。m_pData 将指向分配的缓冲区，m_cbSize 将设置为大小，m_pfnFreeData 将设置为用于释放缓冲区的正确函数。</para>
		/// <para>如果 cbAllocateBuffer=0，则不分配缓冲区。m_pData 将为 NULL，m_cbSize 将为零，m_pfnFreeData 将为 NULL。你需要分别设置这三个。</para>
		/// </summary>
		public static IntPtr AllocateMessage(int cbAllocateBuffer) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingUtils_AllocateMessage(CSteamAPIContext.GetSteamNetworkingUtils(), cbAllocateBuffer);
		}

		/// <summary>
		/// <para> Access to Steam Datagram Relay (SDR) network</para>
		/// <para> Initialization and status check</para>
		/// <para> If you know that you are going to be using the relay network (for example,</para>
		/// <para> because you anticipate making P2P connections), call this to initialize the</para>
		/// <para> relay network.  If you do not call this, the initialization will</para>
		/// <para> be delayed until the first time you use a feature that requires access</para>
		/// <para> to the relay network, which will delay that first access.</para>
		/// <para> You can also call this to force a retry if the previous attempt has failed.</para>
		/// <para> Performing any action that requires access to the relay network will also</para>
		/// <para> trigger a retry, and so calling this function is never strictly necessary,</para>
		/// <para> but it can be useful to call it a program launch time, if access to the</para>
		/// <para> relay network is anticipated.</para>
		/// <para> Use GetRelayNetworkStatus or listen for SteamRelayNetworkStatus_t</para>
		/// <para> callbacks to know when initialization has completed.</para>
		/// <para> Typically initialization completes in a few seconds.</para>
		/// <para> Note: dedicated servers hosted in known data centers do *not* need</para>
		/// <para> to call this, since they do not make routing decisions.  However, if</para>
		/// <para> the dedicated server will be using P2P functionality, it will act as</para>
		/// <para> a "client" and this should be called.</para>
		/// <para>访问 Steam Datagram Relay (SDR) 网络</para>
		/// <para>初始化和状态检查</para>
		/// <para>如果您知道您将使用中继网络（例如，因为您预计将进行P2P连接），请调用此方法来初始化中继网络。 如果您没有调用此方法，初始化将延迟到您首次使用需要访问中继网络的特性时，届时会延迟首次访问。</para>
		/// <para>你也可以通过调用此函数来强制重试，如果之前的尝试失败了。 任何需要访问中继网络的动作也会触发重试，因此调用此函数在严格意义上并不必要，但如果在预期访问中继网络时，在程序启动时调用它可能会有用。</para>
		/// <para>使用GetRelayNetworkStatus或监听SteamRelayNetworkStatus_t回调，以了解初始化是否完成。通常初始化会在几秒钟内完成。</para>
		/// <para>注意：在已知数据中心托管的专用服务器*不*需要调用此项，因为它们不会进行路由决策。但是，如果专用服务器将使用 P2P 功能，它将作为“客户端”而调用此项。</para>
		/// </summary>
		public static void InitRelayNetworkAccess() {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamNetworkingUtils_InitRelayNetworkAccess(CSteamAPIContext.GetSteamNetworkingUtils());
		}

		/// <summary>
		/// <para> Fetch current status of the relay network.</para>
		/// <para> SteamRelayNetworkStatus_t is also a callback.  It will be triggered on</para>
		/// <para> both the user and gameserver interfaces any time the status changes, or</para>
		/// <para> ping measurement starts or stops.</para>
		/// <para> SteamRelayNetworkStatus_t::m_eAvail is returned.  If you want</para>
		/// <para> more details, you can pass a non-NULL value.</para>
		/// <para>获取当前中继网络状态。</para>
		/// <para>SteamRelayNetworkStatus_t 也是一个回调。它会在用户和游戏服务器接口上任何状态改变、ping测量开始或停止时触发。</para>
		/// <para>SteamRelayNetworkStatus_t::m_eAvail 返回可用状态。如果需要更多细节，可以传递一个非NULL值。</para>
		/// </summary>
		public static ESteamNetworkingAvailability GetRelayNetworkStatus(out SteamRelayNetworkStatus_t pDetails) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingUtils_GetRelayNetworkStatus(CSteamAPIContext.GetSteamNetworkingUtils(), out pDetails);
		}

		/// <summary>
		/// <para> "Ping location" functions</para>
		/// <para> We use the ping times to the valve relays deployed worldwide to</para>
		/// <para> generate a "marker" that describes the location of an Internet host.</para>
		/// <para> Given two such markers, we can estimate the network latency between</para>
		/// <para> two hosts, without sending any packets.  The estimate is based on the</para>
		/// <para> optimal route that is found through the Valve network.  If you are</para>
		/// <para> using the Valve network to carry the traffic, then this is precisely</para>
		/// <para> the ping you want.  If you are not, then the ping time will probably</para>
		/// <para> still be a reasonable estimate.</para>
		/// <para> This is extremely useful to select peers for matchmaking!</para>
		/// <para> The markers can also be converted to a string, so they can be transmitted.</para>
		/// <para> We have a separate library you can use on your app's matchmaking/coordinating</para>
		/// <para> server to manipulate these objects.  (See steamdatagram_gamecoordinator.h)</para>
		/// <para> Return location info for the current host.  Returns the approximate</para>
		/// <para> age of the data, in seconds, or -1 if no data is available.</para>
		/// <para> It takes a few seconds to initialize access to the relay network.  If</para>
		/// <para> you call this very soon after calling InitRelayNetworkAccess,</para>
		/// <para> the data may not be available yet.</para>
		/// <para> This always return the most up-to-date information we have available</para>
		/// <para> right now, even if we are in the middle of re-calculating ping times.</para>
		/// <para>“Ping 位置”功能</para>
		/// <para>我们使用到全球部署的Valve继电器的时间戳（ping times）来生成一个“标记”，描述一个互联网主机的地理位置。 鉴于两个这样的标记，我们可以估计两个主机之间的网络延迟，而无需发送任何数据包。 估计基于通过Valve网络中找到的最优路由。 如果您正在使用Valve网络传输流量，那么这就是您想要的时间戳。 如果您没有，则时间戳仍然可能是一个合理的估计。</para>
		/// <para>这对于选择匹配对手非常有用！</para>
		/// <para>这些标记也可以转换为字符串，以便进行传输。我们有一个单独的库，您可以在应用程序的匹配/协调服务器上使用，用于操纵这些对象。（参见 steamdatagram_gamecoordinator.h）返回当前主机的定位信息。返回数据的近似年龄，以秒为单位，如果未提供数据则返回 -1。</para>
		/// <para>初始化对中继网络的访问需要几秒钟。如果在调用 InitRelayNetworkAccess 之后立即调用此方法，数据可能尚未可用。</para>
		/// <para>这始终返回我们目前可用的最新信息，即使我们在重新计算延迟时间时。</para>
		/// </summary>
		public static float GetLocalPingLocation(out SteamNetworkPingLocation_t result) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingUtils_GetLocalPingLocation(CSteamAPIContext.GetSteamNetworkingUtils(), out result);
		}

		/// <summary>
		/// <para> Estimate the round-trip latency between two arbitrary locations, in</para>
		/// <para> milliseconds.  This is a conservative estimate, based on routing through</para>
		/// <para> the relay network.  For most basic relayed connections, this ping time</para>
		/// <para> will be pretty accurate, since it will be based on the route likely to</para>
		/// <para> be actually used.</para>
		/// <para> If a direct IP route is used (perhaps via NAT traversal), then the route</para>
		/// <para> will be different, and the ping time might be better.  Or it might actually</para>
		/// <para> be a bit worse!  Standard IP routing is frequently suboptimal!</para>
		/// <para> But even in this case, the estimate obtained using this method is a</para>
		/// <para> reasonable upper bound on the ping time.  (Also it has the advantage</para>
		/// <para> of returning immediately and not sending any packets.)</para>
		/// <para> In a few cases we might not able to estimate the route.  In this case</para>
		/// <para> a negative value is returned.  k_nSteamNetworkingPing_Failed means</para>
		/// <para> the reason was because of some networking difficulty.  (Failure to</para>
		/// <para> ping, etc)  k_nSteamNetworkingPing_Unknown is returned if we cannot</para>
		/// <para> currently answer the question for some other reason.</para>
		/// <para> Do you need to be able to do this from a backend/matchmaking server?</para>
		/// <para> You are looking for the "game coordinator" library.</para>
		/// <para>估算两个任意位置之间的往返延迟，单位为毫秒。这是一个保守的估计，基于通过中继网络路由。对于大多数基本的中继连接，这个延迟时间会相当准确，因为它将基于实际可能使用的路由。</para>
		/// <para>如果使用直接 IP 路由（例如通过 NAT 穿透），则路由会不同，延迟可能更好。或者，它可能实际上会稍微变差！标准 IP 路由经常是不理想的！</para>
		/// <para>即使在这种情况下，使用这种方法获得的估计值仍然是延迟时间的合理上限。 (此外，它具有立即返回且不发送任何数据包的优势。)</para>
		/// <para>在某些情况下，我们可能无法估算路线。在这种情况下，返回一个负值。k_nSteamNetworkingPing_Failed表示原因是由于一些网络问题（如未成功ping等）。k_nSteamNetworkingPing_Unknown表示我们目前无法以其他原因回答这个问题。</para>
		/// <para>您需要从后端/匹配服务器执行此操作吗？您正在寻找“游戏协调器”库。</para>
		/// </summary>
		public static int EstimatePingTimeBetweenTwoLocations(ref SteamNetworkPingLocation_t location1, ref SteamNetworkPingLocation_t location2) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingUtils_EstimatePingTimeBetweenTwoLocations(CSteamAPIContext.GetSteamNetworkingUtils(), ref location1, ref location2);
		}

		/// <summary>
		/// <para> Same as EstimatePingTime, but assumes that one location is the local host.</para>
		/// <para> This is a bit faster, especially if you need to calculate a bunch of</para>
		/// <para> these in a loop to find the fastest one.</para>
		/// <para> In rare cases this might return a slightly different estimate than combining</para>
		/// <para> GetLocalPingLocation with EstimatePingTimeBetweenTwoLocations.  That's because</para>
		/// <para> this function uses a slightly more complete set of information about what</para>
		/// <para> route would be taken.</para>
		/// <para>与EstimatePingTime相同，但假设一个位置是本地主机。这会更快，尤其是在需要循环计算大量这些值以找到最快的那个时。</para>
		/// <para>在罕见情况下，这可能会返回与结合使用 GetLocalPingLocation 和 EstimatePingTimeBetweenTwoLocations 的方法略有不同的估算值。这是因为此函数使用关于将采取哪条路线的稍微更完整的信息。</para>
		/// </summary>
		public static int EstimatePingTimeFromLocalHost(ref SteamNetworkPingLocation_t remoteLocation) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingUtils_EstimatePingTimeFromLocalHost(CSteamAPIContext.GetSteamNetworkingUtils(), ref remoteLocation);
		}

		/// <summary>
		/// <para> Convert a ping location into a text format suitable for sending over the wire.</para>
		/// <para> The format is a compact and human readable.  However, it is subject to change</para>
		/// <para> so please do not parse it yourself.  Your buffer must be at least</para>
		/// <para> k_cchMaxSteamNetworkingPingLocationString bytes.</para>
		/// <para>将 Ping 位置转换为适合通过网络发送的文本格式。格式应简洁且易于阅读。但是，格式可能随时更改，请勿自行解析它。你的缓冲区必须至少为 k_cchMaxSteamNetworkingPingLocationString 字节。</para>
		/// </summary>
		public static void ConvertPingLocationToString(ref SteamNetworkPingLocation_t location, out string pszBuf, int cchBufSize) {
			InteropHelp.TestIfAvailableClient();
			IntPtr pszBuf2 = Marshal.AllocHGlobal(cchBufSize);
			NativeMethods.ISteamNetworkingUtils_ConvertPingLocationToString(CSteamAPIContext.GetSteamNetworkingUtils(), ref location, pszBuf2, cchBufSize);
			pszBuf = InteropHelp.PtrToStringUTF8(pszBuf2);
			Marshal.FreeHGlobal(pszBuf2);
		}

		/// <summary>
		/// <para> Parse back SteamNetworkPingLocation_t string.  Returns false if we couldn't understand</para>
		/// <para> the string.</para>
		/// <para>解析回声的 SteamNetworkPingLocation_t 字符串。如果无法理解字符串，则返回 false。</para>
		/// </summary>
		public static bool ParsePingLocationString(string pszString, out SteamNetworkPingLocation_t result) {
			InteropHelp.TestIfAvailableClient();
			using (var pszString2 = new InteropHelp.UTF8StringHandle(pszString)) {
				return NativeMethods.ISteamNetworkingUtils_ParsePingLocationString(CSteamAPIContext.GetSteamNetworkingUtils(), pszString2, out result);
			}
		}

		/// <summary>
		/// <para> Check if the ping data of sufficient recency is available, and if</para>
		/// <para> it's too old, start refreshing it.</para>
		/// <para> Please only call this function when you *really* do need to force an</para>
		/// <para> immediate refresh of the data.  (For example, in response to a specific</para>
		/// <para> user input to refresh this information.)  Don't call it "just in case",</para>
		/// <para> before every connection, etc.  That will cause extra traffic to be sent</para>
		/// <para> for no benefit. The library will automatically refresh the information</para>
		/// <para> as needed.</para>
		/// <para> Returns true if sufficiently recent data is already available.</para>
		/// <para> Returns false if sufficiently recent data is not available.  In this</para>
		/// <para> case, ping measurement is initiated, if it is not already active.</para>
		/// <para> (You cannot restart a measurement already in progress.)</para>
		/// <para> You can use GetRelayNetworkStatus or listen for SteamRelayNetworkStatus_t</para>
		/// <para> to know when ping measurement completes.</para>
		/// <para>检查是否有足够新鲜度的ping数据可用，如果数据太旧，则开始刷新它。</para>
		/// <para>请仅在您*确实*需要强制刷新数据时才调用此函数。 (例如，作为特定用户输入响应来更新此信息。) 不要“以防万一”在每次连接之前调用它等。 这会导致发送额外的流量，没有任何好处。 库会自动在需要时刷新信息。</para>
		/// <para>如果已经有足够新的数据，则返回true。</para>
		/// <para>如果无法获取足够近期的数据，则返回false。在这种情况下，会启动ping测量，如果它尚未激活。 (您无法重启正在进行的测量。)</para>
		/// <para>你可以使用 GetRelayNetworkStatus 或监听 SteamRelayNetworkStatus_t 以了解何时完成 ping 测量。</para>
		/// </summary>
		public static bool CheckPingDataUpToDate(float flMaxAgeSeconds) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingUtils_CheckPingDataUpToDate(CSteamAPIContext.GetSteamNetworkingUtils(), flMaxAgeSeconds);
		}

		/// <summary>
		/// <para> List of Valve data centers, and ping times to them.  This might</para>
		/// <para> be useful to you if you are use our hosting, or just need to measure</para>
		/// <para> latency to a cloud data center where we are running relays.</para>
		/// <para> Fetch ping time of best available relayed route from this host to</para>
		/// <para> the specified data center.</para>
		/// <para>Valve数据中心列表，以及到它们的延迟时间。 这可能对您有帮助，如果您使用我们的托管服务，或者只是需要测量到云数据中心（我们运行中继服务器的地方）的延迟。</para>
		/// <para>从本主机到指定数据中心的最佳可用中继路由的延迟获取。</para>
		/// </summary>
		public static int GetPingToDataCenter(SteamNetworkingPOPID popID, out SteamNetworkingPOPID pViaRelayPoP) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingUtils_GetPingToDataCenter(CSteamAPIContext.GetSteamNetworkingUtils(), popID, out pViaRelayPoP);
		}

		/// <summary>
		/// <para> Get *direct* ping time to the relays at the data center.</para>
		/// <para>获取到数据中心复用站点的直接回延迟时间。</para>
		/// </summary>
		public static int GetDirectPingToPOP(SteamNetworkingPOPID popID) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingUtils_GetDirectPingToPOP(CSteamAPIContext.GetSteamNetworkingUtils(), popID);
		}

		/// <summary>
		/// <para> Get number of network points of presence in the config</para>
		/// <para>获取配置中的网络点呢喃数量。</para>
		/// </summary>
		public static int GetPOPCount() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingUtils_GetPOPCount(CSteamAPIContext.GetSteamNetworkingUtils());
		}

		/// <summary>
		/// <para> Get list of all POP IDs.  Returns the number of entries that were filled into</para>
		/// <para> your list.</para>
		/// <para>获取所有 POP ID 列表。返回列表填充的条目数量。</para>
		/// </summary>
		public static int GetPOPList(out SteamNetworkingPOPID list, int nListSz) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingUtils_GetPOPList(CSteamAPIContext.GetSteamNetworkingUtils(), out list, nListSz);
		}

		/// <summary>
		/// <para> Misc</para>
		/// <para> Fetch current timestamp.  This timer has the following properties:</para>
		/// <para> - Monotonicity is guaranteed.</para>
		/// <para> - The initial value will be at least 24*3600*30*1e6, i.e. about</para>
		/// <para>   30 days worth of microseconds.  In this way, the timestamp value of</para>
		/// <para>   0 will always be at least "30 days ago".  Also, negative numbers</para>
		/// <para>   will never be returned.</para>
		/// <para> - Wraparound / overflow is not a practical concern.</para>
		/// <para> If you are running under the debugger and stop the process, the clock</para>
		/// <para> might not advance the full wall clock time that has elapsed between</para>
		/// <para> calls.  If the process is not blocked from normal operation, the</para>
		/// <para> timestamp values will track wall clock time, even if you don't call</para>
		/// <para> the function frequently.</para>
		/// <para> The value is only meaningful for this run of the process.  Don't compare</para>
		/// <para> it to values obtained on another computer, or other runs of the same process.</para>
		/// <para>杂项</para>
		/// <para>获取当前时间戳。这个定时器具有以下属性：</para>
		/// <para>单调性已保证。初始值至少为 24*3600*30*1e6，即大约 30 天份的微秒。 这样，0 的时间戳值始终至少为“30 天前”。 负数不会被返回。 环绕/溢出不是一个实际的顾虑。</para>
		/// <para>如果在调试器下运行并停止进程，时钟可能不会推进实际经过的真实时间。如果进程没有被阻止正常运行，时间戳值会跟踪真实时间，即使你没有频繁调用该函数。</para>
		/// <para>这个值仅在本次流程运行中才有意义。不要将其与在另一台计算机或同一流程的其他运行中获得的数值进行比较。</para>
		/// </summary>
		public static SteamNetworkingMicroseconds GetLocalTimestamp() {
			InteropHelp.TestIfAvailableClient();
			return (SteamNetworkingMicroseconds)NativeMethods.ISteamNetworkingUtils_GetLocalTimestamp(CSteamAPIContext.GetSteamNetworkingUtils());
		}

		/// <summary>
		/// <para> Set a function to receive network-related information that is useful for debugging.</para>
		/// <para> This can be very useful during development, but it can also be useful for troubleshooting</para>
		/// <para> problems with tech savvy end users.  If you have a console or other log that customers</para>
		/// <para> can examine, these log messages can often be helpful to troubleshoot network issues.</para>
		/// <para> (Especially any warning/error messages.)</para>
		/// <para> The detail level indicates what message to invoke your callback on.  Lower numeric</para>
		/// <para> value means more important, and the value you pass is the lowest priority (highest</para>
		/// <para> numeric value) you wish to receive callbacks for.</para>
		/// <para> The value here controls the detail level for most messages.  You can control the</para>
		/// <para> detail level for various subsystems (perhaps only for certain connections) by</para>
		/// <para> adjusting the configuration values k_ESteamNetworkingConfig_LogLevel_Xxxxx.</para>
		/// <para> Except when debugging, you should only use k_ESteamNetworkingSocketsDebugOutputType_Msg</para>
		/// <para> or k_ESteamNetworkingSocketsDebugOutputType_Warning.  For best performance, do NOT</para>
		/// <para> request a high detail level and then filter out messages in your callback.  This incurs</para>
		/// <para> all of the expense of formatting the messages, which are then discarded.  Setting a high</para>
		/// <para> priority value (low numeric value) here allows the library to avoid doing this work.</para>
		/// <para> IMPORTANT: This may be called from a service thread, while we own a mutex, etc.</para>
		/// <para> Your output function must be threadsafe and fast!  Do not make any other</para>
		/// <para> Steamworks calls from within the handler.</para>
		/// <para>设置一个函数来接收与网络相关的调试信息。这在开发过程中非常有用，也可以帮助解决技术高手的用户遇到的问题。如果您有客户可以查看的控制台或日志，这些日志消息通常可以帮助您解决网络问题。（尤其是任何警告/错误消息。）</para>
		/// <para>细节级别指示您在什么消息上调用回调函数。较低的数值意味着更重要，您传递的值是您希望接收回调函数的最低优先级（最高数值）。</para>
		/// <para>此处的值控制大多数消息的详细程度。您可以通过调整配置值 k_ESteamNetworkingConfig_LogLevel_Xxxxx 来控制各种子系统（可能仅针对某些连接）的详细程度。</para>
		/// <para>除非在调试时，否则你应该只使用 k_ESteamNetworkingSocketsDebugOutputType_Msg 或 k_ESteamNetworkingSocketsDebugOutputType_Warning。为了获得最佳性能，不要请求高详细程度，然后在回调中过滤消息。这会产生格式化消息的所有费用，而这些消息随后会被丢弃。设置高优先级值（低数值）在这里允许该库避免执行此操作。</para>
		/// <para>重要提示：此函数可能在服务线程中调用，同时我们拥有互斥锁等资源。您的输出函数必须是线程安全的且快速！请勿在处理程序中进行任何其他 Steamworks 调用。</para>
		/// </summary>
		public static void SetDebugOutputFunction(ESteamNetworkingSocketsDebugOutputType eDetailLevel, FSteamNetworkingSocketsDebugOutput pfnFunc) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamNetworkingUtils_SetDebugOutputFunction(CSteamAPIContext.GetSteamNetworkingUtils(), eDetailLevel, pfnFunc);
		}

		/// <summary>
		/// <para> Fake IP</para>
		/// <para> Useful for interfacing with code that assumes peers are identified using an IPv4 address</para>
		/// <para> Return true if an IPv4 address is one that might be used as a "fake" one.</para>
		/// <para> This function is fast; it just does some logical tests on the IP and does</para>
		/// <para> not need to do any lookup operations.</para>
		/// <para>假IP</para>
		/// <para>适用于与使用 IPv4 地址识别同伴的代码进行交互。</para>
		/// <para>如果一个 IPv4 地址可能被用作“假”地址，则返回 true。此函数速度快，它只进行一些逻辑测试，不需要进行任何查找操作。</para>
		/// </summary>
		public static bool IsFakeIPv4(uint nIPv4) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingUtils_IsFakeIPv4(CSteamAPIContext.GetSteamNetworkingUtils(), nIPv4);
		}

		public static ESteamNetworkingFakeIPType GetIPv4FakeIPType(uint nIPv4) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingUtils_GetIPv4FakeIPType(CSteamAPIContext.GetSteamNetworkingUtils(), nIPv4);
		}

		/// <summary>
		/// <para> Get the real identity associated with a given FakeIP.</para>
		/// <para> On failure, returns:</para>
		/// <para> - k_EResultInvalidParam: the IP is not a FakeIP.</para>
		/// <para> - k_EResultNoMatch: we don't recognize that FakeIP and don't know the corresponding identity.</para>
		/// <para> FakeIP's used by active connections, or the FakeIPs assigned to local identities,</para>
		/// <para> will always work.  FakeIPs for recently destroyed connections will continue to</para>
		/// <para> return results for a little while, but not forever.  At some point, we will forget</para>
		/// <para> FakeIPs to save space.  It's reasonably safe to assume that you can read back the</para>
		/// <para> real identity of a connection very soon after it is destroyed.  But do not wait</para>
		/// <para> indefinitely.</para>
		/// <para>获取与给定 FakeIP 相关的真实身份。</para>
		/// <para>在失败时，返回：- k_EResultInvalidParam：IP 不是 FakeIP。- k_EResultNoMatch：我们不认识这个 FakeIP，也不知道其对应的身份。</para>
		/// <para>活跃连接使用的假IP，或分配给本地身份的假IP，始终有效。最近销毁的连接分配的假IP会继续返回结果一段时间，但不会永久存在。在某个时候，我们将忘记假IP以节省空间。可以合理地假设，在连接销毁后不久，您可以读取连接的真实身份。但是不要无限期地等待。</para>
		/// </summary>
		public static EResult GetRealIdentityForFakeIP(ref SteamNetworkingIPAddr fakeIP, out SteamNetworkingIdentity pOutRealIdentity) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingUtils_GetRealIdentityForFakeIP(CSteamAPIContext.GetSteamNetworkingUtils(), ref fakeIP, out pOutRealIdentity);
		}

		/// <summary>
		/// <para> Set and get configuration values, see ESteamNetworkingConfigValue for individual descriptions.</para>
		/// <para> Shortcuts for common cases.  (Implemented as inline functions below)</para>
		/// <para> Set global callbacks.  If you do not want to use Steam's callback dispatch mechanism and you</para>
		/// <para> want to use the same callback on all (or most) listen sockets and connections, then</para>
		/// <para> simply install these callbacks first thing, and you are good to go.</para>
		/// <para> See ISteamNetworkingSockets::RunCallbacks</para>
		/// <para> Set a configuration value.</para>
		/// <para> - eValue: which value is being set</para>
		/// <para> - eScope: Onto what type of object are you applying the setting?</para>
		/// <para> - scopeArg: Which object you want to change?  (Ignored for global scope).  E.g. connection handle, listen socket handle, interface pointer, etc.</para>
		/// <para> - eDataType: What type of data is in the buffer at pValue?  This must match the type of the variable exactly!</para>
		/// <para> - pArg: Value to set it to.  You can pass NULL to remove a non-global setting at this scope,</para>
		/// <para>   causing the value for that object to use global defaults.  Or at global scope, passing NULL</para>
		/// <para>   will reset any custom value and restore it to the system default.</para>
		/// <para>   NOTE: When setting pointers (e.g. callback functions), do not pass the function pointer directly.</para>
		/// <para>   Your argument should be a pointer to a function pointer.</para>
		/// <para>设置和获取配置值，请参阅 ESteamNetworkingConfigValue 以获取详细描述。</para>
		/// <para>常见情况快捷方式。(已实现为下面定义的内联函数)</para>
		/// <para>设置全局回调。如果您不想使用 Steam 的回调分发机制，并且希望在所有（或大多数）监听套接字和连接上使用相同的回调，只需首先安装这些回调，即可。请参阅 ISteamNetworkingSockets::RunCallbacks</para>
		/// <para>设置配置值。- eValue：正在设置的值 - eScope：您要将设置应用于哪种类型的对象？ - scopeArg：您想要更改哪个对象？（全局范围下忽略） 例如：连接句柄、监听套接字句柄、接口指针等。 - eDataType：缓冲区中的数据类型是什么？必须与变量的类型完全匹配！ - pArg：要设置为的值。您可以传递 NULL 以取消在当前范围内的非全局设置，从而使该对象的取值使用全局默认值。或者在全局范围下，传递 NULL 将重置任何自定义值并将其恢复为系统默认值。注意：当设置指针（例如回调函数）时，不要直接传递函数指针。您的参数应为指向函数指针的指针。</para>
		/// </summary>
		public static bool SetConfigValue(ESteamNetworkingConfigValue eValue, ESteamNetworkingConfigScope eScopeType, IntPtr scopeObj, ESteamNetworkingConfigDataType eDataType, IntPtr pArg) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingUtils_SetConfigValue(CSteamAPIContext.GetSteamNetworkingUtils(), eValue, eScopeType, scopeObj, eDataType, pArg);
		}

		/// <summary>
		/// <para> Set a configuration value, using a struct to pass the value.</para>
		/// <para> (This is just a convenience shortcut; see below for the implementation and</para>
		/// <para> a little insight into how SteamNetworkingConfigValue_t is used when</para>
		/// <para> setting config options during listen socket and connection creation.)</para>
		/// <para> Get a configuration value.</para>
		/// <para> - eValue: which value to fetch</para>
		/// <para> - eScopeType: query setting on what type of object</para>
		/// <para> - eScopeArg: the object to query the setting for</para>
		/// <para> - pOutDataType: If non-NULL, the data type of the value is returned.</para>
		/// <para> - pResult: Where to put the result.  Pass NULL to query the required buffer size.  (k_ESteamNetworkingGetConfigValue_BufferTooSmall will be returned.)</para>
		/// <para> - cbResult: IN: the size of your buffer.  OUT: the number of bytes filled in or required.</para>
		/// <para>设置一个配置值，使用结构体传递值。（这只是一个便捷的快捷方式；下面介绍实现以及如何使用 SteamNetworkingConfigValue_t 在监听套接字和连接创建期间设置配置选项。） 获取一个配置值。 - eValue：要获取的值 - eScopeType：查询设置的类型对象 - eScopeArg：要查询设置的对象 - pOutDataType：如果非 NULL，则返回值的类型。 - pResult：用于存放结果的位置。 传递 NULL 以查询所需的缓冲区大小。（将返回 k_ESteamNetworkingGetConfigValue_BufferTooSmall。） - cbResult：IN：你的缓冲区大小。 OUT：填充或需要的字节数。</para>
		/// </summary>
		public static ESteamNetworkingGetConfigValueResult GetConfigValue(ESteamNetworkingConfigValue eValue, ESteamNetworkingConfigScope eScopeType, IntPtr scopeObj, out ESteamNetworkingConfigDataType pOutDataType, IntPtr pResult, ref ulong cbResult) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingUtils_GetConfigValue(CSteamAPIContext.GetSteamNetworkingUtils(), eValue, eScopeType, scopeObj, out pOutDataType, pResult, ref cbResult);
		}

		/// <summary>
		/// <para> Get info about a configuration value.  Returns the name of the value,</para>
		/// <para> or NULL if the value doesn't exist.  Other output parameters can be NULL</para>
		/// <para> if you do not need them.</para>
		/// <para>获取配置值的详细信息。返回值的名称，如果值不存在则返回NULL。其他输出参数可以设置为NULL，如果您不需要它们。</para>
		/// </summary>
		public static string GetConfigValueInfo(ESteamNetworkingConfigValue eValue, out ESteamNetworkingConfigDataType pOutDataType, out ESteamNetworkingConfigScope pOutScope) {
			InteropHelp.TestIfAvailableClient();
			return InteropHelp.PtrToStringUTF8(NativeMethods.ISteamNetworkingUtils_GetConfigValueInfo(CSteamAPIContext.GetSteamNetworkingUtils(), eValue, out pOutDataType, out pOutScope));
		}

		/// <summary>
		/// <para> Iterate the list of all configuration values in the current environment that it might</para>
		/// <para> be possible to display or edit using a generic UI.  To get the first iterable value,</para>
		/// <para> pass k_ESteamNetworkingConfig_Invalid.  Returns k_ESteamNetworkingConfig_Invalid</para>
		/// <para> to signal end of list.</para>
		/// <para> The bEnumerateDevVars argument can be used to include "dev" vars.  These are vars that</para>
		/// <para> are recommended to only be editable in "debug" or "dev" mode and typically should not be</para>
		/// <para> shown in a retail environment where a malicious local user might use this to cheat.</para>
		/// <para>迭代当前环境的所有可配置值，以确定是否可以使用通用 UI 显示或编辑。要获取第一个可迭代的值，请传递 k_ESteamNetworkingConfig_Invalid。返回 k_ESteamNetworkingConfig_Invalid 以指示列表结束。</para>
		/// <para>`bEnumerateDevVars` 参数可以用来包含“dev”变量。这些变量建议仅在“debug”或“dev”模式下进行编辑，通常不应在零售环境中显示，因为恶意本地用户可能会利用这些变量作弊。</para>
		/// </summary>
		public static ESteamNetworkingConfigValue IterateGenericEditableConfigValues(ESteamNetworkingConfigValue eCurrent, bool bEnumerateDevVars) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingUtils_IterateGenericEditableConfigValues(CSteamAPIContext.GetSteamNetworkingUtils(), eCurrent, bEnumerateDevVars);
		}

		/// <summary>
		/// <para> String conversions.  You'll usually access these using the respective</para>
		/// <para> inline methods.</para>
		/// <para>字符串转换。你通常会使用相应的内联方法来访问它们。</para>
		/// </summary>
		public static void SteamNetworkingIPAddr_ToString(ref SteamNetworkingIPAddr addr, out string buf, uint cbBuf, bool bWithPort) {
			InteropHelp.TestIfAvailableClient();
			IntPtr buf2 = Marshal.AllocHGlobal((int)cbBuf);
			NativeMethods.ISteamNetworkingUtils_SteamNetworkingIPAddr_ToString(CSteamAPIContext.GetSteamNetworkingUtils(), ref addr, buf2, cbBuf, bWithPort);
			buf = InteropHelp.PtrToStringUTF8(buf2);
			Marshal.FreeHGlobal(buf2);
		}

		public static bool SteamNetworkingIPAddr_ParseString(out SteamNetworkingIPAddr pAddr, string pszStr) {
			InteropHelp.TestIfAvailableClient();
			using (var pszStr2 = new InteropHelp.UTF8StringHandle(pszStr)) {
				return NativeMethods.ISteamNetworkingUtils_SteamNetworkingIPAddr_ParseString(CSteamAPIContext.GetSteamNetworkingUtils(), out pAddr, pszStr2);
			}
		}

		public static ESteamNetworkingFakeIPType SteamNetworkingIPAddr_GetFakeIPType(ref SteamNetworkingIPAddr addr) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingUtils_SteamNetworkingIPAddr_GetFakeIPType(CSteamAPIContext.GetSteamNetworkingUtils(), ref addr);
		}

		public static void SteamNetworkingIdentity_ToString(ref SteamNetworkingIdentity identity, out string buf, uint cbBuf) {
			InteropHelp.TestIfAvailableClient();
			IntPtr buf2 = Marshal.AllocHGlobal((int)cbBuf);
			NativeMethods.ISteamNetworkingUtils_SteamNetworkingIdentity_ToString(CSteamAPIContext.GetSteamNetworkingUtils(), ref identity, buf2, cbBuf);
			buf = InteropHelp.PtrToStringUTF8(buf2);
			Marshal.FreeHGlobal(buf2);
		}

		public static bool SteamNetworkingIdentity_ParseString(out SteamNetworkingIdentity pIdentity, string pszStr) {
			InteropHelp.TestIfAvailableClient();
			using (var pszStr2 = new InteropHelp.UTF8StringHandle(pszStr)) {
				return NativeMethods.ISteamNetworkingUtils_SteamNetworkingIdentity_ParseString(CSteamAPIContext.GetSteamNetworkingUtils(), out pIdentity, pszStr2);
			}
		}
	}
}

#endif // !DISABLESTEAMWORKS
