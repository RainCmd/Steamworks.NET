// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
	#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	public static class SteamGameServer {
		/// <summary>
		/// <para> Game product identifier.  This is currently used by the master server for version checking purposes.</para>
		/// <para> It's a required field, but will eventually will go away, and the AppID will be used for this purpose.</para>
		/// <para>游戏产品标识符。目前，主服务器用于版本检查目的。这是一个必需的字段，但最终将消失，appid将用于此目的。</para>
		/// </summary>
		public static void SetProduct(string pszProduct) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pszProduct2 = new InteropHelp.UTF8StringHandle(pszProduct)) {
				NativeMethods.ISteamGameServer_SetProduct(CSteamGameServerAPIContext.GetSteamGameServer(), pszProduct2);
			}
		}

		/// <summary>
		/// <para> Description of the game.  This is a required field and is displayed in the steam server browser....for now.</para>
		/// <para> This is a required field, but it will go away eventually, as the data should be determined from the AppID.</para>
		/// <para>游戏的描述。这是必需的字段，并显示在Steam Server浏览器中。这是一个必需的字段，但最终将消失，因为数据应从appid中确定。</para>
		/// </summary>
		public static void SetGameDescription(string pszGameDescription) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pszGameDescription2 = new InteropHelp.UTF8StringHandle(pszGameDescription)) {
				NativeMethods.ISteamGameServer_SetGameDescription(CSteamGameServerAPIContext.GetSteamGameServer(), pszGameDescription2);
			}
		}

		/// <summary>
		/// <para> If your game is a "mod," pass the string that identifies it.  The default is an empty string, meaning</para>
		/// <para> this application is the original game, not a mod.</para>
		/// <para> @see k_cbMaxGameServerGameDir</para>
		/// <para>如果您的游戏是“ mod”，请传递标识它的字符串。默认值是一个空字符串，这意味着此应用程序是原始游戏，而不是mod。 @See k_cbmaxgameservergamedir</para>
		/// </summary>
		public static void SetModDir(string pszModDir) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pszModDir2 = new InteropHelp.UTF8StringHandle(pszModDir)) {
				NativeMethods.ISteamGameServer_SetModDir(CSteamGameServerAPIContext.GetSteamGameServer(), pszModDir2);
			}
		}

		/// <summary>
		/// <para> Is this is a dedicated server?  The default value is false.</para>
		/// <para>这是专用服务器吗？默认值是错误的。</para>
		/// </summary>
		public static void SetDedicatedServer(bool bDedicated) {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamGameServer_SetDedicatedServer(CSteamGameServerAPIContext.GetSteamGameServer(), bDedicated);
		}

		/// <summary>
		/// <para> Login</para>
		/// <para> Begin process to login to a persistent game server account</para>
		/// <para> You need to register for callbacks to determine the result of this operation.</para>
		/// <para> @see SteamServersConnected_t</para>
		/// <para> @see SteamServerConnectFailure_t</para>
		/// <para> @see SteamServersDisconnected_t</para>
		/// <para>登录 开始流程登录到持续的游戏服务器帐户 您需要注册回调以确定此操作的结果。@See steamserversConnected_t @See steamserverconnectfailure_t @see steamserversdisconnected_t_t</para>
		/// </summary>
		public static void LogOn(string pszToken) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pszToken2 = new InteropHelp.UTF8StringHandle(pszToken)) {
				NativeMethods.ISteamGameServer_LogOn(CSteamGameServerAPIContext.GetSteamGameServer(), pszToken2);
			}
		}

		/// <summary>
		/// <para> Login to a generic, anonymous account.</para>
		/// <para> Note: in previous versions of the SDK, this was automatically called within SteamGameServer_Init,</para>
		/// <para> but this is no longer the case.</para>
		/// <para>登录到通用的匿名帐户。 注意：在SDK的先前版本中，这是在SteamGameserver_init中自动调用的，但事实并非如此。</para>
		/// </summary>
		public static void LogOnAnonymous() {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamGameServer_LogOnAnonymous(CSteamGameServerAPIContext.GetSteamGameServer());
		}

		/// <summary>
		/// <para> Begin process of logging game server out of steam</para>
		/// <para>从Steam开始记录游戏服务器的过程</para>
		/// </summary>
		public static void LogOff() {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamGameServer_LogOff(CSteamGameServerAPIContext.GetSteamGameServer());
		}

		/// <summary>
		/// <para> status functions</para>
		/// <para>状态功能</para>
		/// </summary>
		public static bool BLoggedOn() {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServer_BLoggedOn(CSteamGameServerAPIContext.GetSteamGameServer());
		}

		public static bool BSecure() {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServer_BSecure(CSteamGameServerAPIContext.GetSteamGameServer());
		}

		public static CSteamID GetSteamID() {
			InteropHelp.TestIfAvailableGameServer();
			return (CSteamID)NativeMethods.ISteamGameServer_GetSteamID(CSteamGameServerAPIContext.GetSteamGameServer());
		}

		/// <summary>
		/// <para> Returns true if the master server has requested a restart.</para>
		/// <para> Only returns true once per request.</para>
		/// <para>如果主服务器已请求重新启动，则返回true。每个请求仅返回一次。</para>
		/// </summary>
		public static bool WasRestartRequested() {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServer_WasRestartRequested(CSteamGameServerAPIContext.GetSteamGameServer());
		}

		/// <summary>
		/// <para> Server state.  These properties may be changed at any time.</para>
		/// <para> Max player count that will be reported to server browser and client queries</para>
		/// <para>服务器状态。这些属性可以随时更改。 最大播放器计数将报告给服务器浏览器和客户端查询</para>
		/// </summary>
		public static void SetMaxPlayerCount(int cPlayersMax) {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamGameServer_SetMaxPlayerCount(CSteamGameServerAPIContext.GetSteamGameServer(), cPlayersMax);
		}

		/// <summary>
		/// <para> Number of bots.  Default value is zero</para>
		/// <para>机器人数。默认值为零</para>
		/// </summary>
		public static void SetBotPlayerCount(int cBotplayers) {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamGameServer_SetBotPlayerCount(CSteamGameServerAPIContext.GetSteamGameServer(), cBotplayers);
		}

		/// <summary>
		/// <para> Set the name of server as it will appear in the server browser</para>
		/// <para> @see k_cbMaxGameServerName</para>
		/// <para>设置将显示在服务器浏览器中的服务器的名称 @See k_cbmaxgameservername</para>
		/// </summary>
		public static void SetServerName(string pszServerName) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pszServerName2 = new InteropHelp.UTF8StringHandle(pszServerName)) {
				NativeMethods.ISteamGameServer_SetServerName(CSteamGameServerAPIContext.GetSteamGameServer(), pszServerName2);
			}
		}

		/// <summary>
		/// <para> Set name of map to report in the server browser</para>
		/// <para> @see k_cbMaxGameServerMapName</para>
		/// <para>设置在服务器浏览器中报告的地图名称 @See k_cbmaxgameservermapname</para>
		/// </summary>
		public static void SetMapName(string pszMapName) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pszMapName2 = new InteropHelp.UTF8StringHandle(pszMapName)) {
				NativeMethods.ISteamGameServer_SetMapName(CSteamGameServerAPIContext.GetSteamGameServer(), pszMapName2);
			}
		}

		/// <summary>
		/// <para> Let people know if your server will require a password</para>
		/// <para>让人们知道您的服务器是否需要密码</para>
		/// </summary>
		public static void SetPasswordProtected(bool bPasswordProtected) {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamGameServer_SetPasswordProtected(CSteamGameServerAPIContext.GetSteamGameServer(), bPasswordProtected);
		}

		/// <summary>
		/// <para> Spectator server port to advertise.  The default value is zero, meaning the</para>
		/// <para> service is not used.  If your server receives any info requests on the LAN,</para>
		/// <para> this is the value that will be placed into the reply for such local queries.</para>
		/// <para> This is also the value that will be advertised by the master server.</para>
		/// <para> The only exception is if your server is using a FakeIP.  Then then the second</para>
		/// <para> fake port number (index 1) assigned to your server will be listed on the master</para>
		/// <para> server as the spectator port, if you set this value to any nonzero value.</para>
		/// <para> This function merely controls the values that are advertised -- it's up to you to</para>
		/// <para> configure the server to actually listen on this port and handle any spectator traffic</para>
		/// <para>观众服务器端口要广告。默认值为零，这意味着不使用服务。如果您的服务器收到LAN上的任何信息请求，则该值将被放入此类查询的答复中。 这也是主服务器将宣传的价值。唯一的例外是您的服务器正在使用FakeIP。然后，如果您将此值设置为任何非零值，则分配给服务器的第二个假端口号（索引1）将在主服务器上列为观众端口。 此函数仅控制广告的值 - 由您配置服务器以实际收听此端口并处理任何观众流量</para>
		/// </summary>
		public static void SetSpectatorPort(ushort unSpectatorPort) {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamGameServer_SetSpectatorPort(CSteamGameServerAPIContext.GetSteamGameServer(), unSpectatorPort);
		}

		/// <summary>
		/// <para> Name of the spectator server.  (Only used if spectator port is nonzero.)</para>
		/// <para> @see k_cbMaxGameServerMapName</para>
		/// <para>观众服务器的名称。（仅当观众端口为非零时才使用。） @See k_cbmaxgameservermapname</para>
		/// </summary>
		public static void SetSpectatorServerName(string pszSpectatorServerName) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pszSpectatorServerName2 = new InteropHelp.UTF8StringHandle(pszSpectatorServerName)) {
				NativeMethods.ISteamGameServer_SetSpectatorServerName(CSteamGameServerAPIContext.GetSteamGameServer(), pszSpectatorServerName2);
			}
		}

		/// <summary>
		/// <para> Call this to clear the whole list of key/values that are sent in rules queries.</para>
		/// <para>调用此消息以清除规则查询中发送的密钥/值的整个列表。</para>
		/// </summary>
		public static void ClearAllKeyValues() {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamGameServer_ClearAllKeyValues(CSteamGameServerAPIContext.GetSteamGameServer());
		}

		/// <summary>
		/// <para> Call this to add/update a key/value pair.</para>
		/// <para>调用此添加/更新键/值对。</para>
		/// </summary>
		public static void SetKeyValue(string pKey, string pValue) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pKey2 = new InteropHelp.UTF8StringHandle(pKey))
			using (var pValue2 = new InteropHelp.UTF8StringHandle(pValue)) {
				NativeMethods.ISteamGameServer_SetKeyValue(CSteamGameServerAPIContext.GetSteamGameServer(), pKey2, pValue2);
			}
		}

		/// <summary>
		/// <para> Sets a string defining the "gametags" for this server, this is optional, but if it is set</para>
		/// <para> it allows users to filter in the matchmaking/server-browser interfaces based on the value</para>
		/// <para> @see k_cbMaxGameServerTags</para>
		/// <para>设置一个为该服务器定义“ Gametags”的字符串，这是可选的，但是如果设置了该服务器 @See k_cbmaxgameservertags</para>
		/// </summary>
		public static void SetGameTags(string pchGameTags) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pchGameTags2 = new InteropHelp.UTF8StringHandle(pchGameTags)) {
				NativeMethods.ISteamGameServer_SetGameTags(CSteamGameServerAPIContext.GetSteamGameServer(), pchGameTags2);
			}
		}

		/// <summary>
		/// <para> Sets a string defining the "gamedata" for this server, this is optional, but if it is set</para>
		/// <para> it allows users to filter in the matchmaking/server-browser interfaces based on the value</para>
		/// <para> @see k_cbMaxGameServerGameData</para>
		/// <para>设置一个为该服务器定义“ gamedata”的字符串，这是可选的，但是如果设置了该服务器 @See k_cbmaxgameservergamedata</para>
		/// </summary>
		public static void SetGameData(string pchGameData) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pchGameData2 = new InteropHelp.UTF8StringHandle(pchGameData)) {
				NativeMethods.ISteamGameServer_SetGameData(CSteamGameServerAPIContext.GetSteamGameServer(), pchGameData2);
			}
		}

		/// <summary>
		/// <para> Region identifier.  This is an optional field, the default value is empty, meaning the "world" region</para>
		/// <para>区域标识符。这是一个可选字段，默认值是空的，这意味着“世界”区域</para>
		/// </summary>
		public static void SetRegion(string pszRegion) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pszRegion2 = new InteropHelp.UTF8StringHandle(pszRegion)) {
				NativeMethods.ISteamGameServer_SetRegion(CSteamGameServerAPIContext.GetSteamGameServer(), pszRegion2);
			}
		}

		/// <summary>
		/// <para> Indicate whether you wish to be listed on the master server list</para>
		/// <para> and/or respond to server browser / LAN discovery packets.</para>
		/// <para> The server starts with this value set to false.  You should set all</para>
		/// <para> relevant server parameters before enabling advertisement on the server.</para>
		/// <para> (This function used to be named EnableHeartbeats, so if you are wondering</para>
		/// <para> where that function went, it's right here.  It does the same thing as before,</para>
		/// <para> the old name was just confusing.)</para>
		/// <para>指示您是否希望在主服务器列表中列出和 /或响应服务器浏览器 / LAN发现数据包。服务器以此值设置为false开始。在启用服务器上的广告之前，您应该设置所有相关的服务器参数。 （此功能曾经被命名为EnableHeartBeats，因此，如果您想知道该功能去了哪里，就在这里。它与以前相同的事情，旧名称只是令人困惑的。）</para>
		/// </summary>
		public static void SetAdvertiseServerActive(bool bActive) {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamGameServer_SetAdvertiseServerActive(CSteamGameServerAPIContext.GetSteamGameServer(), bActive);
		}

		/// <summary>
		/// <para> Player list management / authentication.</para>
		/// <para> Retrieve ticket to be sent to the entity who wishes to authenticate you ( using BeginAuthSession API ).</para>
		/// <para> pcbTicket retrieves the length of the actual ticket.</para>
		/// <para> SteamNetworkingIdentity is an optional parameter to hold the public IP address of the entity you are connecting to</para>
		/// <para> if an IP address is passed Steam will only allow the ticket to be used by an entity with that IP address</para>
		/// <para>玩家列表管理 /身份验证。 检索希望将您验证您身份验证的实体发送的机票（使用BeginAuthSession API）。PCBTicket检索实际票的长度。SteamnetWorkingIdentity是一个可选参数，可容纳您要连接到的实体的公共IP地址，如果通过IP地址通过Steam仅允许使用该IP地址的实体使用票证</para>
		/// </summary>
		public static HAuthTicket GetAuthSessionTicket(byte[] pTicket, int cbMaxTicket, out uint pcbTicket, ref SteamNetworkingIdentity pSnid) {
			InteropHelp.TestIfAvailableGameServer();
			return (HAuthTicket)NativeMethods.ISteamGameServer_GetAuthSessionTicket(CSteamGameServerAPIContext.GetSteamGameServer(), pTicket, cbMaxTicket, out pcbTicket, ref pSnid);
		}

		/// <summary>
		/// <para> Authenticate ticket ( from GetAuthSessionTicket ) from entity steamID to be sure it is valid and isnt reused</para>
		/// <para> Registers for callbacks if the entity goes offline or cancels the ticket ( see ValidateAuthTicketResponse_t callback and EAuthSessionResponse )</para>
		/// <para>从实体Steamid进行身份验证票证（从getauthsessionticket）确保如果实体脱机或取消票证，请确保其有效，并且不会重新使用寄存器（请参阅valialateateAuthTicketTicketTicketTicketResponse_t回调和EauthSessionSessionSponse））</para>
		/// </summary>
		public static EBeginAuthSessionResult BeginAuthSession(byte[] pAuthTicket, int cbAuthTicket, CSteamID steamID) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServer_BeginAuthSession(CSteamGameServerAPIContext.GetSteamGameServer(), pAuthTicket, cbAuthTicket, steamID);
		}

		/// <summary>
		/// <para> Stop tracking started by BeginAuthSession - called when no longer playing game with this entity</para>
		/// <para>停止跟踪是由Beginauthsession启动的 - 当不再与该实体玩游戏时呼唤</para>
		/// </summary>
		public static void EndAuthSession(CSteamID steamID) {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamGameServer_EndAuthSession(CSteamGameServerAPIContext.GetSteamGameServer(), steamID);
		}

		/// <summary>
		/// <para> Cancel auth ticket from GetAuthSessionTicket, called when no longer playing game with the entity you gave the ticket to</para>
		/// <para>取消getauthsessionticket的验证票，当不再与您提供的机票玩游戏时，请召集</para>
		/// </summary>
		public static void CancelAuthTicket(HAuthTicket hAuthTicket) {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamGameServer_CancelAuthTicket(CSteamGameServerAPIContext.GetSteamGameServer(), hAuthTicket);
		}

		/// <summary>
		/// <para> After receiving a user's authentication data, and passing it to SendUserConnectAndAuthenticate, use this function</para>
		/// <para> to determine if the user owns downloadable content specified by the provided AppID.</para>
		/// <para>在接收用户的身份验证数据并将其传递给SenduserConnectAntentatice之后，使用此功能来确定用户是否拥有提供的Appid指定的可下载内容。</para>
		/// </summary>
		public static EUserHasLicenseForAppResult UserHasLicenseForApp(CSteamID steamID, AppId_t appID) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServer_UserHasLicenseForApp(CSteamGameServerAPIContext.GetSteamGameServer(), steamID, appID);
		}

		/// <summary>
		/// <para> Ask if a user in in the specified group, results returns async by GSUserGroupStatus_t</para>
		/// <para> returns false if we're not connected to the steam servers and thus cannot ask</para>
		/// <para>询问指定组中的用户是否在GSUSERGROUPSTATUS_T中返回异步，如果我们未连接到Steam服务器，因此无法询问</para>
		/// </summary>
		public static bool RequestUserGroupStatus(CSteamID steamIDUser, CSteamID steamIDGroup) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServer_RequestUserGroupStatus(CSteamGameServerAPIContext.GetSteamGameServer(), steamIDUser, steamIDGroup);
		}

		/// <summary>
		/// <para> these two functions s are deprecated, and will not return results</para>
		/// <para> they will be removed in a future version of the SDK</para>
		/// <para>这两个函数已被弃用，并且不会返回结果，它们将在SDK的将来版本中删除</para>
		/// </summary>
		public static void GetGameplayStats() {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamGameServer_GetGameplayStats(CSteamGameServerAPIContext.GetSteamGameServer());
		}

		public static SteamAPICall_t GetServerReputation() {
			InteropHelp.TestIfAvailableGameServer();
			return (SteamAPICall_t)NativeMethods.ISteamGameServer_GetServerReputation(CSteamGameServerAPIContext.GetSteamGameServer());
		}

		/// <summary>
		/// <para> Returns the public IP of the server according to Steam, useful when the server is</para>
		/// <para> behind NAT and you want to advertise its IP in a lobby for other clients to directly</para>
		/// <para> connect to</para>
		/// <para>根据Steam返回服务器的公共IP，当服务器位于NAT后面时，您想在大厅中宣传其IP，以供其他客户直接连接到</para>
		/// </summary>
		public static SteamIPAddress_t GetPublicIP() {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServer_GetPublicIP(CSteamGameServerAPIContext.GetSteamGameServer());
		}

		/// <summary>
		/// <para> Server browser related query packet processing for shared socket mode.  These are used</para>
		/// <para> when you pass STEAMGAMESERVER_QUERY_PORT_SHARED as the query port to SteamGameServer_Init.</para>
		/// <para> IP address and port are in host order, i.e 127.0.0.1 == 0x7f000001</para>
		/// <para> These are used when you've elected to multiplex the game server's UDP socket</para>
		/// <para> rather than having the master server updater use its own sockets.</para>
		/// <para> Source games use this to simplify the job of the server admins, so they</para>
		/// <para> don't have to open up more ports on their firewalls.</para>
		/// <para> Call this when a packet that starts with 0xFFFFFFFF comes in. That means</para>
		/// <para> it's for us.</para>
		/// <para>服务器浏览器相关的查询数据包处理共享套接字模式。当您将steamgameserver_query_port_shared作为查询端口传递给steamgameserver_init时，使用这些。IP地址和端口按主机顺序，即127.0.0.1 == 0x7f000001当选为多重乘坐游戏服务器的UDP套接字时，使用这些。 源游戏使用它来简化服务器管理员的作业，因此他们不必在防火墙上打开更多端口。当一个以0xffffffff开头的数据包进来时，请致电。这意味着它适合我们。</para>
		/// </summary>
		public static bool HandleIncomingPacket(byte[] pData, int cbData, uint srcIP, ushort srcPort) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServer_HandleIncomingPacket(CSteamGameServerAPIContext.GetSteamGameServer(), pData, cbData, srcIP, srcPort);
		}

		/// <summary>
		/// <para> AFTER calling HandleIncomingPacket for any packets that came in that frame, call this.</para>
		/// <para> This gets a packet that the master server updater needs to send out on UDP.</para>
		/// <para> It returns the length of the packet it wants to send, or 0 if there are no more packets to send.</para>
		/// <para> Call this each frame until it returns 0.</para>
		/// <para>在调用该框架中任何数据包的句柄incomingpacket之后，请致电。这将获得主服务器更新程序需要在UDP上发送的数据包。它返回要发送的数据包的长度，或者如果没有更多数据包，则返回0。调用每个帧直到返回0。</para>
		/// </summary>
		public static int GetNextOutgoingPacket(byte[] pOut, int cbMaxOut, out uint pNetAdr, out ushort pPort) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServer_GetNextOutgoingPacket(CSteamGameServerAPIContext.GetSteamGameServer(), pOut, cbMaxOut, out pNetAdr, out pPort);
		}

		/// <summary>
		/// <para> Server clan association</para>
		/// <para> associate this game server with this clan for the purposes of computing player compat</para>
		/// <para>服务器氏族协会 将此氏族与该氏族相关联，以计算玩家兼容</para>
		/// </summary>
		public static SteamAPICall_t AssociateWithClan(CSteamID steamIDClan) {
			InteropHelp.TestIfAvailableGameServer();
			return (SteamAPICall_t)NativeMethods.ISteamGameServer_AssociateWithClan(CSteamGameServerAPIContext.GetSteamGameServer(), steamIDClan);
		}

		/// <summary>
		/// <para> ask if any of the current players dont want to play with this new player - or vice versa</para>
		/// <para>询问当前的任何玩家是否不想玩这个新球员 - 反之亦然</para>
		/// </summary>
		public static SteamAPICall_t ComputeNewPlayerCompatibility(CSteamID steamIDNewPlayer) {
			InteropHelp.TestIfAvailableGameServer();
			return (SteamAPICall_t)NativeMethods.ISteamGameServer_ComputeNewPlayerCompatibility(CSteamGameServerAPIContext.GetSteamGameServer(), steamIDNewPlayer);
		}

		/// <summary>
		/// <para> Handles receiving a new connection from a Steam user.  This call will ask the Steam</para>
		/// <para> servers to validate the users identity, app ownership, and VAC status.  If the Steam servers</para>
		/// <para> are off-line, then it will validate the cached ticket itself which will validate app ownership</para>
		/// <para> and identity.  The AuthBlob here should be acquired on the game client using SteamUser()-&gt;InitiateGameConnection()</para>
		/// <para> and must then be sent up to the game server for authentication.</para>
		/// <para> Return Value: returns true if the users ticket passes basic checks. pSteamIDUser will contain the Steam ID of this user. pSteamIDUser must NOT be NULL</para>
		/// <para> If the call succeeds then you should expect a GSClientApprove_t or GSClientDeny_t callback which will tell you whether authentication</para>
		/// <para> for the user has succeeded or failed (the steamid in the callback will match the one returned by this call)</para>
		/// <para> DEPRECATED!  This function will be removed from the SDK in an upcoming version.</para>
		/// <para>              Please migrate to BeginAuthSession and related functions.</para>
		/// <para>从Steam用户接收新连接的操作。此通话将要求Steam服务器验证用户身份，应用程序所有权和VAC状态。如果蒸汽服务器离线，则将验证缓存的票务本身，该机票本身将验证应用程序所有权和身份。这里应使用Steamuser（） - > initiateGameConnection（）在游戏客户端上获取authBlob，然后必须将其发送到游戏服务器以进行身份​​验证。 返回值：如果用户门票通过基本检查，则返回true。PsteamIduser将包含此用户的Steam ID。psteamIduser不得无效，如果呼叫成功，那么您应该期望gsclientapprove_t或gsclientdeny_t回调，这将告诉您用户的身份验证是否已成功或失败（回调中的SteamID将匹配此调用的返回的验证）） 弃用！此函数将在即将发布的版本中从SDK中删除。请迁移到开始活动和相关功能。</para>
		/// </summary>
		public static bool SendUserConnectAndAuthenticate_DEPRECATED(uint unIPClient, byte[] pvAuthBlob, uint cubAuthBlobSize, out CSteamID pSteamIDUser) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamGameServer_SendUserConnectAndAuthenticate_DEPRECATED(CSteamGameServerAPIContext.GetSteamGameServer(), unIPClient, pvAuthBlob, cubAuthBlobSize, out pSteamIDUser);
		}

		/// <summary>
		/// <para> Creates a fake user (ie, a bot) which will be listed as playing on the server, but skips validation.</para>
		/// <para> Return Value: Returns a SteamID for the user to be tracked with, you should call EndAuthSession()</para>
		/// <para> when this user leaves the server just like you would for a real user.</para>
		/// <para>创建一个假用户（即，一个机器人），该用户将在服务器上列出，但会跳过验证。 返回值：返回供用户跟踪的蒸汽，当用户像真实用户一样离开服务器时，应调用endauthsession（）。</para>
		/// </summary>
		public static CSteamID CreateUnauthenticatedUserConnection() {
			InteropHelp.TestIfAvailableGameServer();
			return (CSteamID)NativeMethods.ISteamGameServer_CreateUnauthenticatedUserConnection(CSteamGameServerAPIContext.GetSteamGameServer());
		}

		/// <summary>
		/// <para> Should be called whenever a user leaves our game server, this lets Steam internally</para>
		/// <para> track which users are currently on which servers for the purposes of preventing a single</para>
		/// <para> account being logged into multiple servers, showing who is currently on a server, etc.</para>
		/// <para> DEPRECATED!  This function will be removed from the SDK in an upcoming version.</para>
		/// <para>              Please migrate to BeginAuthSession and related functions.</para>
		/// <para>每当用户离开我们的游戏服务器时，都应调用，这使Steam可以内部跟踪哪些用户当前在哪些服务器上，以防止单个帐户登录到多个服务器，显示谁当前在服务器上，等等。 弃用！此函数将在即将发布的版本中从SDK中删除。请迁移到开始活动和相关功能。</para>
		/// </summary>
		public static void SendUserDisconnect_DEPRECATED(CSteamID steamIDUser) {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamGameServer_SendUserDisconnect_DEPRECATED(CSteamGameServerAPIContext.GetSteamGameServer(), steamIDUser);
		}

		/// <summary>
		/// <para> Update the data to be displayed in the server browser and matchmaking interfaces for a user</para>
		/// <para> currently connected to the server.  For regular users you must call this after you receive a</para>
		/// <para> GSUserValidationSuccess callback.</para>
		/// <para> Return Value: true if successful, false if failure (ie, steamIDUser wasn't for an active player)</para>
		/// <para>更新目前连接到服务器的用户的服务器浏览器和对接接口中要显示的数据。对于常规用户，您必须在收到GSuserValidationsuccess回调后调用。 返回值：如果成功，则为false，如果失败（即Steamiduser不适合活跃的播放器）</para>
		/// </summary>
		public static bool BUpdateUserData(CSteamID steamIDUser, string pchPlayerName, uint uScore) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pchPlayerName2 = new InteropHelp.UTF8StringHandle(pchPlayerName)) {
				return NativeMethods.ISteamGameServer_BUpdateUserData(CSteamGameServerAPIContext.GetSteamGameServer(), steamIDUser, pchPlayerName2, uScore);
			}
		}
	}
}

#endif // !DISABLESTEAMWORKS
