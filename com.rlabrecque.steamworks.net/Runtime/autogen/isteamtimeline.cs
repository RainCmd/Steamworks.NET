// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
	#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	public static class SteamTimeline {
		/// <summary>
		/// <para> Sets a description for the current game state in the timeline. These help the user to find specific</para>
		/// <para> moments in the timeline when saving clips. Setting a new state description replaces any previous</para>
		/// <para> description.</para>
		/// <para> Examples could include:</para>
		/// <para>  * Where the user is in the world in a single player game</para>
		/// <para>  * Which round is happening in a multiplayer game</para>
		/// <para>  * The current score for a sports game</para>
		/// <para> Parameters:</para>
		/// <para> - pchDescription: provide a localized string in the language returned by SteamUtils()-&gt;GetSteamUILanguage()</para>
		/// <para> - flTimeDelta: The time offset in seconds to apply to this event. Negative times indicate an</para>
		/// <para>			event that happened in the past.</para>
		/// <para>为当前游戏状态设置时间线描述。这些有助于用户在保存片段时找到时间线中的特定时刻。设置新状态描述会覆盖任何先前描述。</para>
		/// <para>示例可能包括：* 单人游戏中玩家所处的位置 * 在多人游戏中正在进行的轮次 * 体育游戏中当前的得分</para>
		/// <para>参数：- pchDescription：提供 SteamUtils()->GetSteamUILanguage() 返回的语言中本地化的字符串 - flTimeDelta：将应用于此事件的时间偏移量（秒）。负时间表示事件发生在过去。</para>
		/// </summary>
		public static void SetTimelineTooltip(string pchDescription, float flTimeDelta) {
			InteropHelp.TestIfAvailableClient();
			using (var pchDescription2 = new InteropHelp.UTF8StringHandle(pchDescription)) {
				NativeMethods.ISteamTimeline_SetTimelineTooltip(CSteamAPIContext.GetSteamTimeline(), pchDescription2, flTimeDelta);
			}
		}

		public static void ClearTimelineTooltip(float flTimeDelta) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamTimeline_ClearTimelineTooltip(CSteamAPIContext.GetSteamTimeline(), flTimeDelta);
		}

		/// <summary>
		/// <para> Changes the color of the timeline bar. See ETimelineGameMode comments for how to use each value</para>
		/// <para>更改时间线条的颜色。请参阅 ETimelineGameMode 评论以了解如何使用每个值。</para>
		/// </summary>
		public static void SetTimelineGameMode(ETimelineGameMode eMode) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamTimeline_SetTimelineGameMode(CSteamAPIContext.GetSteamTimeline(), eMode);
		}

		/// <summary>
		/// <para>******************    Timeline Events    ******************</para>
		/// <para> The following functions add events and/or tags to the timeline.  There are helpers to add simple events or tags in a single call.</para>
		/// <para> or you can use StartEvent and CloseEvent to customize what gets added.</para>
		/// <para> Examples of events to add could include:</para>
		/// <para>   * a boss battle</para>
		/// <para>   * a cut scene</para>
		/// <para>   * a large team fight</para>
		/// <para>   * picking up a new weapon or ammunition</para>
		/// <para>   * scoring a goal</para>
		/// <para> Adding an event and a time range with the simple API:</para>
		/// <para> don't show filter</para>
		/// <para> start now</para>
		/// <para>   SteamTimeline()-&gt;AddSimpleTimelineEvent( "steam_heart", Localize( "#user healed" ), Localize( "#health_amount", 27 ), 15, 0, 0, k_ETimelineEventClipPriority_None );</para>
		/// <para> start 10 sec ago</para>
		/// <para>   SteamTimeline()-&gt;AddTaggedTimeRange( Localize( "#player_resting" ), "steam_flag", nullptr, 15, 0, 10 );</para>
		/// <para>   SteamTimeline()-&gt;AddTaggedTimeRange( Localize( "#player_cast_light" ), "steam_starburst", Localize( "#player_spells" ), 10,  -10, 5 );</para>
		/// <para> start now</para>
		/// <para> Adding a marker and time range in one event:</para>
		/// <para>   TimelineEventHandle_t event = SteamTimeline()-&gt;StartEvent(  0 );</para>
		/// <para> start now</para>
		/// <para>   SteamTimeline()-&gt;ShowEventOnTimeline( event, "steam_heart", Localize( "#player_healed" ), Localize( "#player_healed_amount", 27 ), 15 );</para>
		/// <para>   SteamTimeline()-&gt;AddEventTag( event, Localize( "#player_cast_heal" ), "steam_heart", Localize( "#player_, 15, 0, 10 );</para>
		/// <para>   ... // time passes</para>
		/// <para>   SteamTimeline()-&gt;CloseEvent( event );</para>
		/// <para> Parameters used by the event functions:</para>
		/// <para> - ulOpenEvent: An event returned by StartEvent that has not yet had CancelEvent or CloseEvent called on it</para>
		/// <para> - ulEvent: An event that has had CloseEvent called on it, or an event returned from AddSimpleTimelineEvent or AddTaggedTimeRange (which</para>
		/// <para>   are closed automatically.)</para>
		/// <para> - pchIcon: specify the name of the icon uploaded through the Steamworks Partner Site for your title</para>
		/// <para>   or one of the provided icons that start with steam_</para>
		/// <para> - pchTitle &amp; pchDescription: provide a localized string in the language returned by</para>
		/// <para>	 SteamUtils()-&gt;GetSteamUILanguage()</para>
		/// <para> - unIconPriority: specify how important this range is compared to other markers provided by the game.</para>
		/// <para>   Ranges with larger priority values will be displayed more prominently in the UI. This value</para>
		/// <para>   may be between 0 and k_unMaxTimelinePriority.</para>
		/// <para> - flStartOffsetSeconds: The time that this range started relative to now. Negative times</para>
		/// <para>   indicate an event that happened in the past.</para>
		/// <para> - flDurationSeconds: How long the time range should be in seconds. For instantaneous events, this</para>
		/// <para>   should be 0</para>
		/// <para> - ePossibleClip: By setting this parameter to Featured or Standard, the game indicates to Steam that it</para>
		/// <para>   would be appropriate to offer this range as a clip to the user. For instantaneous events, the</para>
		/// <para>   suggested clip will be for a short time before and after the event itself.</para>
		/// <para> - pchTagIcon: specify an icon name that will be used next to the tag name in the UI</para>
		/// <para> - pchTagName: The localized name of the tag to show in the UI.</para>
		/// <para> - pchTagGroup: The localized name of the tag group to show in the UI. If this is not specified, users will not be able to filter by this tag</para>
		/// <para> - unTagPriority: specify how important this tag is compared to other tags provided by the game.</para>
		/// <para> Returns:</para>
		/// <para>   A TimelineEventHandle_t that can be used to make subsequent calls to refer to the timeline event. This event handle is invalid</para>
		/// <para>   after the game exits.</para>
		/// <para> quick helpers that add to the timeline in one call</para>
		/// <para>******************    时间线事件    ****************** 以下函数添加事件和/或标签到时间线。 它们提供帮助函数，可以一次性添加简单的事件或标签，或者您可以使用 StartEvent 和 CloseEvent 来自定义添加的内容。</para>
		/// <para>可以添加的事件示例包括：* BOSS战 * 场景 * 大型团队战斗 * 拾取新武器或弹药 * 进球</para>
		/// <para>使用简单API添加事件和时间范围：不显示筛选器开始于现在。 SteamTimeline()->AddSimpleTimelineEvent( "steam_heart", Localize( "#user healed" ), Localize( "#health_amount", 27 ), 15, 0, 0, k_ETimelineEventClipPriority_None ); 从10秒前开始。 SteamTimeline()->AddTaggedTimeRange( Localize( "#player_resting" ), "steam_flag", nullptr, 15, 0, 10 ); SteamTimeline()->AddTaggedTimeRange( Localize( "#player_cast_light" ), "steam_starburst", Localize( "#player_spells" ), 10, -10, 5 );</para>
		/// <para>开始现在 添加标记和时间范围到一个事件： TimelineEventHandle_t event = SteamTimeline()->StartEvent( 0 ); 开始现在 SteamTimeline()->ShowEventOnTimeline( event, "steam_heart", Localize( "#player_healed" ), Localize( "#player_healed_amount", 27 ), 15 ); SteamTimeline()->AddEventTag( event, Localize( "#player_cast_heal" ), "steam_heart", Localize( "#player_, 15, 0, 10 ); ... // 时间流逝 SteamTimeline()->CloseEvent( event );</para>
		/// <para>事件函数使用的参数：</para>
		/// <para>- ulOpenEvent: 一种由 StartEvent 返回且尚未调用 CancelEvent 或 CloseEvent 的事件 - ulEvent: 一种已调用 CloseEvent 的事件，或由 AddSimpleTimelineEvent 或 AddTaggedTimeRange 返回的事件（这些事件会自动关闭）。 - pchIcon: 指定通过 Steamworks 合作伙伴网站上传到标题的图标，或以 steam_ 开头的提供的图标名称 - pchTitle & pchDescription: 提供 SteamUtils()->GetSteamUILanguage() 返回的语言中的本地化字符串 - unIconPriority: 指定该范围相对于游戏提供的其他标记的重要性。具有较大优先级值的范围将在 UI 中显示得更突出。此值介于 0 和 k_unMaxTimelinePriority 之间。 - flStartOffsetSeconds: 此范围相对于当前时间的开始时间。负时间表示事件发生在过去。 - flDurationSeconds: 时间范围的持续时间，以秒为单位。对于瞬时事件，应设置为 0 - ePossibleClip: 通过将此参数设置为 Featured 或 Standard，游戏指示 Steam 认为该范围适合作为剪辑提供给用户。对于瞬时事件，建议的剪辑将在事件本身之前和之后的一短时间内提供。 - pchTagIcon: 指定将在 UI 中与标签名称旁边使用的图标名称 - pchTagName: UI 中显示的标签本地化名称 - pchTagGroup: UI 中显示的标签组本地化名称。如果未指定，则用户将无法按此标签过滤 - unTagPriority: 指定该标签相对于游戏提供的其他标签的重要性。 - Returns: A TimelineEventHandle_t that can be used to make subsequent calls to refer to the timeline event. This event handle is invalid after the game exits. quick helpers that add to the timeline in one call</para>
		/// </summary>
		public static TimelineEventHandle_t AddInstantaneousTimelineEvent(string pchTitle, string pchDescription, string pchIcon, uint unIconPriority, float flStartOffsetSeconds = 0.0f, ETimelineEventClipPriority ePossibleClip = ETimelineEventClipPriority.k_ETimelineEventClipPriority_None) {
			InteropHelp.TestIfAvailableClient();
			using (var pchTitle2 = new InteropHelp.UTF8StringHandle(pchTitle))
			using (var pchDescription2 = new InteropHelp.UTF8StringHandle(pchDescription))
			using (var pchIcon2 = new InteropHelp.UTF8StringHandle(pchIcon)) {
				return (TimelineEventHandle_t)NativeMethods.ISteamTimeline_AddInstantaneousTimelineEvent(CSteamAPIContext.GetSteamTimeline(), pchTitle2, pchDescription2, pchIcon2, unIconPriority, flStartOffsetSeconds, ePossibleClip);
			}
		}

		public static TimelineEventHandle_t AddRangeTimelineEvent(string pchTitle, string pchDescription, string pchIcon, uint unIconPriority, float flStartOffsetSeconds = 0.0f, float flDuration = 0.0f, ETimelineEventClipPriority ePossibleClip = ETimelineEventClipPriority.k_ETimelineEventClipPriority_None) {
			InteropHelp.TestIfAvailableClient();
			using (var pchTitle2 = new InteropHelp.UTF8StringHandle(pchTitle))
			using (var pchDescription2 = new InteropHelp.UTF8StringHandle(pchDescription))
			using (var pchIcon2 = new InteropHelp.UTF8StringHandle(pchIcon)) {
				return (TimelineEventHandle_t)NativeMethods.ISteamTimeline_AddRangeTimelineEvent(CSteamAPIContext.GetSteamTimeline(), pchTitle2, pchDescription2, pchIcon2, unIconPriority, flStartOffsetSeconds, flDuration, ePossibleClip);
			}
		}

		/// <summary>
		/// <para> Starts a timeline event at a the current time, plus an offset in seconds. This event must be ended with EndRangeTimelineEvent.</para>
		/// <para> Any timeline events that have not been ended when the game exits will be discarded.</para>
		/// <para>启动一个时间线事件，在当前时间加上偏移秒数。这个事件必须使用 EndRangeTimelineEvent 结束。游戏退出时未结束的所有时间线事件将被丢弃。</para>
		/// </summary>
		public static TimelineEventHandle_t StartRangeTimelineEvent(string pchTitle, string pchDescription, string pchIcon, uint unPriority, float flStartOffsetSeconds, ETimelineEventClipPriority ePossibleClip) {
			InteropHelp.TestIfAvailableClient();
			using (var pchTitle2 = new InteropHelp.UTF8StringHandle(pchTitle))
			using (var pchDescription2 = new InteropHelp.UTF8StringHandle(pchDescription))
			using (var pchIcon2 = new InteropHelp.UTF8StringHandle(pchIcon)) {
				return (TimelineEventHandle_t)NativeMethods.ISteamTimeline_StartRangeTimelineEvent(CSteamAPIContext.GetSteamTimeline(), pchTitle2, pchDescription2, pchIcon2, unPriority, flStartOffsetSeconds, ePossibleClip);
			}
		}

		/// <summary>
		/// <para> Updates fields on a range timeline event that was started with StartRangeTimelineEvent, and which has not been ended.</para>
		/// <para>更新范围时间线事件，该事件是由 StartRangeTimelineEvent 启动的，并且尚未结束。</para>
		/// </summary>
		public static void UpdateRangeTimelineEvent(TimelineEventHandle_t ulEvent, string pchTitle, string pchDescription, string pchIcon, uint unPriority, ETimelineEventClipPriority ePossibleClip) {
			InteropHelp.TestIfAvailableClient();
			using (var pchTitle2 = new InteropHelp.UTF8StringHandle(pchTitle))
			using (var pchDescription2 = new InteropHelp.UTF8StringHandle(pchDescription))
			using (var pchIcon2 = new InteropHelp.UTF8StringHandle(pchIcon)) {
				NativeMethods.ISteamTimeline_UpdateRangeTimelineEvent(CSteamAPIContext.GetSteamTimeline(), ulEvent, pchTitle2, pchDescription2, pchIcon2, unPriority, ePossibleClip);
			}
		}

		/// <summary>
		/// <para> Ends a range timeline event and shows it in the UI.</para>
		/// <para>结束一个时间线事件并将其显示在UI中。</para>
		/// </summary>
		public static void EndRangeTimelineEvent(TimelineEventHandle_t ulEvent, float flEndOffsetSeconds) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamTimeline_EndRangeTimelineEvent(CSteamAPIContext.GetSteamTimeline(), ulEvent, flEndOffsetSeconds);
		}

		/// <summary>
		/// <para> delete the event from the timeline. This can be called on a timeline event from AddInstantaneousTimelineEvent,</para>
		/// <para> AddRangeTimelineEvent, or StartRangeTimelineEvent/EndRangeTimelineEvent. The timeline event handle must be from the</para>
		/// <para> current game process.</para>
		/// <para>从时间线上删除事件。这可以在 AddInstantaneousTimelineEvent、AddRangeTimelineEvent、StartRangeTimelineEvent/EndRangeTimelineEvent 中调用。时间线事件句柄必须来自当前游戏进程。</para>
		/// </summary>
		public static void RemoveTimelineEvent(TimelineEventHandle_t ulEvent) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamTimeline_RemoveTimelineEvent(CSteamAPIContext.GetSteamTimeline(), ulEvent);
		}

		/// <summary>
		/// <para> add a tag to whatever time range is represented by the event</para>
		/// <para>为任何事件所代表的时间范围添加一个标签。</para>
		/// </summary>
		public static SteamAPICall_t DoesEventRecordingExist(TimelineEventHandle_t ulEvent) {
			InteropHelp.TestIfAvailableClient();
			return (SteamAPICall_t)NativeMethods.ISteamTimeline_DoesEventRecordingExist(CSteamAPIContext.GetSteamTimeline(), ulEvent);
		}

		/// <summary>
		/// <para>******************    Game Phases    ******************</para>
		/// <para> Game phases allow the user to navigate their background recordings and clips. Exactly what a game phase means will vary game to game, but</para>
		/// <para> the game phase should be a section of gameplay that is usually between 10 minutes and a few hours in length, and should be the</para>
		/// <para> main way a user would think to divide up the game. These are presented to the user in a UI that shows the date the game was played,</para>
		/// <para> with one row per game slice. Game phases should be used to mark sections of gameplay that the user might be interested in watching.</para>
		/// <para>	Examples could include:</para>
		/// <para>		* A single match in a multiplayer PvP game</para>
		/// <para>		* A chapter of a story-based singleplayer game</para>
		/// <para>		* A single run in a roguelike</para>
		/// <para> Game phases are started with StartGamePhase, and while a phase is still happening, they can have tags and attributes added to them.</para>
		/// <para> Phase attributes represent generic text fields that can be updated throughout the duration of the phase. They are meant</para>
		/// <para> to be used for phase metadata that is not part of a well defined set of options. For example, a KDA attribute that starts</para>
		/// <para> with the value "0/0/0" and updates as the phase progresses, or something like a played-entered character name. Attributes</para>
		/// <para> can be set as many times as the game likes with SetGamePhaseAttribute, and only the last value will be shown to the user.</para>
		/// <para> Phase tags represent data with a well defined set of options, which could be data such as match resolution, hero played,</para>
		/// <para> game mode, etc. Tags can have an icon in addition to a text name. Multiple tags within the same group may be added per phase</para>
		/// <para> and all will be remembered. For example, AddGamePhaseTag may be called multiple times for a "Bosses Defeated" group, with</para>
		/// <para> different names and icons for each boss defeated during the phase, all of which will be shown to the user.</para>
		/// <para> The phase will continue until the game exits, until the game calls EndGamePhase, or until the game calls</para>
		/// <para> StartGamePhase to start a new phase.</para>
		/// <para> The game phase functions take these parameters:</para>
		/// <para> - pchTagIcon: The name of a game provided timeline icon or builtin "steam_" icon.</para>
		/// <para> - pchPhaseID: A game-provided persistent ID for a game phase. This could be a the match ID in a multiplayer game, a chapter name in a</para>
		/// <para>   single player game, the ID of a character, etc.</para>
		/// <para> - pchTagName: The localized name of the tag in the language returned by SteamUtils()-&gt;GetSteamUILanguage().</para>
		/// <para> - pchTagGroup: The localized name of the tag group.</para>
		/// <para> - pchAttributeValue: The localized name of the attribute.</para>
		/// <para> - pchAttributeGroup: The localized name of the attribute group.</para>
		/// <para> - unPriority: Used to order tags and attributes in the UI displayed to the user, with higher priority values leading</para>
		/// <para>   to more prominent positioning. In contexts where there is limited space, lower priority items may be hidden.</para>
		/// <para>游戏阶段 游戏阶段允许用户浏览他们的背景录音和片段。 确切地讲，每个游戏阶段的含义各不相同，但游戏阶段通常是指一段10分钟到几个小时的游戏内容，并且应该作为用户划分游戏的主要方式。 这些内容以一个UI呈现，显示了游戏被玩的时间，每行一个游戏片段。 游戏阶段应该用于标记用户可能感兴趣的玩法部分。</para>
		/// <para>示例可能包括：* 玩家对战模式多人游戏中的一场比赛 * 基于故事的单人游戏中的一个章节 * Roguelike 游戏中的一次通行</para>
		/// <para>游戏阶段通过 StartGamePhase 启动，并且在阶段仍在进行时，可以向它们添加标签和属性。</para>
		/// <para>相位属性代表通用的文本字段，可以在相位的整个过程中进行更新。它们旨在用于非明确选项集中的相位元数据。例如，一个以“0/0/0”值开始并随着相位进展而更新的KDA属性，或者类似已进入游戏的角色名称。可以使用SetGamePhaseAttribute设置属性，可以设置任意次数，但仅会显示给用户最后一次的值。</para>
		/// <para>相控标签代表具有明确选项的数据集，例如比赛结果、所选英雄、游戏模式等。标签可以拥有图标，除了文本名称外。同一组中可以添加多个标签，并且所有标签都会被记住。例如，AddGamePhaseTag 可以在“Boss战结束”组中多次调用，并为每个击败的Boss使用不同的名称和图标，所有这些都会向用户显示。</para>
		/// <para>这个阶段将持续到游戏退出、游戏调用 EndGamePhase 或游戏调用 StartGamePhase 以启动新阶段为止。</para>
		/// <para>游戏阶段函数接受以下参数：- pchTagIcon：游戏提供的时间线图标或内置“steam_”图标的名称。- pchPhaseID：游戏提供的持久化ID，用于游戏阶段。这可以是多人游戏中匹配ID、单人游戏中章节名称、角色ID等。- pchTagName：通过 SteamUtils()->GetSteamUILanguage() 返回的语言中标签的本地化名称。- pchTagGroup：标签组的本地化名称。- pchAttributeValue：属性的本地化名称。- pchAttributeGroup：属性组的本地化名称。- unPriority：用于在用户显示的UI中排序标签和属性，具有更高的优先级值会导致更突出的位置。在空间有限的情况下，优先级较低的项目可能会被隐藏。</para>
		/// </summary>
		public static void StartGamePhase() {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamTimeline_StartGamePhase(CSteamAPIContext.GetSteamTimeline());
		}

		public static void EndGamePhase() {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamTimeline_EndGamePhase(CSteamAPIContext.GetSteamTimeline());
		}

		/// <summary>
		/// <para> Games can set a phase ID so they can refer back to a phase in OpenOverlayToPhase</para>
		/// <para>游戏可以设置一个相位ID，以便可以回溯到OpenOverlayToPhase中的一个相位。</para>
		/// </summary>
		public static void SetGamePhaseID(string pchPhaseID) {
			InteropHelp.TestIfAvailableClient();
			using (var pchPhaseID2 = new InteropHelp.UTF8StringHandle(pchPhaseID)) {
				NativeMethods.ISteamTimeline_SetGamePhaseID(CSteamAPIContext.GetSteamTimeline(), pchPhaseID2);
			}
		}

		public static SteamAPICall_t DoesGamePhaseRecordingExist(string pchPhaseID) {
			InteropHelp.TestIfAvailableClient();
			using (var pchPhaseID2 = new InteropHelp.UTF8StringHandle(pchPhaseID)) {
				return (SteamAPICall_t)NativeMethods.ISteamTimeline_DoesGamePhaseRecordingExist(CSteamAPIContext.GetSteamTimeline(), pchPhaseID2);
			}
		}

		/// <summary>
		/// <para> Add a tag that applies to the entire phase</para>
		/// <para>添加一个应用于整个阶段的标签</para>
		/// </summary>
		public static void AddGamePhaseTag(string pchTagName, string pchTagIcon, string pchTagGroup, uint unPriority) {
			InteropHelp.TestIfAvailableClient();
			using (var pchTagName2 = new InteropHelp.UTF8StringHandle(pchTagName))
			using (var pchTagIcon2 = new InteropHelp.UTF8StringHandle(pchTagIcon))
			using (var pchTagGroup2 = new InteropHelp.UTF8StringHandle(pchTagGroup)) {
				NativeMethods.ISteamTimeline_AddGamePhaseTag(CSteamAPIContext.GetSteamTimeline(), pchTagName2, pchTagIcon2, pchTagGroup2, unPriority);
			}
		}

		/// <summary>
		/// <para> Add a text attribute that applies to the entire phase</para>
		/// <para>添加一个应用于整个阶段的文本属性。</para>
		/// </summary>
		public static void SetGamePhaseAttribute(string pchAttributeGroup, string pchAttributeValue, uint unPriority) {
			InteropHelp.TestIfAvailableClient();
			using (var pchAttributeGroup2 = new InteropHelp.UTF8StringHandle(pchAttributeGroup))
			using (var pchAttributeValue2 = new InteropHelp.UTF8StringHandle(pchAttributeValue)) {
				NativeMethods.ISteamTimeline_SetGamePhaseAttribute(CSteamAPIContext.GetSteamTimeline(), pchAttributeGroup2, pchAttributeValue2, unPriority);
			}
		}

		/// <summary>
		/// <para>******************    Opening the overlay    ******************</para>
		/// <para> Opens the Steam overlay to a game phase.</para>
		/// <para> Parameters:</para>
		/// <para> - pchPhaseID: The ID of a phase that was previously provided by the game in SetGamePhaseID.</para>
		/// <para>******************    打开叠加层    ****************** 打开 Steam 叠加层到游戏阶段。</para>
		/// <para>参数：- pchPhaseID：游戏在 SetGamePhaseID 中提供的相位的 ID。</para>
		/// </summary>
		public static void OpenOverlayToGamePhase(string pchPhaseID) {
			InteropHelp.TestIfAvailableClient();
			using (var pchPhaseID2 = new InteropHelp.UTF8StringHandle(pchPhaseID)) {
				NativeMethods.ISteamTimeline_OpenOverlayToGamePhase(CSteamAPIContext.GetSteamTimeline(), pchPhaseID2);
			}
		}

		/// <summary>
		/// <para> Opens the Steam overlay to a timeline event.</para>
		/// <para> Parameters:</para>
		/// <para> - ulEventID: The ID of a timeline event returned by StartEvent or AddSimpleTimelineEvent</para>
		/// <para>打开 Steam 叠加层到时间线事件。</para>
		/// <para>参数：- ulEventID：一个由 StartEvent 或 AddSimpleTimelineEvent 返回的事件ID。</para>
		/// </summary>
		public static void OpenOverlayToTimelineEvent(TimelineEventHandle_t ulEvent) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamTimeline_OpenOverlayToTimelineEvent(CSteamAPIContext.GetSteamTimeline(), ulEvent);
		}
	}
}

#endif // !DISABLESTEAMWORKS
