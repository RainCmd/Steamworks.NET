// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
	#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	public static class SteamTimeline {
		/// <summary>
		/// <para> Sets a description for the current game state in the timeline. These help the user to find specific</para>
		/// <para> moments in the timeline when saving clips. Setting a new state description replaces any previous</para>
		/// <para> description.</para>
		/// <para> Examples could include:</para>
		/// <para>  * Where the user is in the world in a single player game</para>
		/// <para>  * Which round is happening in a multiplayer game</para>
		/// <para>  * The current score for a sports game</para>
		/// <para> Parameters:</para>
		/// <para> - pchDescription: provide a localized string in the language returned by SteamUtils()-&gt;GetSteamUILanguage()</para>
		/// <para> - flTimeDelta: The time offset in seconds to apply to this event. Negative times indicate an</para>
		/// <para>			event that happened in the past.</para>
		/// <para>在时间表中为当前游戏状态设置描述。这些帮助用户在保存剪辑时找到时间表中的特定时刻。设置新状态说明替换了任何先前的描述。 示例可以包括： *单个玩家游戏中的用户在世界上的位置 *在多人游戏中正在发生的回合 * 参数：-pchdescription：在Steamutils（） - > getSteamUilanguage（）返回的语言中提供一个本地化字符串 -  fltimedelta：以秒为单位的时间偏移以应用于此事件。负时间表示过去发生的事件。</para>
		/// </summary>
		public static void SetTimelineTooltip(string pchDescription, float flTimeDelta) {
			InteropHelp.TestIfAvailableClient();
			using (var pchDescription2 = new InteropHelp.UTF8StringHandle(pchDescription)) {
				NativeMethods.ISteamTimeline_SetTimelineTooltip(CSteamAPIContext.GetSteamTimeline(), pchDescription2, flTimeDelta);
			}
		}

		public static void ClearTimelineTooltip(float flTimeDelta) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamTimeline_ClearTimelineTooltip(CSteamAPIContext.GetSteamTimeline(), flTimeDelta);
		}

		/// <summary>
		/// <para> Changes the color of the timeline bar. See ETimelineGameMode comments for how to use each value</para>
		/// <para>更改时间轴条的颜色。请参阅etimelinegamemode有关如何使用每个值的注释</para>
		/// </summary>
		public static void SetTimelineGameMode(ETimelineGameMode eMode) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamTimeline_SetTimelineGameMode(CSteamAPIContext.GetSteamTimeline(), eMode);
		}

		/// <summary>
		/// <para>******************    Timeline Events    ******************</para>
		/// <para> The following functions add events and/or tags to the timeline.  There are helpers to add simple events or tags in a single call.</para>
		/// <para> or you can use StartEvent and CloseEvent to customize what gets added.</para>
		/// <para> Examples of events to add could include:</para>
		/// <para>   * a boss battle</para>
		/// <para>   * a cut scene</para>
		/// <para>   * a large team fight</para>
		/// <para>   * picking up a new weapon or ammunition</para>
		/// <para>   * scoring a goal</para>
		/// <para> Adding an event and a time range with the simple API:</para>
		/// <para> don't show filter</para>
		/// <para> start now</para>
		/// <para>   SteamTimeline()-&gt;AddSimpleTimelineEvent( "steam_heart", Localize( "#user healed" ), Localize( "#health_amount", 27 ), 15, 0, 0, k_ETimelineEventClipPriority_None );</para>
		/// <para> start 10 sec ago</para>
		/// <para>   SteamTimeline()-&gt;AddTaggedTimeRange( Localize( "#player_resting" ), "steam_flag", nullptr, 15, 0, 10 );</para>
		/// <para>   SteamTimeline()-&gt;AddTaggedTimeRange( Localize( "#player_cast_light" ), "steam_starburst", Localize( "#player_spells" ), 10,  -10, 5 );</para>
		/// <para> start now</para>
		/// <para> Adding a marker and time range in one event:</para>
		/// <para>   TimelineEventHandle_t event = SteamTimeline()-&gt;StartEvent(  0 );</para>
		/// <para> start now</para>
		/// <para>   SteamTimeline()-&gt;ShowEventOnTimeline( event, "steam_heart", Localize( "#player_healed" ), Localize( "#player_healed_amount", 27 ), 15 );</para>
		/// <para>   SteamTimeline()-&gt;AddEventTag( event, Localize( "#player_cast_heal" ), "steam_heart", Localize( "#player_, 15, 0, 10 );</para>
		/// <para>   ... // time passes</para>
		/// <para>   SteamTimeline()-&gt;CloseEvent( event );</para>
		/// <para> Parameters used by the event functions:</para>
		/// <para> - ulOpenEvent: An event returned by StartEvent that has not yet had CancelEvent or CloseEvent called on it</para>
		/// <para> - ulEvent: An event that has had CloseEvent called on it, or an event returned from AddSimpleTimelineEvent or AddTaggedTimeRange (which</para>
		/// <para>   are closed automatically.)</para>
		/// <para> - pchIcon: specify the name of the icon uploaded through the Steamworks Partner Site for your title</para>
		/// <para>   or one of the provided icons that start with steam_</para>
		/// <para> - pchTitle &amp; pchDescription: provide a localized string in the language returned by</para>
		/// <para>	 SteamUtils()-&gt;GetSteamUILanguage()</para>
		/// <para> - unIconPriority: specify how important this range is compared to other markers provided by the game.</para>
		/// <para>   Ranges with larger priority values will be displayed more prominently in the UI. This value</para>
		/// <para>   may be between 0 and k_unMaxTimelinePriority.</para>
		/// <para> - flStartOffsetSeconds: The time that this range started relative to now. Negative times</para>
		/// <para>   indicate an event that happened in the past.</para>
		/// <para> - flDurationSeconds: How long the time range should be in seconds. For instantaneous events, this</para>
		/// <para>   should be 0</para>
		/// <para> - ePossibleClip: By setting this parameter to Featured or Standard, the game indicates to Steam that it</para>
		/// <para>   would be appropriate to offer this range as a clip to the user. For instantaneous events, the</para>
		/// <para>   suggested clip will be for a short time before and after the event itself.</para>
		/// <para> - pchTagIcon: specify an icon name that will be used next to the tag name in the UI</para>
		/// <para> - pchTagName: The localized name of the tag to show in the UI.</para>
		/// <para> - pchTagGroup: The localized name of the tag group to show in the UI. If this is not specified, users will not be able to filter by this tag</para>
		/// <para> - unTagPriority: specify how important this tag is compared to other tags provided by the game.</para>
		/// <para> Returns:</para>
		/// <para>   A TimelineEventHandle_t that can be used to make subsequent calls to refer to the timeline event. This event handle is invalid</para>
		/// <para>   after the game exits.</para>
		/// <para> quick helpers that add to the timeline in one call</para>
		/// <para>******************    Timeline Events    ****************** The following functions add events and/or tags to the timeline.有帮助者可以在单个呼叫中添加简单的事件或标签。或者，您可以使用StartEvent和CloseEvent自定义添加的内容。 要添加的事件的示例可能包括： *老板战 *削减场景 *大型团队战斗 *捡起新武器或弹药 *打进目标 使用简单API添加事件和时间范围：不要显示filter start now now steamtimeline（） - > addsimpletimelineEvent（“ steam_heart”，localize（“ #user healed”），intimize（“ #health_amount”，27），15，0，0，0，0，0，k_etimelineEventClippripriortility_none_none_none）;开始10 sec aofo aofe steamtimeline（） - > addtaggedTimerange（interize（“ #player_resting”），“ steam_flag”，nullptr，15，0，10）;SteamTimeline（） - > addTaggedTimerange（localize（“ #player_cast_light”），“ steam_starburst”，interize（“ #player_spells”），10，-10，5）; 现在开始在一个事件中添加标记和时间范围：TimeleNeventHandle_t event = SteamTimeline（） - > startEvent（0）;现在开始SteamTimeline（） - > ShowEventOntimeline（事件，“ Steam_heart”，局部（“ #player_healed”），本地化（“ #player_healed_amount”，27），15），15）;SteamTimeline（） - > addeventTag（事件，本地化（“ #player_cast_heal”），“ steam_heart”，interize（“ #player_，15，0，10）; ... //时间通过steamtimeline（） - > cloteTimeline（） - > clotevent（） 事件功能使用的参数： -ulopenevent：尚未取消或关闭的事件返回的事件，呼吁它 -  ulevent：一个已接近访问的事件，或者从addSimimellineEvent或addSimimellineEvent或addAgggedTimerange中返回的事件，该事件是由ICON的名称：iCON的名称。Steam_- PCHTITLE＆PCHDESCRIPTION：提供STEAMUTILS（） - > getSteamuilanguage（）的语言中的本地化字符串 -  UniconPriority：指定该范围与游戏提供的其他标记的重要性。优先级值较大的范围将在UI中更突出。该值可能在0和k_unmaxtimelinepriority之间。-  flstartoffsetseconds：此范围相对于现在开始的时间。负时间表示过去发生的事件。-  fldurationseconds：时间范围应在几秒钟内进行多长时间。对于瞬时事件，应为0 -epossibleclip：通过将此参数设置为特征或标准，游戏表明Steam表明将此范围作为剪辑提供给用户是合适的。对于瞬时事件，建议的剪辑将在活动本身之前和之后短时间内进行。-pchtagicon：指定一个图标名称，该名称将在UI -PCHTAGNAME中的标签名称旁边使用：在UI中显示的标签的本地名称。-pchtaggroup：在UI中显示的标签组的本地名称。如果未指定这一点，则用户将无法通过此标签过滤 -  UntagPriority：指定与游戏提供的其他标签相比，该标签的重要性。返回：可以用来进行随后的呼叫来参考时间表事件的时间表。游戏退出后，此事件手柄无效。一个通话中添加到时间表中的快速帮助者</para>
		/// </summary>
		public static TimelineEventHandle_t AddInstantaneousTimelineEvent(string pchTitle, string pchDescription, string pchIcon, uint unIconPriority, float flStartOffsetSeconds = 0.0f, ETimelineEventClipPriority ePossibleClip = ETimelineEventClipPriority.k_ETimelineEventClipPriority_None) {
			InteropHelp.TestIfAvailableClient();
			using (var pchTitle2 = new InteropHelp.UTF8StringHandle(pchTitle))
			using (var pchDescription2 = new InteropHelp.UTF8StringHandle(pchDescription))
			using (var pchIcon2 = new InteropHelp.UTF8StringHandle(pchIcon)) {
				return (TimelineEventHandle_t)NativeMethods.ISteamTimeline_AddInstantaneousTimelineEvent(CSteamAPIContext.GetSteamTimeline(), pchTitle2, pchDescription2, pchIcon2, unIconPriority, flStartOffsetSeconds, ePossibleClip);
			}
		}

		public static TimelineEventHandle_t AddRangeTimelineEvent(string pchTitle, string pchDescription, string pchIcon, uint unIconPriority, float flStartOffsetSeconds = 0.0f, float flDuration = 0.0f, ETimelineEventClipPriority ePossibleClip = ETimelineEventClipPriority.k_ETimelineEventClipPriority_None) {
			InteropHelp.TestIfAvailableClient();
			using (var pchTitle2 = new InteropHelp.UTF8StringHandle(pchTitle))
			using (var pchDescription2 = new InteropHelp.UTF8StringHandle(pchDescription))
			using (var pchIcon2 = new InteropHelp.UTF8StringHandle(pchIcon)) {
				return (TimelineEventHandle_t)NativeMethods.ISteamTimeline_AddRangeTimelineEvent(CSteamAPIContext.GetSteamTimeline(), pchTitle2, pchDescription2, pchIcon2, unIconPriority, flStartOffsetSeconds, flDuration, ePossibleClip);
			}
		}

		/// <summary>
		/// <para> Starts a timeline event at a the current time, plus an offset in seconds. This event must be ended with EndRangeTimelineEvent.</para>
		/// <para> Any timeline events that have not been ended when the game exits will be discarded.</para>
		/// <para>在当前时间启动时间轴事件，再加上几秒钟的偏移。该事件必须以EndrangetimelineEvent结束。当游戏退出时尚未结束的任何时间轴事件都将被丢弃。</para>
		/// </summary>
		public static TimelineEventHandle_t StartRangeTimelineEvent(string pchTitle, string pchDescription, string pchIcon, uint unPriority, float flStartOffsetSeconds, ETimelineEventClipPriority ePossibleClip) {
			InteropHelp.TestIfAvailableClient();
			using (var pchTitle2 = new InteropHelp.UTF8StringHandle(pchTitle))
			using (var pchDescription2 = new InteropHelp.UTF8StringHandle(pchDescription))
			using (var pchIcon2 = new InteropHelp.UTF8StringHandle(pchIcon)) {
				return (TimelineEventHandle_t)NativeMethods.ISteamTimeline_StartRangeTimelineEvent(CSteamAPIContext.GetSteamTimeline(), pchTitle2, pchDescription2, pchIcon2, unPriority, flStartOffsetSeconds, ePossibleClip);
			}
		}

		/// <summary>
		/// <para> Updates fields on a range timeline event that was started with StartRangeTimelineEvent, and which has not been ended.</para>
		/// <para>更新范围时间表事件的字段是从StarTrangetimelineEvent开始的，但尚未结束。</para>
		/// </summary>
		public static void UpdateRangeTimelineEvent(TimelineEventHandle_t ulEvent, string pchTitle, string pchDescription, string pchIcon, uint unPriority, ETimelineEventClipPriority ePossibleClip) {
			InteropHelp.TestIfAvailableClient();
			using (var pchTitle2 = new InteropHelp.UTF8StringHandle(pchTitle))
			using (var pchDescription2 = new InteropHelp.UTF8StringHandle(pchDescription))
			using (var pchIcon2 = new InteropHelp.UTF8StringHandle(pchIcon)) {
				NativeMethods.ISteamTimeline_UpdateRangeTimelineEvent(CSteamAPIContext.GetSteamTimeline(), ulEvent, pchTitle2, pchDescription2, pchIcon2, unPriority, ePossibleClip);
			}
		}

		/// <summary>
		/// <para> Ends a range timeline event and shows it in the UI.</para>
		/// <para>结束范围时间表事件，并在UI中显示。</para>
		/// </summary>
		public static void EndRangeTimelineEvent(TimelineEventHandle_t ulEvent, float flEndOffsetSeconds) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamTimeline_EndRangeTimelineEvent(CSteamAPIContext.GetSteamTimeline(), ulEvent, flEndOffsetSeconds);
		}

		/// <summary>
		/// <para> delete the event from the timeline. This can be called on a timeline event from AddInstantaneousTimelineEvent,</para>
		/// <para> AddRangeTimelineEvent, or StartRangeTimelineEvent/EndRangeTimelineEvent. The timeline event handle must be from the</para>
		/// <para> current game process.</para>
		/// <para>从时间表中删除活动。可以在AddInstantaneoustimelineEvent，AddRangetimelineEvent或StarTrangetimelineEvent/EndrangetimelineEvent的时间轴事件中调用。时间轴事件句柄必须来自当前的游戏过程。</para>
		/// </summary>
		public static void RemoveTimelineEvent(TimelineEventHandle_t ulEvent) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamTimeline_RemoveTimelineEvent(CSteamAPIContext.GetSteamTimeline(), ulEvent);
		}

		/// <summary>
		/// <para> add a tag to whatever time range is represented by the event</para>
		/// <para>将标签添加到事件代表的任何时间范围内</para>
		/// </summary>
		public static SteamAPICall_t DoesEventRecordingExist(TimelineEventHandle_t ulEvent) {
			InteropHelp.TestIfAvailableClient();
			return (SteamAPICall_t)NativeMethods.ISteamTimeline_DoesEventRecordingExist(CSteamAPIContext.GetSteamTimeline(), ulEvent);
		}

		/// <summary>
		/// <para>******************    Game Phases    ******************</para>
		/// <para> Game phases allow the user to navigate their background recordings and clips. Exactly what a game phase means will vary game to game, but</para>
		/// <para> the game phase should be a section of gameplay that is usually between 10 minutes and a few hours in length, and should be the</para>
		/// <para> main way a user would think to divide up the game. These are presented to the user in a UI that shows the date the game was played,</para>
		/// <para> with one row per game slice. Game phases should be used to mark sections of gameplay that the user might be interested in watching.</para>
		/// <para>	Examples could include:</para>
		/// <para>		* A single match in a multiplayer PvP game</para>
		/// <para>		* A chapter of a story-based singleplayer game</para>
		/// <para>		* A single run in a roguelike</para>
		/// <para> Game phases are started with StartGamePhase, and while a phase is still happening, they can have tags and attributes added to them.</para>
		/// <para> Phase attributes represent generic text fields that can be updated throughout the duration of the phase. They are meant</para>
		/// <para> to be used for phase metadata that is not part of a well defined set of options. For example, a KDA attribute that starts</para>
		/// <para> with the value "0/0/0" and updates as the phase progresses, or something like a played-entered character name. Attributes</para>
		/// <para> can be set as many times as the game likes with SetGamePhaseAttribute, and only the last value will be shown to the user.</para>
		/// <para> Phase tags represent data with a well defined set of options, which could be data such as match resolution, hero played,</para>
		/// <para> game mode, etc. Tags can have an icon in addition to a text name. Multiple tags within the same group may be added per phase</para>
		/// <para> and all will be remembered. For example, AddGamePhaseTag may be called multiple times for a "Bosses Defeated" group, with</para>
		/// <para> different names and icons for each boss defeated during the phase, all of which will be shown to the user.</para>
		/// <para> The phase will continue until the game exits, until the game calls EndGamePhase, or until the game calls</para>
		/// <para> StartGamePhase to start a new phase.</para>
		/// <para> The game phase functions take these parameters:</para>
		/// <para> - pchTagIcon: The name of a game provided timeline icon or builtin "steam_" icon.</para>
		/// <para> - pchPhaseID: A game-provided persistent ID for a game phase. This could be a the match ID in a multiplayer game, a chapter name in a</para>
		/// <para>   single player game, the ID of a character, etc.</para>
		/// <para> - pchTagName: The localized name of the tag in the language returned by SteamUtils()-&gt;GetSteamUILanguage().</para>
		/// <para> - pchTagGroup: The localized name of the tag group.</para>
		/// <para> - pchAttributeValue: The localized name of the attribute.</para>
		/// <para> - pchAttributeGroup: The localized name of the attribute group.</para>
		/// <para> - unPriority: Used to order tags and attributes in the UI displayed to the user, with higher priority values leading</para>
		/// <para>   to more prominent positioning. In contexts where there is limited space, lower priority items may be hidden.</para>
		/// <para>******************游戏阶段******************游戏阶段允许用户浏览其背景录音和剪辑。游戏阶段的含义将变化为游戏，但是游戏阶段应该是通常长度在10分钟到几个小时之间的游戏阶段，并且应该是用户认为将游戏划分的主要方式。这些是在UI中呈现给用户的，该UI显示了游戏的日期，每个游戏切片一排。游戏阶段应用于标记用户可能有兴趣观看的游戏节目。 示例可能包括： *多人游戏PVP游戏中的一场匹配 * *基于故事的单人游戏的章节 * 游戏阶段是从StartGamephase开始的，尽管阶段仍在发生，但它们可以将标签和属性添加到它们中。 相位属性表示可以在整个阶段的过程中更新的通用文本字段。它们本来可以用于相位元数据，这不是定义明确的选项集的一部分。例如，一个以“ 0/0/0”值开始的KDA属性，并随着相位的进展而更新，或类似播放的字符名称。可以将属性设置为与游戏相喜欢的setGamePloseatTribute多次，并且只有最后一个值将显示给用户。 相位标签表示具有定义明确的选项的数据，其中可能是诸如匹配分辨率，英雄播放，游戏模式等的数据。标签除文本名称外还具有图标。每个阶段可以添加同一组中的多个标签，所有这些标签将被记住。例如，对于“击败的老板”组，AddGamephaseTag可以多次调用，每个老板在阶段被击败的每个老板的不同名称和图标，所有这些都将显示给用户。 该阶段将持续到游戏退出为止，直到游戏呼叫最终场合，或直到游戏调用StartGamephase开始新阶段。 游戏阶段函数采用以下参数： -  pchtagicon：游戏的名称提供了时间表图标或内置“ Steam_”图标。-PCHPHASEID：游戏阶段的游戏持续ID。这可能是多人游戏中的匹配ID，单个玩家游戏中的章节名称，字符的ID等。-pchtagname：标签的本地名称在Steamutils（）返回的语言（） - > getSteamuilanguage（）中。-pchtaggroup：标签组的本地名称。-pChattributeValue：属性的本地名称。-pChattributeGroup：属性组的本地名称。- 非优先级：用于显示给用户的UI中的标签和属性，其优先级值更高，导致更为突出的定位。在空间有限的上下文中，可以隐藏较低的优先级项目。</para>
		/// </summary>
		public static void StartGamePhase() {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamTimeline_StartGamePhase(CSteamAPIContext.GetSteamTimeline());
		}

		public static void EndGamePhase() {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamTimeline_EndGamePhase(CSteamAPIContext.GetSteamTimeline());
		}

		/// <summary>
		/// <para> Games can set a phase ID so they can refer back to a phase in OpenOverlayToPhase</para>
		/// <para>游戏可以设置一个阶段ID，以便他们可以将其引用到Openoverlaytophase中的阶段</para>
		/// </summary>
		public static void SetGamePhaseID(string pchPhaseID) {
			InteropHelp.TestIfAvailableClient();
			using (var pchPhaseID2 = new InteropHelp.UTF8StringHandle(pchPhaseID)) {
				NativeMethods.ISteamTimeline_SetGamePhaseID(CSteamAPIContext.GetSteamTimeline(), pchPhaseID2);
			}
		}

		public static SteamAPICall_t DoesGamePhaseRecordingExist(string pchPhaseID) {
			InteropHelp.TestIfAvailableClient();
			using (var pchPhaseID2 = new InteropHelp.UTF8StringHandle(pchPhaseID)) {
				return (SteamAPICall_t)NativeMethods.ISteamTimeline_DoesGamePhaseRecordingExist(CSteamAPIContext.GetSteamTimeline(), pchPhaseID2);
			}
		}

		/// <summary>
		/// <para> Add a tag that applies to the entire phase</para>
		/// <para>添加适用于整个阶段的标签</para>
		/// </summary>
		public static void AddGamePhaseTag(string pchTagName, string pchTagIcon, string pchTagGroup, uint unPriority) {
			InteropHelp.TestIfAvailableClient();
			using (var pchTagName2 = new InteropHelp.UTF8StringHandle(pchTagName))
			using (var pchTagIcon2 = new InteropHelp.UTF8StringHandle(pchTagIcon))
			using (var pchTagGroup2 = new InteropHelp.UTF8StringHandle(pchTagGroup)) {
				NativeMethods.ISteamTimeline_AddGamePhaseTag(CSteamAPIContext.GetSteamTimeline(), pchTagName2, pchTagIcon2, pchTagGroup2, unPriority);
			}
		}

		/// <summary>
		/// <para> Add a text attribute that applies to the entire phase</para>
		/// <para>添加适用于整个阶段的文本属性</para>
		/// </summary>
		public static void SetGamePhaseAttribute(string pchAttributeGroup, string pchAttributeValue, uint unPriority) {
			InteropHelp.TestIfAvailableClient();
			using (var pchAttributeGroup2 = new InteropHelp.UTF8StringHandle(pchAttributeGroup))
			using (var pchAttributeValue2 = new InteropHelp.UTF8StringHandle(pchAttributeValue)) {
				NativeMethods.ISteamTimeline_SetGamePhaseAttribute(CSteamAPIContext.GetSteamTimeline(), pchAttributeGroup2, pchAttributeValue2, unPriority);
			}
		}

		/// <summary>
		/// <para>******************    Opening the overlay    ******************</para>
		/// <para> Opens the Steam overlay to a game phase.</para>
		/// <para> Parameters:</para>
		/// <para> - pchPhaseID: The ID of a phase that was previously provided by the game in SetGamePhaseID.</para>
		/// <para>******************    Opening the overlay    ****************** Opens the Steam overlay to a game phase. 参数：-pchphaseid：setGamePhaseID中游戏以前提供的阶段的ID。</para>
		/// </summary>
		public static void OpenOverlayToGamePhase(string pchPhaseID) {
			InteropHelp.TestIfAvailableClient();
			using (var pchPhaseID2 = new InteropHelp.UTF8StringHandle(pchPhaseID)) {
				NativeMethods.ISteamTimeline_OpenOverlayToGamePhase(CSteamAPIContext.GetSteamTimeline(), pchPhaseID2);
			}
		}

		/// <summary>
		/// <para> Opens the Steam overlay to a timeline event.</para>
		/// <para> Parameters:</para>
		/// <para> - ulEventID: The ID of a timeline event returned by StartEvent or AddSimpleTimelineEvent</para>
		/// <para>将Steam覆盖层打开到时间轴事件。 参数： -  uleventid：startEvent返回的时间轴事件的ID或addSimpletimelineEvent</para>
		/// </summary>
		public static void OpenOverlayToTimelineEvent(TimelineEventHandle_t ulEvent) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamTimeline_OpenOverlayToTimelineEvent(CSteamAPIContext.GetSteamTimeline(), ulEvent);
		}
	}
}

#endif // !DISABLESTEAMWORKS
