// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
	#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	public static class SteamHTTP {
		/// <summary>
		/// <para> Initializes a new HTTP request, returning a handle to use in further operations on it.  Requires</para>
		/// <para> the method (GET or POST) and the absolute URL for the request.  Both http and https are supported,</para>
		/// <para> so this string must start with http:// or https:// and should look like http://store.steampowered.com/app/250/</para>
		/// <para> or such.</para>
		/// <para>初始化一个新的 HTTP 请求，返回一个句柄用于后续操作。需要指定方法（GET 或 POST）和请求的绝对 URL。同时支持 http 和 https，因此该字符串必须以 http:// 或 https:// 开头，并像 http://store.steampowered.com/app/250/ 这样的形式。</para>
		/// </summary>
		public static HTTPRequestHandle CreateHTTPRequest(EHTTPMethod eHTTPRequestMethod, string pchAbsoluteURL) {
			InteropHelp.TestIfAvailableClient();
			using (var pchAbsoluteURL2 = new InteropHelp.UTF8StringHandle(pchAbsoluteURL)) {
				return (HTTPRequestHandle)NativeMethods.ISteamHTTP_CreateHTTPRequest(CSteamAPIContext.GetSteamHTTP(), eHTTPRequestMethod, pchAbsoluteURL2);
			}
		}

		/// <summary>
		/// <para> Set a context value for the request, which will be returned in the HTTPRequestCompleted_t callback after</para>
		/// <para> sending the request.  This is just so the caller can easily keep track of which callbacks go with which request data.</para>
		/// <para>设置请求上下文值，将在发送请求后在 HTTPRequestCompleted_t 回调函数中返回。这只是为了让调用者能够轻松地跟踪哪些回调与哪些请求数据相关。</para>
		/// </summary>
		public static bool SetHTTPRequestContextValue(HTTPRequestHandle hRequest, ulong ulContextValue) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTTP_SetHTTPRequestContextValue(CSteamAPIContext.GetSteamHTTP(), hRequest, ulContextValue);
		}

		/// <summary>
		/// <para> Set a timeout in seconds for the HTTP request, must be called prior to sending the request.  Default</para>
		/// <para> timeout is 60 seconds if you don't call this.  Returns false if the handle is invalid, or the request</para>
		/// <para> has already been sent.</para>
		/// <para>设置 HTTP 请求的超时时间（秒），必须在发送请求之前调用。默认超时时间为 60 秒，如果未调用此方法，则使用默认值。如果句柄无效或请求已发送，则返回 false。</para>
		/// </summary>
		public static bool SetHTTPRequestNetworkActivityTimeout(HTTPRequestHandle hRequest, uint unTimeoutSeconds) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTTP_SetHTTPRequestNetworkActivityTimeout(CSteamAPIContext.GetSteamHTTP(), hRequest, unTimeoutSeconds);
		}

		/// <summary>
		/// <para> Set a request header value for the request, must be called prior to sending the request.  Will</para>
		/// <para> return false if the handle is invalid or the request is already sent.</para>
		/// <para>设置请求头值，在发送请求之前必须执行。如果句柄无效或请求已发送，则返回false。</para>
		/// </summary>
		public static bool SetHTTPRequestHeaderValue(HTTPRequestHandle hRequest, string pchHeaderName, string pchHeaderValue) {
			InteropHelp.TestIfAvailableClient();
			using (var pchHeaderName2 = new InteropHelp.UTF8StringHandle(pchHeaderName))
			using (var pchHeaderValue2 = new InteropHelp.UTF8StringHandle(pchHeaderValue)) {
				return NativeMethods.ISteamHTTP_SetHTTPRequestHeaderValue(CSteamAPIContext.GetSteamHTTP(), hRequest, pchHeaderName2, pchHeaderValue2);
			}
		}

		/// <summary>
		/// <para> Set a GET or POST parameter value on the request, which is set will depend on the EHTTPMethod specified</para>
		/// <para> when creating the request.  Must be called prior to sending the request.  Will return false if the</para>
		/// <para> handle is invalid or the request is already sent.</para>
		/// <para>设置请求的 GET 或 POST 参数值，该值将取决于在创建请求时指定的 EHTTPMethod。必须在发送请求之前调用。如果句柄无效或请求已发送，则返回 false。</para>
		/// </summary>
		public static bool SetHTTPRequestGetOrPostParameter(HTTPRequestHandle hRequest, string pchParamName, string pchParamValue) {
			InteropHelp.TestIfAvailableClient();
			using (var pchParamName2 = new InteropHelp.UTF8StringHandle(pchParamName))
			using (var pchParamValue2 = new InteropHelp.UTF8StringHandle(pchParamValue)) {
				return NativeMethods.ISteamHTTP_SetHTTPRequestGetOrPostParameter(CSteamAPIContext.GetSteamHTTP(), hRequest, pchParamName2, pchParamValue2);
			}
		}

		/// <summary>
		/// <para> Sends the HTTP request, will return false on a bad handle, otherwise use SteamCallHandle to wait on</para>
		/// <para> asynchronous response via callback.</para>
		/// <para> Note: If the user is in offline mode in Steam, then this will add a only-if-cached cache-control</para>
		/// <para> header and only do a local cache lookup rather than sending any actual remote request.</para>
		/// <para>发送 HTTP 请求，在处理失败时返回 false，否则使用 SteamCallHandle 等待异步响应通过回调。</para>
		/// <para>注意：如果用户处于Steam离线模式，则会添加仅缓存-如果缓存则仅执行缓存控制标头，并且不会发送任何实际的远程请求，而是仅执行本地缓存查找。</para>
		/// </summary>
		public static bool SendHTTPRequest(HTTPRequestHandle hRequest, out SteamAPICall_t pCallHandle) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTTP_SendHTTPRequest(CSteamAPIContext.GetSteamHTTP(), hRequest, out pCallHandle);
		}

		/// <summary>
		/// <para> Sends the HTTP request, will return false on a bad handle, otherwise use SteamCallHandle to wait on</para>
		/// <para> asynchronous response via callback for completion, and listen for HTTPRequestHeadersReceived_t and</para>
		/// <para> HTTPRequestDataReceived_t callbacks while streaming.</para>
		/// <para>发送 HTTP 请求，在出现无效句柄时返回 false，否则使用 SteamCallHandle 等待异步响应通过回调完成，并在流式传输期间监听 HTTPRequestHeadersReceived_t 和 HTTPRequestDataReceived_t 回调。</para>
		/// </summary>
		public static bool SendHTTPRequestAndStreamResponse(HTTPRequestHandle hRequest, out SteamAPICall_t pCallHandle) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTTP_SendHTTPRequestAndStreamResponse(CSteamAPIContext.GetSteamHTTP(), hRequest, out pCallHandle);
		}

		/// <summary>
		/// <para> Defers a request you have sent, the actual HTTP client code may have many requests queued, and this will move</para>
		/// <para> the specified request to the tail of the queue.  Returns false on invalid handle, or if the request is not yet sent.</para>
		/// <para>延迟发送你已发送的请求，实际的 HTTP 客户端代码可能存在许多请求排队，这会将指定请求移动到队列的末尾。在无效句柄或请求尚未发送时返回 false。</para>
		/// </summary>
		public static bool DeferHTTPRequest(HTTPRequestHandle hRequest) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTTP_DeferHTTPRequest(CSteamAPIContext.GetSteamHTTP(), hRequest);
		}

		/// <summary>
		/// <para> Prioritizes a request you have sent, the actual HTTP client code may have many requests queued, and this will move</para>
		/// <para> the specified request to the head of the queue.  Returns false on invalid handle, or if the request is not yet sent.</para>
		/// <para>优先处理你发送的请求，实际的HTTP客户端可能存在多个请求排队，这会将指定的请求移动到队列的头部。如果处理无效，或请求尚未发送，则返回false。</para>
		/// </summary>
		public static bool PrioritizeHTTPRequest(HTTPRequestHandle hRequest) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTTP_PrioritizeHTTPRequest(CSteamAPIContext.GetSteamHTTP(), hRequest);
		}

		/// <summary>
		/// <para> Checks if a response header is present in a HTTP response given a handle from HTTPRequestCompleted_t, also</para>
		/// <para> returns the size of the header value if present so the caller and allocate a correctly sized buffer for</para>
		/// <para> GetHTTPResponseHeaderValue.</para>
		/// <para>检查 HTTP 响应中是否存在响应头，同时如果存在则返回头的值大小，以便调用者为 GetHTTPResponseHeaderValue 函数正确地分配缓冲区。</para>
		/// </summary>
		public static bool GetHTTPResponseHeaderSize(HTTPRequestHandle hRequest, string pchHeaderName, out uint unResponseHeaderSize) {
			InteropHelp.TestIfAvailableClient();
			using (var pchHeaderName2 = new InteropHelp.UTF8StringHandle(pchHeaderName)) {
				return NativeMethods.ISteamHTTP_GetHTTPResponseHeaderSize(CSteamAPIContext.GetSteamHTTP(), hRequest, pchHeaderName2, out unResponseHeaderSize);
			}
		}

		/// <summary>
		/// <para> Gets header values from a HTTP response given a handle from HTTPRequestCompleted_t, will return false if the</para>
		/// <para> header is not present or if your buffer is too small to contain it's value.  You should first call</para>
		/// <para> BGetHTTPResponseHeaderSize to check for the presence of the header and to find out the size buffer needed.</para>
		/// <para>从 HTTP 响应获取标头值，给定一个 HTTPRequestCompleted_t 的句柄。如果标头不存在或您的缓冲区太小无法容纳其值，则返回 false。您应该首先调用 BGetHTTPResponseHeaderSize 以检查标头的存在情况，并确定所需的缓冲区大小。</para>
		/// </summary>
		public static bool GetHTTPResponseHeaderValue(HTTPRequestHandle hRequest, string pchHeaderName, byte[] pHeaderValueBuffer, uint unBufferSize) {
			InteropHelp.TestIfAvailableClient();
			using (var pchHeaderName2 = new InteropHelp.UTF8StringHandle(pchHeaderName)) {
				return NativeMethods.ISteamHTTP_GetHTTPResponseHeaderValue(CSteamAPIContext.GetSteamHTTP(), hRequest, pchHeaderName2, pHeaderValueBuffer, unBufferSize);
			}
		}

		/// <summary>
		/// <para> Gets the size of the body data from a HTTP response given a handle from HTTPRequestCompleted_t, will return false if the</para>
		/// <para> handle is invalid.</para>
		/// <para>从 HTTP 响应中获取 body 数据的大小，给定一个 HTTPRequestCompleted_t 的句柄，如果句柄无效则返回 false。</para>
		/// </summary>
		public static bool GetHTTPResponseBodySize(HTTPRequestHandle hRequest, out uint unBodySize) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTTP_GetHTTPResponseBodySize(CSteamAPIContext.GetSteamHTTP(), hRequest, out unBodySize);
		}

		/// <summary>
		/// <para> Gets the body data from a HTTP response given a handle from HTTPRequestCompleted_t, will return false if the</para>
		/// <para> handle is invalid or is to a streaming response, or if the provided buffer is not the correct size.  Use BGetHTTPResponseBodySize first to find out</para>
		/// <para> the correct buffer size to use.</para>
		/// <para>从 HTTP 响应中获取主体数据，给定一个 HTTPRequestCompleted_t 的句柄。如果句柄无效或指向流式响应，或者提供的缓冲区大小不正确，则返回 false。首先使用 BGetHTTPResponseBodySize 确定正确的缓冲区大小。</para>
		/// </summary>
		public static bool GetHTTPResponseBodyData(HTTPRequestHandle hRequest, byte[] pBodyDataBuffer, uint unBufferSize) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTTP_GetHTTPResponseBodyData(CSteamAPIContext.GetSteamHTTP(), hRequest, pBodyDataBuffer, unBufferSize);
		}

		/// <summary>
		/// <para> Gets the body data from a streaming HTTP response given a handle from HTTPRequestDataReceived_t. Will return false if the</para>
		/// <para> handle is invalid or is to a non-streaming response (meaning it wasn't sent with SendHTTPRequestAndStreamResponse), or if the buffer size and offset</para>
		/// <para> do not match the size and offset sent in HTTPRequestDataReceived_t.</para>
		/// <para>从流式 HTTP 响应中获取主体数据，给定一个 HTTPRequestDataReceived_t 处理句柄。如果句柄无效或指向非流式响应（即未通过 SendHTTPRequestAndStreamResponse 发送），或者缓冲区大小和偏移量与 HTTPRequestDataReceived_t 中发送的大小和偏移量不匹配，则返回 false。</para>
		/// </summary>
		public static bool GetHTTPStreamingResponseBodyData(HTTPRequestHandle hRequest, uint cOffset, byte[] pBodyDataBuffer, uint unBufferSize) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTTP_GetHTTPStreamingResponseBodyData(CSteamAPIContext.GetSteamHTTP(), hRequest, cOffset, pBodyDataBuffer, unBufferSize);
		}

		/// <summary>
		/// <para> Releases an HTTP response handle, should always be called to free resources after receiving a HTTPRequestCompleted_t</para>
		/// <para> callback and finishing using the response.</para>
		/// <para>释放一个 HTTP 响应句柄，始终应该在收到 HTTPRequestCompleted_t 回调并完成使用响应后调用，以释放资源。</para>
		/// </summary>
		public static bool ReleaseHTTPRequest(HTTPRequestHandle hRequest) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTTP_ReleaseHTTPRequest(CSteamAPIContext.GetSteamHTTP(), hRequest);
		}

		/// <summary>
		/// <para> Gets progress on downloading the body for the request.  This will be zero unless a response header has already been</para>
		/// <para> received which included a content-length field.  For responses that contain no content-length it will report</para>
		/// <para> zero for the duration of the request as the size is unknown until the connection closes.</para>
		/// <para>获取请求体下载进度。除非已收到包含 content-length 字段的响应头，否则此值将为零。对于不包含 content-length 的响应，该值将在请求期间为零，因为大小在连接关闭时才已知。</para>
		/// </summary>
		public static bool GetHTTPDownloadProgressPct(HTTPRequestHandle hRequest, out float pflPercentOut) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTTP_GetHTTPDownloadProgressPct(CSteamAPIContext.GetSteamHTTP(), hRequest, out pflPercentOut);
		}

		/// <summary>
		/// <para> Sets the body for an HTTP Post request.  Will fail and return false on a GET request, and will fail if POST params</para>
		/// <para> have already been set for the request.  Setting this raw body makes it the only contents for the post, the pchContentType</para>
		/// <para> parameter will set the content-type header for the request so the server may know how to interpret the body.</para>
		/// <para>设置HTTP Post请求的body。如果请求是GET请求，将会失败并返回false，如果POST参数已经设置，也会失败。设置raw body会使其成为Post请求的唯一内容，pchContentType参数将设置请求的content-type header，以便服务器能够理解body。</para>
		/// </summary>
		public static bool SetHTTPRequestRawPostBody(HTTPRequestHandle hRequest, string pchContentType, byte[] pubBody, uint unBodyLen) {
			InteropHelp.TestIfAvailableClient();
			using (var pchContentType2 = new InteropHelp.UTF8StringHandle(pchContentType)) {
				return NativeMethods.ISteamHTTP_SetHTTPRequestRawPostBody(CSteamAPIContext.GetSteamHTTP(), hRequest, pchContentType2, pubBody, unBodyLen);
			}
		}

		/// <summary>
		/// <para> Creates a cookie container handle which you must later free with ReleaseCookieContainer().  If bAllowResponsesToModify=true</para>
		/// <para> than any response to your requests using this cookie container may add new cookies which may be transmitted with</para>
		/// <para> future requests.  If bAllowResponsesToModify=false than only cookies you explicitly set will be sent.  This API is just for</para>
		/// <para> during process lifetime, after steam restarts no cookies are persisted and you have no way to access the cookie container across</para>
		/// <para> repeat executions of your process.</para>
		/// <para>创建一个 Cookie 容器句柄，您必须稍后使用 ReleaseCookieContainer() 释放它。如果 bAllowResponsesToModify=true，则使用此 Cookie 容器的任何对请求的响应都可能添加新的 Cookie，这些 Cookie 将在后续请求中传输。如果 bAllowResponsesToModify=false，则仅发送您明确设置的 Cookie。此 API 仅用于进程生命周期内，Steam 重启后不会持久化 Cookie，您无法在重复执行进程时访问 Cookie 容器。</para>
		/// </summary>
		public static HTTPCookieContainerHandle CreateCookieContainer(bool bAllowResponsesToModify) {
			InteropHelp.TestIfAvailableClient();
			return (HTTPCookieContainerHandle)NativeMethods.ISteamHTTP_CreateCookieContainer(CSteamAPIContext.GetSteamHTTP(), bAllowResponsesToModify);
		}

		/// <summary>
		/// <para> Release a cookie container you are finished using, freeing it's memory</para>
		/// <para>发布一个饼干容器，你已完成使用，释放它的内存。</para>
		/// </summary>
		public static bool ReleaseCookieContainer(HTTPCookieContainerHandle hCookieContainer) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTTP_ReleaseCookieContainer(CSteamAPIContext.GetSteamHTTP(), hCookieContainer);
		}

		/// <summary>
		/// <para> Adds a cookie to the specified cookie container that will be used with future requests.</para>
		/// <para>添加一个到指定cookie容器的cookie，该cookie将用于未来的请求。</para>
		/// </summary>
		public static bool SetCookie(HTTPCookieContainerHandle hCookieContainer, string pchHost, string pchUrl, string pchCookie) {
			InteropHelp.TestIfAvailableClient();
			using (var pchHost2 = new InteropHelp.UTF8StringHandle(pchHost))
			using (var pchUrl2 = new InteropHelp.UTF8StringHandle(pchUrl))
			using (var pchCookie2 = new InteropHelp.UTF8StringHandle(pchCookie)) {
				return NativeMethods.ISteamHTTP_SetCookie(CSteamAPIContext.GetSteamHTTP(), hCookieContainer, pchHost2, pchUrl2, pchCookie2);
			}
		}

		/// <summary>
		/// <para> Set the cookie container to use for a HTTP request</para>
		/// <para>设置用于 HTTP 请求的 Cookie 容器。</para>
		/// </summary>
		public static bool SetHTTPRequestCookieContainer(HTTPRequestHandle hRequest, HTTPCookieContainerHandle hCookieContainer) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTTP_SetHTTPRequestCookieContainer(CSteamAPIContext.GetSteamHTTP(), hRequest, hCookieContainer);
		}

		/// <summary>
		/// <para> Set the extra user agent info for a request, this doesn't clobber the normal user agent, it just adds the extra info on the end</para>
		/// <para>设置请求的额外用户代理信息，这不会覆盖正常的用户代理，它只是在请求末尾添加额外信息。</para>
		/// </summary>
		public static bool SetHTTPRequestUserAgentInfo(HTTPRequestHandle hRequest, string pchUserAgentInfo) {
			InteropHelp.TestIfAvailableClient();
			using (var pchUserAgentInfo2 = new InteropHelp.UTF8StringHandle(pchUserAgentInfo)) {
				return NativeMethods.ISteamHTTP_SetHTTPRequestUserAgentInfo(CSteamAPIContext.GetSteamHTTP(), hRequest, pchUserAgentInfo2);
			}
		}

		/// <summary>
		/// <para> Disable or re-enable verification of SSL/TLS certificates.</para>
		/// <para> By default, certificates are checked for all HTTPS requests.</para>
		/// <para>禁用或重新启用 SSL/TLS 证书验证。 默认情况下，证书将针对所有 HTTPS 请求进行检查。</para>
		/// </summary>
		public static bool SetHTTPRequestRequiresVerifiedCertificate(HTTPRequestHandle hRequest, bool bRequireVerifiedCertificate) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTTP_SetHTTPRequestRequiresVerifiedCertificate(CSteamAPIContext.GetSteamHTTP(), hRequest, bRequireVerifiedCertificate);
		}

		/// <summary>
		/// <para> Set an absolute timeout on the HTTP request, this is just a total time timeout different than the network activity timeout</para>
		/// <para> which can bump everytime we get more data</para>
		/// <para>设置 HTTP 请求的绝对超时时间，这与网络活动超时时间不同，后者会随时增加。</para>
		/// </summary>
		public static bool SetHTTPRequestAbsoluteTimeoutMS(HTTPRequestHandle hRequest, uint unMilliseconds) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTTP_SetHTTPRequestAbsoluteTimeoutMS(CSteamAPIContext.GetSteamHTTP(), hRequest, unMilliseconds);
		}

		/// <summary>
		/// <para> Check if the reason the request failed was because we timed it out (rather than some harder failure)</para>
		/// <para>检查请求失败的原因是否因为超时（而不是更严重的错误）</para>
		/// </summary>
		public static bool GetHTTPRequestWasTimedOut(HTTPRequestHandle hRequest, out bool pbWasTimedOut) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTTP_GetHTTPRequestWasTimedOut(CSteamAPIContext.GetSteamHTTP(), hRequest, out pbWasTimedOut);
		}
	}
}

#endif // !DISABLESTEAMWORKS
