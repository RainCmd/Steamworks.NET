// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
	#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	public static class SteamFriends {
		/// <summary>
		/// <para> returns the local players name - guaranteed to not be NULL.</para>
		/// <para> this is the same name as on the users community profile page</para>
		/// <para> this is stored in UTF-8 format</para>
		/// <para> like all the other interface functions that return a char *, it's important that this pointer is not saved</para>
		/// <para> off; it will eventually be free'd or re-allocated</para>
		/// <para>返回本地玩家名称 - 保证不会无效。这与用户社区配置文件页面上的名称相同，就像返回char *的所有其他接口函数一样，它以utf-8格式存储，这一点很重要，必须没有保存该指针。它最终将是免费的或重新分配的</para>
		/// </summary>
		public static string GetPersonaName() {
			InteropHelp.TestIfAvailableClient();
			return InteropHelp.PtrToStringUTF8(NativeMethods.ISteamFriends_GetPersonaName(CSteamAPIContext.GetSteamFriends()));
		}

		/// <summary>
		/// <para> Sets the player name, stores it on the server and publishes the changes to all friends who are online.</para>
		/// <para> Changes take place locally immediately, and a PersonaStateChange_t is posted, presuming success.</para>
		/// <para> The final results are available through the return value SteamAPICall_t, using SetPersonaNameResponse_t.</para>
		/// <para> If the name change fails to happen on the server, then an additional global PersonaStateChange_t will be posted</para>
		/// <para> to change the name back, in addition to the SetPersonaNameResponse_t callback.</para>
		/// <para>设置播放器名称，将其存储在服务器上，并将更改发布给所有在线朋友。更改会立即在当地进行，并且发布了PersonAtateChange_T，假定成功。 最终结果可通过使用setPersonanameresponse_t的返回值Steamapicall_t获得。 如果名称更改未能在服务器上发生，则除了SETPersonAnameresponse_t callback外，还将发布其他全局PersicastaTechange_T以更改名称。</para>
		/// </summary>
		public static SteamAPICall_t SetPersonaName(string pchPersonaName) {
			InteropHelp.TestIfAvailableClient();
			using (var pchPersonaName2 = new InteropHelp.UTF8StringHandle(pchPersonaName)) {
				return (SteamAPICall_t)NativeMethods.ISteamFriends_SetPersonaName(CSteamAPIContext.GetSteamFriends(), pchPersonaName2);
			}
		}

		/// <summary>
		/// <para> gets the status of the current user</para>
		/// <para>获取当前用户的状态</para>
		/// </summary>
		public static EPersonaState GetPersonaState() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetPersonaState(CSteamAPIContext.GetSteamFriends());
		}

		/// <summary>
		/// <para> friend iteration</para>
		/// <para> takes a set of k_EFriendFlags, and returns the number of users the client knows about who meet that criteria</para>
		/// <para> then GetFriendByIndex() can then be used to return the id's of each of those users</para>
		/// <para>朋友迭代采用一组k_efriendflags，并返回客户端知道的用户数量</para>
		/// </summary>
		public static int GetFriendCount(EFriendFlags iFriendFlags) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetFriendCount(CSteamAPIContext.GetSteamFriends(), iFriendFlags);
		}

		/// <summary>
		/// <para> returns the steamID of a user</para>
		/// <para> iFriend is a index of range [0, GetFriendCount())</para>
		/// <para> iFriendsFlags must be the same value as used in GetFriendCount()</para>
		/// <para> the returned CSteamID can then be used by all the functions below to access details about the user</para>
		/// <para>返回用户ifriend的蒸汽是范围[0，get friendcount（））ifriendsflags的索引，必须与getfriendcount（）返回的csteamid在下面的所有函数中使用返回的csteamid相同，以访问用户的详细信息</para>
		/// </summary>
		public static CSteamID GetFriendByIndex(int iFriend, EFriendFlags iFriendFlags) {
			InteropHelp.TestIfAvailableClient();
			return (CSteamID)NativeMethods.ISteamFriends_GetFriendByIndex(CSteamAPIContext.GetSteamFriends(), iFriend, iFriendFlags);
		}

		/// <summary>
		/// <para> returns a relationship to a user</para>
		/// <para>返回与用户的关系</para>
		/// </summary>
		public static EFriendRelationship GetFriendRelationship(CSteamID steamIDFriend) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetFriendRelationship(CSteamAPIContext.GetSteamFriends(), steamIDFriend);
		}

		/// <summary>
		/// <para> returns the current status of the specified user</para>
		/// <para> this will only be known by the local user if steamIDFriend is in their friends list; on the same game server; in a chat room or lobby; or in a small group with the local user</para>
		/// <para>返回指定用户的当前状态，只有在Steamidfriend在他们的朋友列表中，本地用户才会知道。在同一游戏服务器上；在聊天室或大厅中；或与本地用户的小组中</para>
		/// </summary>
		public static EPersonaState GetFriendPersonaState(CSteamID steamIDFriend) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetFriendPersonaState(CSteamAPIContext.GetSteamFriends(), steamIDFriend);
		}

		/// <summary>
		/// <para> returns the name another user - guaranteed to not be NULL.</para>
		/// <para> same rules as GetFriendPersonaState() apply as to whether or not the user knowns the name of the other user</para>
		/// <para> note that on first joining a lobby, chat room or game server the local user will not known the name of the other users automatically; that information will arrive asyncronously</para>
		/// <para>返回另一个用户的名称 - 保证不为null。与getfriendpersonastate（）相同的规则适用于用户是否知道其他用户的名称，请注意，首先加入大厅，聊天室或游戏服务器，本地用户将不知道其他用户的名称；该信息将异类到达</para>
		/// </summary>
		public static string GetFriendPersonaName(CSteamID steamIDFriend) {
			InteropHelp.TestIfAvailableClient();
			return InteropHelp.PtrToStringUTF8(NativeMethods.ISteamFriends_GetFriendPersonaName(CSteamAPIContext.GetSteamFriends(), steamIDFriend));
		}

		/// <summary>
		/// <para> returns true if the friend is actually in a game, and fills in pFriendGameInfo with an extra details</para>
		/// <para>如果朋友实际上在游戏中，则返回true，并填写PrightGameInfo的额外详细信息</para>
		/// </summary>
		public static bool GetFriendGamePlayed(CSteamID steamIDFriend, out FriendGameInfo_t pFriendGameInfo) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetFriendGamePlayed(CSteamAPIContext.GetSteamFriends(), steamIDFriend, out pFriendGameInfo);
		}

		/// <summary>
		/// <para> accesses old friends names - returns an empty string when their are no more items in the history</para>
		/// <para>访问老朋友的名字 - 历史记录中不再有项目时返回一个空字符串</para>
		/// </summary>
		public static string GetFriendPersonaNameHistory(CSteamID steamIDFriend, int iPersonaName) {
			InteropHelp.TestIfAvailableClient();
			return InteropHelp.PtrToStringUTF8(NativeMethods.ISteamFriends_GetFriendPersonaNameHistory(CSteamAPIContext.GetSteamFriends(), steamIDFriend, iPersonaName));
		}

		/// <summary>
		/// <para> friends steam level</para>
		/// <para>朋友蒸汽水平</para>
		/// </summary>
		public static int GetFriendSteamLevel(CSteamID steamIDFriend) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetFriendSteamLevel(CSteamAPIContext.GetSteamFriends(), steamIDFriend);
		}

		/// <summary>
		/// <para> Returns nickname the current user has set for the specified player. Returns NULL if the no nickname has been set for that player.</para>
		/// <para> DEPRECATED: GetPersonaName follows the Steam nickname preferences, so apps shouldn't need to care about nicknames explicitly.</para>
		/// <para>返回昵称当前用户为指定播放器设置了设置。如果为该播放器设置了无昵称，则返回null。弃用：GetPersonAname遵循Steam Nickname首选项，因此应用不需要明确关心昵称。</para>
		/// </summary>
		public static string GetPlayerNickname(CSteamID steamIDPlayer) {
			InteropHelp.TestIfAvailableClient();
			return InteropHelp.PtrToStringUTF8(NativeMethods.ISteamFriends_GetPlayerNickname(CSteamAPIContext.GetSteamFriends(), steamIDPlayer));
		}

		/// <summary>
		/// <para> friend grouping (tag) apis</para>
		/// <para> returns the number of friends groups</para>
		/// <para>朋友分组（标签）API返回朋友组的数量</para>
		/// </summary>
		public static int GetFriendsGroupCount() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetFriendsGroupCount(CSteamAPIContext.GetSteamFriends());
		}

		/// <summary>
		/// <para> returns the friends group ID for the given index (invalid indices return k_FriendsGroupID_Invalid)</para>
		/// <para>返回给定索引的朋友组ID（无效索引返回k_friendsgroupid_invalid）</para>
		/// </summary>
		public static FriendsGroupID_t GetFriendsGroupIDByIndex(int iFG) {
			InteropHelp.TestIfAvailableClient();
			return (FriendsGroupID_t)NativeMethods.ISteamFriends_GetFriendsGroupIDByIndex(CSteamAPIContext.GetSteamFriends(), iFG);
		}

		/// <summary>
		/// <para> returns the name for the given friends group (NULL in the case of invalid friends group IDs)</para>
		/// <para>返回给定的朋友组的名称（如果无效的朋友组ID为null）</para>
		/// </summary>
		public static string GetFriendsGroupName(FriendsGroupID_t friendsGroupID) {
			InteropHelp.TestIfAvailableClient();
			return InteropHelp.PtrToStringUTF8(NativeMethods.ISteamFriends_GetFriendsGroupName(CSteamAPIContext.GetSteamFriends(), friendsGroupID));
		}

		/// <summary>
		/// <para> returns the number of members in a given friends group</para>
		/// <para>返回给定的朋友组中的成员人数</para>
		/// </summary>
		public static int GetFriendsGroupMembersCount(FriendsGroupID_t friendsGroupID) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetFriendsGroupMembersCount(CSteamAPIContext.GetSteamFriends(), friendsGroupID);
		}

		/// <summary>
		/// <para> gets up to nMembersCount members of the given friends group, if fewer exist than requested those positions' SteamIDs will be invalid</para>
		/// <para>获得给定朋友组的NMembersCount成员，如果存在的少于这些位置的蒸汽蒸腾措施无效</para>
		/// </summary>
		public static void GetFriendsGroupMembersList(FriendsGroupID_t friendsGroupID, CSteamID[] pOutSteamIDMembers, int nMembersCount) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamFriends_GetFriendsGroupMembersList(CSteamAPIContext.GetSteamFriends(), friendsGroupID, pOutSteamIDMembers, nMembersCount);
		}

		/// <summary>
		/// <para> returns true if the specified user meets any of the criteria specified in iFriendFlags</para>
		/// <para> iFriendFlags can be the union (binary or, |) of one or more k_EFriendFlags values</para>
		/// <para>如果指定的用户符合Ifriendflags Ifriendflags中指定的任何标准，则返回true。</para>
		/// </summary>
		public static bool HasFriend(CSteamID steamIDFriend, EFriendFlags iFriendFlags) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_HasFriend(CSteamAPIContext.GetSteamFriends(), steamIDFriend, iFriendFlags);
		}

		/// <summary>
		/// <para> clan (group) iteration and access functions</para>
		/// <para>氏族（组）迭代和访问功能</para>
		/// </summary>
		public static int GetClanCount() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetClanCount(CSteamAPIContext.GetSteamFriends());
		}

		public static CSteamID GetClanByIndex(int iClan) {
			InteropHelp.TestIfAvailableClient();
			return (CSteamID)NativeMethods.ISteamFriends_GetClanByIndex(CSteamAPIContext.GetSteamFriends(), iClan);
		}

		public static string GetClanName(CSteamID steamIDClan) {
			InteropHelp.TestIfAvailableClient();
			return InteropHelp.PtrToStringUTF8(NativeMethods.ISteamFriends_GetClanName(CSteamAPIContext.GetSteamFriends(), steamIDClan));
		}

		public static string GetClanTag(CSteamID steamIDClan) {
			InteropHelp.TestIfAvailableClient();
			return InteropHelp.PtrToStringUTF8(NativeMethods.ISteamFriends_GetClanTag(CSteamAPIContext.GetSteamFriends(), steamIDClan));
		}

		/// <summary>
		/// <para> returns the most recent information we have about what's happening in a clan</para>
		/// <para>返回有关氏族中发生的事情的最新信息</para>
		/// </summary>
		public static bool GetClanActivityCounts(CSteamID steamIDClan, out int pnOnline, out int pnInGame, out int pnChatting) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetClanActivityCounts(CSteamAPIContext.GetSteamFriends(), steamIDClan, out pnOnline, out pnInGame, out pnChatting);
		}

		/// <summary>
		/// <para> for clans a user is a member of, they will have reasonably up-to-date information, but for others you'll have to download the info to have the latest</para>
		/// <para>对于用户是氏族的成员，他们将拥有合理的最新信息，但是对于其他人，您必须下载信息才能拥有最新的信息</para>
		/// </summary>
		public static SteamAPICall_t DownloadClanActivityCounts(CSteamID[] psteamIDClans, int cClansToRequest) {
			InteropHelp.TestIfAvailableClient();
			return (SteamAPICall_t)NativeMethods.ISteamFriends_DownloadClanActivityCounts(CSteamAPIContext.GetSteamFriends(), psteamIDClans, cClansToRequest);
		}

		/// <summary>
		/// <para> iterators for getting users in a chat room, lobby, game server or clan</para>
		/// <para> note that large clans that cannot be iterated by the local user</para>
		/// <para> note that the current user must be in a lobby to retrieve CSteamIDs of other users in that lobby</para>
		/// <para> steamIDSource can be the steamID of a group, game server, lobby or chat room</para>
		/// <para>迭代器可以在聊天室，大厅，游戏服务器或氏族中吸引用户，请注意，本地用户无法迭代的大型氏族注意，当前用户必须在大厅中检索其他用户的CSteamids，因为大厅STEAMIDSOURCE可以是小组，游戏服务器，大厅或聊天室或聊天室或聊天室或聊天室的蒸汽</para>
		/// </summary>
		public static int GetFriendCountFromSource(CSteamID steamIDSource) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetFriendCountFromSource(CSteamAPIContext.GetSteamFriends(), steamIDSource);
		}

		public static CSteamID GetFriendFromSourceByIndex(CSteamID steamIDSource, int iFriend) {
			InteropHelp.TestIfAvailableClient();
			return (CSteamID)NativeMethods.ISteamFriends_GetFriendFromSourceByIndex(CSteamAPIContext.GetSteamFriends(), steamIDSource, iFriend);
		}

		/// <summary>
		/// <para> returns true if the local user can see that steamIDUser is a member or in steamIDSource</para>
		/// <para>如果本地用户可以看到Steamiduser是成员或SteamidSource，则返回true</para>
		/// </summary>
		public static bool IsUserInSource(CSteamID steamIDUser, CSteamID steamIDSource) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_IsUserInSource(CSteamAPIContext.GetSteamFriends(), steamIDUser, steamIDSource);
		}

		/// <summary>
		/// <para> User is in a game pressing the talk button (will suppress the microphone for all voice comms from the Steam friends UI)</para>
		/// <para>用户正在按下聊天按钮的游戏（将抑制Steam Friends UI的所有语音通讯的麦克风）</para>
		/// </summary>
		public static void SetInGameVoiceSpeaking(CSteamID steamIDUser, bool bSpeaking) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamFriends_SetInGameVoiceSpeaking(CSteamAPIContext.GetSteamFriends(), steamIDUser, bSpeaking);
		}

		/// <summary>
		/// <para> activates the game overlay, with an optional dialog to open</para>
		/// <para> valid options include "Friends", "Community", "Players", "Settings", "OfficialGameGroup", "Stats", "Achievements",</para>
		/// <para> "chatroomgroup/nnnn"</para>
		/// <para>激活游戏覆盖层，使用可选的对话框打开有效选项，包括“朋友”，“社区”，“播放器”，“设置”，“官方游戏”，“统计”，“成就”，“ chatroomgroup/nnnn”</para>
		/// </summary>
		public static void ActivateGameOverlay(string pchDialog) {
			InteropHelp.TestIfAvailableClient();
			using (var pchDialog2 = new InteropHelp.UTF8StringHandle(pchDialog)) {
				NativeMethods.ISteamFriends_ActivateGameOverlay(CSteamAPIContext.GetSteamFriends(), pchDialog2);
			}
		}

		/// <summary>
		/// <para> activates game overlay to a specific place</para>
		/// <para> valid options are</para>
		/// <para>		"steamid" - opens the overlay web browser to the specified user or groups profile</para>
		/// <para>		"chat" - opens a chat window to the specified user, or joins the group chat</para>
		/// <para>		"jointrade" - opens a window to a Steam Trading session that was started with the ISteamEconomy/StartTrade Web API</para>
		/// <para>		"stats" - opens the overlay web browser to the specified user's stats</para>
		/// <para>		"achievements" - opens the overlay web browser to the specified user's achievements</para>
		/// <para>		"friendadd" - opens the overlay in minimal mode prompting the user to add the target user as a friend</para>
		/// <para>		"friendremove" - opens the overlay in minimal mode prompting the user to remove the target friend</para>
		/// <para>		"friendrequestaccept" - opens the overlay in minimal mode prompting the user to accept an incoming friend invite</para>
		/// <para>		"friendrequestignore" - opens the overlay in minimal mode prompting the user to ignore an incoming friend invite</para>
		/// <para>activates game overlay to a specific place valid options are "steamid" - opens the overlay web browser to the specified user or groups profile "chat" - opens a chat window to the specified user, or joins the group chat "jointrade" - opens a window to a Steam Trading session that was started with the ISteamEconomy/StartTrade Web API "stats" - opens the overlay web browser to the specified user's stats "achievements" -将覆盖网络浏览器打开到指定用户的成就“ friendadd”  - 以最小的模式打开覆盖层，促使用户将目标用户添加为朋友“ friendremove”  - 以最小的模式打开覆盖层，以最小的模式打开覆盖层，从在最小模式下，提示用户忽略传入的朋友邀请</para>
		/// </summary>
		public static void ActivateGameOverlayToUser(string pchDialog, CSteamID steamID) {
			InteropHelp.TestIfAvailableClient();
			using (var pchDialog2 = new InteropHelp.UTF8StringHandle(pchDialog)) {
				NativeMethods.ISteamFriends_ActivateGameOverlayToUser(CSteamAPIContext.GetSteamFriends(), pchDialog2, steamID);
			}
		}

		/// <summary>
		/// <para> activates game overlay web browser directly to the specified URL</para>
		/// <para> full address with protocol type is required, e.g. http://www.steamgames.com/</para>
		/// <para>激活游戏覆盖Web浏览器直接到指定的URL完整地址，其中需要协议类型，例如http://www.steamgames.com/</para>
		/// </summary>
		public static void ActivateGameOverlayToWebPage(string pchURL, EActivateGameOverlayToWebPageMode eMode = EActivateGameOverlayToWebPageMode.k_EActivateGameOverlayToWebPageMode_Default) {
			InteropHelp.TestIfAvailableClient();
			using (var pchURL2 = new InteropHelp.UTF8StringHandle(pchURL)) {
				NativeMethods.ISteamFriends_ActivateGameOverlayToWebPage(CSteamAPIContext.GetSteamFriends(), pchURL2, eMode);
			}
		}

		/// <summary>
		/// <para> activates game overlay to store page for app</para>
		/// <para>激活游戏覆盖到应用程序的商店页面</para>
		/// </summary>
		public static void ActivateGameOverlayToStore(AppId_t nAppID, EOverlayToStoreFlag eFlag) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamFriends_ActivateGameOverlayToStore(CSteamAPIContext.GetSteamFriends(), nAppID, eFlag);
		}

		/// <summary>
		/// <para> Mark a target user as 'played with'. This is a client-side only feature that requires that the calling user is</para>
		/// <para> in game</para>
		/// <para>将目标用户标记为“使用”。这是一个唯一需要调用用户在游戏中的客户端功能</para>
		/// </summary>
		public static void SetPlayedWith(CSteamID steamIDUserPlayedWith) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamFriends_SetPlayedWith(CSteamAPIContext.GetSteamFriends(), steamIDUserPlayedWith);
		}

		/// <summary>
		/// <para> activates game overlay to open the invite dialog. Invitations will be sent for the provided lobby.</para>
		/// <para>激活游戏覆盖以打开邀请对话框。将向提供的大厅发送邀请。</para>
		/// </summary>
		public static void ActivateGameOverlayInviteDialog(CSteamID steamIDLobby) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamFriends_ActivateGameOverlayInviteDialog(CSteamAPIContext.GetSteamFriends(), steamIDLobby);
		}

		/// <summary>
		/// <para> gets the small (32x32) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set</para>
		/// <para>获取当前用户的小（32x32）头像，这是在iclientutils :: getimagergba（）中使用的句柄，或者如果没有设置为0</para>
		/// </summary>
		public static int GetSmallFriendAvatar(CSteamID steamIDFriend) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetSmallFriendAvatar(CSteamAPIContext.GetSteamFriends(), steamIDFriend);
		}

		/// <summary>
		/// <para> gets the medium (64x64) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set</para>
		/// <para>获取当前用户的介质（64x64）头像，这是在iclientutils :: getimagergba（）中使用的句柄，或者如果没有设置为0</para>
		/// </summary>
		public static int GetMediumFriendAvatar(CSteamID steamIDFriend) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetMediumFriendAvatar(CSteamAPIContext.GetSteamFriends(), steamIDFriend);
		}

		/// <summary>
		/// <para> gets the large (184x184) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set</para>
		/// <para> returns -1 if this image has yet to be loaded, in this case wait for a AvatarImageLoaded_t callback and then call this again</para>
		/// <para>获取当前用户的大型（184x184）头像，这是在iclientutils :: getimagergba（）中使用的句柄，或者如果没有设置尚未返回-1，则如果尚未返回-1，则在这种情况下，请等待Avatarimageloaded_t呼叫再次调用，然后再次调用此次数</para>
		/// </summary>
		public static int GetLargeFriendAvatar(CSteamID steamIDFriend) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetLargeFriendAvatar(CSteamAPIContext.GetSteamFriends(), steamIDFriend);
		}

		/// <summary>
		/// <para> requests information about a user - persona name &amp; avatar</para>
		/// <para> if bRequireNameOnly is set, then the avatar of a user isn't downloaded</para>
		/// <para> - it's a lot slower to download avatars and churns the local cache, so if you don't need avatars, don't request them</para>
		/// <para> if returns true, it means that data is being requested, and a PersonaStateChanged_t callback will be posted when it's retrieved</para>
		/// <para> if returns false, it means that we already have all the details about that user, and functions can be called immediately</para>
		/// <para>requests information about a user - persona name & avatar if bRequireNameOnly is set, then the avatar of a user isn't downloaded - it's a lot slower to download avatars and churns the local cache, so if you don't need avatars, don't request them if returns true, it means that data is being requested, and a PersonaStateChanged_t callback will be posted when it's retrieved if returns false, it means that we already have all the details about该用户和功能可以立即调用</para>
		/// </summary>
		public static bool RequestUserInformation(CSteamID steamIDUser, bool bRequireNameOnly) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_RequestUserInformation(CSteamAPIContext.GetSteamFriends(), steamIDUser, bRequireNameOnly);
		}

		/// <summary>
		/// <para> requests information about a clan officer list</para>
		/// <para> when complete, data is returned in ClanOfficerListResponse_t call result</para>
		/// <para> this makes available the calls below</para>
		/// <para> you can only ask about clans that a user is a member of</para>
		/// <para> note that this won't download avatars automatically; if you get an officer,</para>
		/// <para> and no avatar image is available, call RequestUserInformation( steamID, false ) to download the avatar</para>
		/// <para>请求有关CLAN军官列表的信息，完成后，在Clanofficerlistersponse_t调用结果中返回数据，这使您只能询问以下呼叫，您只能询问用户是用户是注释的成员，即这不会自动下载Avatars；如果您有一名官员，并且没有可用的头像图像，请致电RequestUserInformation（Steamid，false）下载AVATAR</para>
		/// </summary>
		public static SteamAPICall_t RequestClanOfficerList(CSteamID steamIDClan) {
			InteropHelp.TestIfAvailableClient();
			return (SteamAPICall_t)NativeMethods.ISteamFriends_RequestClanOfficerList(CSteamAPIContext.GetSteamFriends(), steamIDClan);
		}

		/// <summary>
		/// <para> iteration of clan officers - can only be done when a RequestClanOfficerList() call has completed</para>
		/// <para> returns the steamID of the clan owner</para>
		/// <para>氏族官员的迭代 - 只有在requestClanofficerList（）呼叫完成回报的回报时才能完成氏族所有者的蒸汽</para>
		/// </summary>
		public static CSteamID GetClanOwner(CSteamID steamIDClan) {
			InteropHelp.TestIfAvailableClient();
			return (CSteamID)NativeMethods.ISteamFriends_GetClanOwner(CSteamAPIContext.GetSteamFriends(), steamIDClan);
		}

		/// <summary>
		/// <para> returns the number of officers in a clan (including the owner)</para>
		/// <para>返回氏族中的军官人数（包括所有者）</para>
		/// </summary>
		public static int GetClanOfficerCount(CSteamID steamIDClan) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetClanOfficerCount(CSteamAPIContext.GetSteamFriends(), steamIDClan);
		}

		/// <summary>
		/// <para> returns the steamID of a clan officer, by index, of range [0,GetClanOfficerCount)</para>
		/// <para>通过索引返回一个氏族军官的蒸汽[0，getClanofficerCount）</para>
		/// </summary>
		public static CSteamID GetClanOfficerByIndex(CSteamID steamIDClan, int iOfficer) {
			InteropHelp.TestIfAvailableClient();
			return (CSteamID)NativeMethods.ISteamFriends_GetClanOfficerByIndex(CSteamAPIContext.GetSteamFriends(), steamIDClan, iOfficer);
		}

		/// <summary>
		/// <para> if current user is chat restricted, he can't send or receive any text/voice chat messages.</para>
		/// <para> the user can't see custom avatars. But the user can be online and send/recv game invites.</para>
		/// <para> a chat restricted user can't add friends or join any groups.</para>
		/// <para>如果当前用户受到限制，他将无法发送或接收任何文本/语音聊天消息。用户看不到自定义化身。但是用户可以在线并发送/RECV游戏邀请。聊天限制的用户无法添加朋友或加入任何组。</para>
		/// </summary>
		public static uint GetUserRestrictions() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetUserRestrictions(CSteamAPIContext.GetSteamFriends());
		}

		/// <summary>
		/// <para> Rich Presence data is automatically shared between friends who are in the same game</para>
		/// <para> Each user has a set of Key/Value pairs</para>
		/// <para> Note the following limits: k_cchMaxRichPresenceKeys, k_cchMaxRichPresenceKeyLength, k_cchMaxRichPresenceValueLength</para>
		/// <para> There are five magic keys:</para>
		/// <para>		"status"  - a UTF-8 string that will show up in the 'view game info' dialog in the Steam friends list</para>
		/// <para>		"connect" - a UTF-8 string that contains the command-line for how a friend can connect to a game</para>
		/// <para>		"steam_display"				- Names a rich presence localization token that will be displayed in the viewing user's selected language</para>
		/// <para>									  in the Steam client UI. For more info: https://partner.steamgames.com/doc/api/ISteamFriends#richpresencelocalization</para>
		/// <para>		"steam_player_group"		- When set, indicates to the Steam client that the player is a member of a particular group. Players in the same group</para>
		/// <para>									  may be organized together in various places in the Steam UI.</para>
		/// <para>		"steam_player_group_size"	- When set, indicates the total number of players in the steam_player_group. The Steam client may use this number to</para>
		/// <para>									  display additional information about a group when all of the members are not part of a user's friends list.</para>
		/// <para> GetFriendRichPresence() returns an empty string "" if no value is set</para>
		/// <para> SetRichPresence() to a NULL or an empty string deletes the key</para>
		/// <para> You can iterate the current set of keys for a friend with GetFriendRichPresenceKeyCount()</para>
		/// <para> and GetFriendRichPresenceKeyByIndex() (typically only used for debugging)</para>
		/// <para>在同一游戏中，每个用户都有一组密钥/值对的朋友之间会自动共享丰富的存在数据，请注意以下限制：K_CCHMAXRICHPRESECEYSECEYS，K_CCHMAXRICHPRESECENECEKEYLENGTH，K_CCHMAXRICHPRESENCEVALUELEGTHUTF-8字符串包含有关朋友如何连接到游戏“ Steam_display”的命令行 - 命名将在Steam Client UI中查看用户选择的语言中显示的丰富存在定位令牌。有关更多信息：https：//partner.steamgames.com/doc/api/isteamfriends#richpresencelocalizatization“ steam_player_group”  - 设置时，向Steam客户端指示播放器是特定组的成员。同一组的玩家可以在Steam UI的各个地方一起组织。“ Steam_player_group_size”  - 设置时，指示Steam_player_group中的播放器总数。当所有成员都不是用户朋友列表的一部分时，Steam客户端可以使用此数字显示有关组的其他信息。getFriendrichPresence（）返回一个空字符串“”如果没有值设置为setRichPresence（）为null或一个空字符串删除键，您可以使用GetFriendrichPresenceKeykount（）和GetFriendfriendRichRichPreSenceKeyKeyKeyByIndex（）（通常用于debugugging）（通常用于debugging）的朋友为朋友迭代当前的键。</para>
		/// </summary>
		public static bool SetRichPresence(string pchKey, string pchValue) {
			InteropHelp.TestIfAvailableClient();
			using (var pchKey2 = new InteropHelp.UTF8StringHandle(pchKey))
			using (var pchValue2 = new InteropHelp.UTF8StringHandle(pchValue)) {
				return NativeMethods.ISteamFriends_SetRichPresence(CSteamAPIContext.GetSteamFriends(), pchKey2, pchValue2);
			}
		}

		public static void ClearRichPresence() {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamFriends_ClearRichPresence(CSteamAPIContext.GetSteamFriends());
		}

		public static string GetFriendRichPresence(CSteamID steamIDFriend, string pchKey) {
			InteropHelp.TestIfAvailableClient();
			using (var pchKey2 = new InteropHelp.UTF8StringHandle(pchKey)) {
				return InteropHelp.PtrToStringUTF8(NativeMethods.ISteamFriends_GetFriendRichPresence(CSteamAPIContext.GetSteamFriends(), steamIDFriend, pchKey2));
			}
		}

		public static int GetFriendRichPresenceKeyCount(CSteamID steamIDFriend) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetFriendRichPresenceKeyCount(CSteamAPIContext.GetSteamFriends(), steamIDFriend);
		}

		public static string GetFriendRichPresenceKeyByIndex(CSteamID steamIDFriend, int iKey) {
			InteropHelp.TestIfAvailableClient();
			return InteropHelp.PtrToStringUTF8(NativeMethods.ISteamFriends_GetFriendRichPresenceKeyByIndex(CSteamAPIContext.GetSteamFriends(), steamIDFriend, iKey));
		}

		/// <summary>
		/// <para> Requests rich presence for a specific user.</para>
		/// <para>请求特定用户的丰富存在。</para>
		/// </summary>
		public static void RequestFriendRichPresence(CSteamID steamIDFriend) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamFriends_RequestFriendRichPresence(CSteamAPIContext.GetSteamFriends(), steamIDFriend);
		}

		/// <summary>
		/// <para> Rich invite support.</para>
		/// <para> If the target accepts the invite, a GameRichPresenceJoinRequested_t callback is posted containing the connect string.</para>
		/// <para> (Or you can configure your game so that it is passed on the command line instead.  This is a deprecated path; ask us if you really need this.)</para>
		/// <para>丰富的邀请支持。如果目标接受邀请，则张贴包含连接字符串的gamerichPresenceJoinrequested_t回调。（或者您可以配置您的游戏，以便将其传递在命令行上。这是一条弃用的路径；问我们是否真的需要这个。）</para>
		/// </summary>
		public static bool InviteUserToGame(CSteamID steamIDFriend, string pchConnectString) {
			InteropHelp.TestIfAvailableClient();
			using (var pchConnectString2 = new InteropHelp.UTF8StringHandle(pchConnectString)) {
				return NativeMethods.ISteamFriends_InviteUserToGame(CSteamAPIContext.GetSteamFriends(), steamIDFriend, pchConnectString2);
			}
		}

		/// <summary>
		/// <para> recently-played-with friends iteration</para>
		/// <para> this iterates the entire list of users recently played with, across games</para>
		/// <para> GetFriendCoplayTime() returns as a unix time</para>
		/// <para>最近播放的朋友迭代迭代了最近播放的整个用户列表，跨越游戏getfriendcoplaytime（）返回作为UNIX时间</para>
		/// </summary>
		public static int GetCoplayFriendCount() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetCoplayFriendCount(CSteamAPIContext.GetSteamFriends());
		}

		public static CSteamID GetCoplayFriend(int iCoplayFriend) {
			InteropHelp.TestIfAvailableClient();
			return (CSteamID)NativeMethods.ISteamFriends_GetCoplayFriend(CSteamAPIContext.GetSteamFriends(), iCoplayFriend);
		}

		public static int GetFriendCoplayTime(CSteamID steamIDFriend) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetFriendCoplayTime(CSteamAPIContext.GetSteamFriends(), steamIDFriend);
		}

		public static AppId_t GetFriendCoplayGame(CSteamID steamIDFriend) {
			InteropHelp.TestIfAvailableClient();
			return (AppId_t)NativeMethods.ISteamFriends_GetFriendCoplayGame(CSteamAPIContext.GetSteamFriends(), steamIDFriend);
		}

		/// <summary>
		/// <para> chat interface for games</para>
		/// <para> this allows in-game access to group (clan) chats from in the game</para>
		/// <para> the behavior is somewhat sophisticated, because the user may or may not be already in the group chat from outside the game or in the overlay</para>
		/// <para> use ActivateGameOverlayToUser( "chat", steamIDClan ) to open the in-game overlay version of the chat</para>
		/// <para>游戏的聊天界面允许游戏中的游戏访问（氏族）聊天中的行为有些复杂，因为用户可能已经或可能不在游戏外部的组聊天中或在覆盖层中使用ActivAgeMameOverlaytouser（chat，SteamidClan）打开聊天聊天版本的聊天版本</para>
		/// </summary>
		public static SteamAPICall_t JoinClanChatRoom(CSteamID steamIDClan) {
			InteropHelp.TestIfAvailableClient();
			return (SteamAPICall_t)NativeMethods.ISteamFriends_JoinClanChatRoom(CSteamAPIContext.GetSteamFriends(), steamIDClan);
		}

		public static bool LeaveClanChatRoom(CSteamID steamIDClan) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_LeaveClanChatRoom(CSteamAPIContext.GetSteamFriends(), steamIDClan);
		}

		public static int GetClanChatMemberCount(CSteamID steamIDClan) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetClanChatMemberCount(CSteamAPIContext.GetSteamFriends(), steamIDClan);
		}

		public static CSteamID GetChatMemberByIndex(CSteamID steamIDClan, int iUser) {
			InteropHelp.TestIfAvailableClient();
			return (CSteamID)NativeMethods.ISteamFriends_GetChatMemberByIndex(CSteamAPIContext.GetSteamFriends(), steamIDClan, iUser);
		}

		public static bool SendClanChatMessage(CSteamID steamIDClanChat, string pchText) {
			InteropHelp.TestIfAvailableClient();
			using (var pchText2 = new InteropHelp.UTF8StringHandle(pchText)) {
				return NativeMethods.ISteamFriends_SendClanChatMessage(CSteamAPIContext.GetSteamFriends(), steamIDClanChat, pchText2);
			}
		}

		public static int GetClanChatMessage(CSteamID steamIDClanChat, int iMessage, out string prgchText, int cchTextMax, out EChatEntryType peChatEntryType, out CSteamID psteamidChatter) {
			InteropHelp.TestIfAvailableClient();
			IntPtr prgchText2 = Marshal.AllocHGlobal(cchTextMax);
			int ret = NativeMethods.ISteamFriends_GetClanChatMessage(CSteamAPIContext.GetSteamFriends(), steamIDClanChat, iMessage, prgchText2, cchTextMax, out peChatEntryType, out psteamidChatter);
			prgchText = ret != 0 ? InteropHelp.PtrToStringUTF8(prgchText2) : null;
			Marshal.FreeHGlobal(prgchText2);
			return ret;
		}

		public static bool IsClanChatAdmin(CSteamID steamIDClanChat, CSteamID steamIDUser) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_IsClanChatAdmin(CSteamAPIContext.GetSteamFriends(), steamIDClanChat, steamIDUser);
		}

		/// <summary>
		/// <para> interact with the Steam (game overlay / desktop)</para>
		/// <para>与Steam互动（游戏覆盖 /桌面）</para>
		/// </summary>
		public static bool IsClanChatWindowOpenInSteam(CSteamID steamIDClanChat) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_IsClanChatWindowOpenInSteam(CSteamAPIContext.GetSteamFriends(), steamIDClanChat);
		}

		public static bool OpenClanChatWindowInSteam(CSteamID steamIDClanChat) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_OpenClanChatWindowInSteam(CSteamAPIContext.GetSteamFriends(), steamIDClanChat);
		}

		public static bool CloseClanChatWindowInSteam(CSteamID steamIDClanChat) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_CloseClanChatWindowInSteam(CSteamAPIContext.GetSteamFriends(), steamIDClanChat);
		}

		/// <summary>
		/// <para> peer-to-peer chat interception</para>
		/// <para> this is so you can show P2P chats inline in the game</para>
		/// <para>点对点聊天拦截是这样，您可以在游戏中显示P2P聊天</para>
		/// </summary>
		public static bool SetListenForFriendsMessages(bool bInterceptEnabled) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_SetListenForFriendsMessages(CSteamAPIContext.GetSteamFriends(), bInterceptEnabled);
		}

		public static bool ReplyToFriendMessage(CSteamID steamIDFriend, string pchMsgToSend) {
			InteropHelp.TestIfAvailableClient();
			using (var pchMsgToSend2 = new InteropHelp.UTF8StringHandle(pchMsgToSend)) {
				return NativeMethods.ISteamFriends_ReplyToFriendMessage(CSteamAPIContext.GetSteamFriends(), steamIDFriend, pchMsgToSend2);
			}
		}

		public static int GetFriendMessage(CSteamID steamIDFriend, int iMessageID, out string pvData, int cubData, out EChatEntryType peChatEntryType) {
			InteropHelp.TestIfAvailableClient();
			IntPtr pvData2 = Marshal.AllocHGlobal(cubData);
			int ret = NativeMethods.ISteamFriends_GetFriendMessage(CSteamAPIContext.GetSteamFriends(), steamIDFriend, iMessageID, pvData2, cubData, out peChatEntryType);
			pvData = ret != 0 ? InteropHelp.PtrToStringUTF8(pvData2) : null;
			Marshal.FreeHGlobal(pvData2);
			return ret;
		}

		/// <summary>
		/// <para> following apis</para>
		/// <para>跟随API</para>
		/// </summary>
		public static SteamAPICall_t GetFollowerCount(CSteamID steamID) {
			InteropHelp.TestIfAvailableClient();
			return (SteamAPICall_t)NativeMethods.ISteamFriends_GetFollowerCount(CSteamAPIContext.GetSteamFriends(), steamID);
		}

		public static SteamAPICall_t IsFollowing(CSteamID steamID) {
			InteropHelp.TestIfAvailableClient();
			return (SteamAPICall_t)NativeMethods.ISteamFriends_IsFollowing(CSteamAPIContext.GetSteamFriends(), steamID);
		}

		public static SteamAPICall_t EnumerateFollowingList(uint unStartIndex) {
			InteropHelp.TestIfAvailableClient();
			return (SteamAPICall_t)NativeMethods.ISteamFriends_EnumerateFollowingList(CSteamAPIContext.GetSteamFriends(), unStartIndex);
		}

		public static bool IsClanPublic(CSteamID steamIDClan) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_IsClanPublic(CSteamAPIContext.GetSteamFriends(), steamIDClan);
		}

		public static bool IsClanOfficialGameGroup(CSteamID steamIDClan) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_IsClanOfficialGameGroup(CSteamAPIContext.GetSteamFriends(), steamIDClan);
		}

		/// <summary>
		/// <para> Return the number of chats (friends or chat rooms) with unread messages.</para>
		/// <para> A "priority" message is one that would generate some sort of toast or</para>
		/// <para> notification, and depends on user settings.</para>
		/// <para> You can register for UnreadChatMessagesChanged_t callbacks to know when this</para>
		/// <para> has potentially changed.</para>
		/// <para>返回带有未读消息的聊天数（朋友或聊天室）。“优先级”消息是会生成某种敬酒或通知的消息，并取决于用户设置。 您可以注册未ReadChatMessagesChanged_t回调，以了解何时可能更改。</para>
		/// </summary>
		public static int GetNumChatsWithUnreadPriorityMessages() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetNumChatsWithUnreadPriorityMessages(CSteamAPIContext.GetSteamFriends());
		}

		/// <summary>
		/// <para> activates game overlay to open the remote play together invite dialog. Invitations will be sent for remote play together</para>
		/// <para>激活游戏覆盖以打开远程播放邀请对话框。邀请将发送远程播放</para>
		/// </summary>
		public static void ActivateGameOverlayRemotePlayTogetherInviteDialog(CSteamID steamIDLobby) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamFriends_ActivateGameOverlayRemotePlayTogetherInviteDialog(CSteamAPIContext.GetSteamFriends(), steamIDLobby);
		}

		/// <summary>
		/// <para> Call this before calling ActivateGameOverlayToWebPage() to have the Steam Overlay Browser block navigations</para>
		/// <para> to your specified protocol (scheme) uris and instead dispatch a OverlayBrowserProtocolNavigation_t callback to your game.</para>
		/// <para> ActivateGameOverlayToWebPage() must have been called with k_EActivateGameOverlayToWebPageMode_Modal</para>
		/// <para>在调用ActivAgeMayoverLaytowebpage（）之前调用此消息，以将Steam覆盖浏览器块导航到您指定的协议（Schemion）URIS，然后派遣一个OverlayBrowserPrototocolNavigation_t回调到您的游戏。必须使用k_eactivategameoverlayoverlaytowebpagemode_modal来调用ActivateGameOverLaytowebpage（）</para>
		/// </summary>
		public static bool RegisterProtocolInOverlayBrowser(string pchProtocol) {
			InteropHelp.TestIfAvailableClient();
			using (var pchProtocol2 = new InteropHelp.UTF8StringHandle(pchProtocol)) {
				return NativeMethods.ISteamFriends_RegisterProtocolInOverlayBrowser(CSteamAPIContext.GetSteamFriends(), pchProtocol2);
			}
		}

		/// <summary>
		/// <para> Activates the game overlay to open an invite dialog that will send the provided Rich Presence connect string to selected friends</para>
		/// <para>激活游戏覆盖层以打开邀请对话框，该对话框将发送提供的丰富的效果连接到选定的朋友</para>
		/// </summary>
		public static void ActivateGameOverlayInviteDialogConnectString(string pchConnectString) {
			InteropHelp.TestIfAvailableClient();
			using (var pchConnectString2 = new InteropHelp.UTF8StringHandle(pchConnectString)) {
				NativeMethods.ISteamFriends_ActivateGameOverlayInviteDialogConnectString(CSteamAPIContext.GetSteamFriends(), pchConnectString2);
			}
		}

		/// <summary>
		/// <para> Steam Community items equipped by a user on their profile</para>
		/// <para> You can register for EquippedProfileItemsChanged_t to know when a friend has changed their equipped profile items</para>
		/// <para>由用户配备的Steam社区项目您可以在其个人资料上注册为ProfileItemschanged_t注册，以了解朋友何时更改了配备的个人资料项目</para>
		/// </summary>
		public static SteamAPICall_t RequestEquippedProfileItems(CSteamID steamID) {
			InteropHelp.TestIfAvailableClient();
			return (SteamAPICall_t)NativeMethods.ISteamFriends_RequestEquippedProfileItems(CSteamAPIContext.GetSteamFriends(), steamID);
		}

		public static bool BHasEquippedProfileItem(CSteamID steamID, ECommunityProfileItemType itemType) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_BHasEquippedProfileItem(CSteamAPIContext.GetSteamFriends(), steamID, itemType);
		}

		public static string GetProfileItemPropertyString(CSteamID steamID, ECommunityProfileItemType itemType, ECommunityProfileItemProperty prop) {
			InteropHelp.TestIfAvailableClient();
			return InteropHelp.PtrToStringUTF8(NativeMethods.ISteamFriends_GetProfileItemPropertyString(CSteamAPIContext.GetSteamFriends(), steamID, itemType, prop));
		}

		public static uint GetProfileItemPropertyUint(CSteamID steamID, ECommunityProfileItemType itemType, ECommunityProfileItemProperty prop) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamFriends_GetProfileItemPropertyUint(CSteamAPIContext.GetSteamFriends(), steamID, itemType, prop);
		}
	}
}

#endif // !DISABLESTEAMWORKS
