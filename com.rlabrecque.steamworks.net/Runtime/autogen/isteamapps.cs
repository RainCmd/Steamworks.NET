// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
	#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	public static class SteamApps {
		public static bool BIsSubscribed() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsSubscribed(CSteamAPIContext.GetSteamApps());
		}

		public static bool BIsLowViolence() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsLowViolence(CSteamAPIContext.GetSteamApps());
		}

		public static bool BIsCybercafe() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsCybercafe(CSteamAPIContext.GetSteamApps());
		}

		public static bool BIsVACBanned() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsVACBanned(CSteamAPIContext.GetSteamApps());
		}

		public static string GetCurrentGameLanguage() {
			InteropHelp.TestIfAvailableClient();
			return InteropHelp.PtrToStringUTF8(NativeMethods.ISteamApps_GetCurrentGameLanguage(CSteamAPIContext.GetSteamApps()));
		}

		public static string GetAvailableGameLanguages() {
			InteropHelp.TestIfAvailableClient();
			return InteropHelp.PtrToStringUTF8(NativeMethods.ISteamApps_GetAvailableGameLanguages(CSteamAPIContext.GetSteamApps()));
		}

		/// <summary>
		/// <para> only use this member if you need to check ownership of another game related to yours, a demo for example</para>
		/// <para>仅在需要检查与您相关的另一个游戏的所有权时使用此成员，例如</para>
		/// </summary>
		public static bool BIsSubscribedApp(AppId_t appID) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsSubscribedApp(CSteamAPIContext.GetSteamApps(), appID);
		}

		/// <summary>
		/// <para> Takes AppID of DLC and checks if the user owns the DLC &amp; if the DLC is installed</para>
		/// <para>获取DLC的Appid，并检查用户是否拥有DLC，以及是否已安装DLC</para>
		/// </summary>
		public static bool BIsDlcInstalled(AppId_t appID) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsDlcInstalled(CSteamAPIContext.GetSteamApps(), appID);
		}

		/// <summary>
		/// <para> returns the Unix time of the purchase of the app</para>
		/// <para>返回购买应用程序的UNIX时间</para>
		/// </summary>
		public static uint GetEarliestPurchaseUnixTime(AppId_t nAppID) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_GetEarliestPurchaseUnixTime(CSteamAPIContext.GetSteamApps(), nAppID);
		}

		/// <summary>
		/// <para> Checks if the user is subscribed to the current app through a free weekend</para>
		/// <para> This function will return false for users who have a retail or other type of license</para>
		/// <para> Before using, please ask your Valve technical contact how to package and secure your free weekened</para>
		/// <para>检查用户是否通过免费周末订阅了当前应用程序此功能将返回false forse forses forses forses false fors在使用之前的零售或其他类型的许可证，请询问您的阀门技术联系方式</para>
		/// </summary>
		public static bool BIsSubscribedFromFreeWeekend() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsSubscribedFromFreeWeekend(CSteamAPIContext.GetSteamApps());
		}

		/// <summary>
		/// <para> Returns the number of DLC pieces for the running app</para>
		/// <para>返回运行应用程序的DLC件数量</para>
		/// </summary>
		public static int GetDLCCount() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_GetDLCCount(CSteamAPIContext.GetSteamApps());
		}

		/// <summary>
		/// <para> Returns metadata for DLC by index, of range [0, GetDLCCount()]</para>
		/// <para>由index返回DLC的元数据，范围[0，getDlccount（）]</para>
		/// </summary>
		public static bool BGetDLCDataByIndex(int iDLC, out AppId_t pAppID, out bool pbAvailable, out string pchName, int cchNameBufferSize) {
			InteropHelp.TestIfAvailableClient();
			IntPtr pchName2 = Marshal.AllocHGlobal(cchNameBufferSize);
			bool ret = NativeMethods.ISteamApps_BGetDLCDataByIndex(CSteamAPIContext.GetSteamApps(), iDLC, out pAppID, out pbAvailable, pchName2, cchNameBufferSize);
			pchName = ret ? InteropHelp.PtrToStringUTF8(pchName2) : null;
			Marshal.FreeHGlobal(pchName2);
			return ret;
		}

		/// <summary>
		/// <para> Install/Uninstall control for optional DLC</para>
		/// <para>可选DLC的安装/卸载控制</para>
		/// </summary>
		public static void InstallDLC(AppId_t nAppID) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamApps_InstallDLC(CSteamAPIContext.GetSteamApps(), nAppID);
		}

		public static void UninstallDLC(AppId_t nAppID) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamApps_UninstallDLC(CSteamAPIContext.GetSteamApps(), nAppID);
		}

		/// <summary>
		/// <para> Request legacy cd-key for yourself or owned DLC. If you are interested in this</para>
		/// <para> data then make sure you provide us with a list of valid keys to be distributed</para>
		/// <para> to users when they purchase the game, before the game ships.</para>
		/// <para> You'll receive an AppProofOfPurchaseKeyResponse_t callback when</para>
		/// <para> the key is available (which may be immediately).</para>
		/// <para>请您自己或拥有的DLC要求旧版CD键。如果您对这些数据感兴趣，请确保您在购买游戏时购买游戏时向我们提供有效密钥列表，以在他们购买游戏时分配给用户。当键可用时（可能立即），您将收到一个AppProofOffurchAseKeyResponse_t回调。</para>
		/// </summary>
		public static void RequestAppProofOfPurchaseKey(AppId_t nAppID) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamApps_RequestAppProofOfPurchaseKey(CSteamAPIContext.GetSteamApps(), nAppID);
		}

		/// <summary>
		/// <para> returns current beta branch name, 'public' is the default branch</para>
		/// <para>返回当前的beta分支名称，“ public”是默认分支</para>
		/// </summary>
		public static bool GetCurrentBetaName(out string pchName, int cchNameBufferSize) {
			InteropHelp.TestIfAvailableClient();
			IntPtr pchName2 = Marshal.AllocHGlobal(cchNameBufferSize);
			bool ret = NativeMethods.ISteamApps_GetCurrentBetaName(CSteamAPIContext.GetSteamApps(), pchName2, cchNameBufferSize);
			pchName = ret ? InteropHelp.PtrToStringUTF8(pchName2) : null;
			Marshal.FreeHGlobal(pchName2);
			return ret;
		}

		/// <summary>
		/// <para> signal Steam that game files seems corrupt or missing</para>
		/// <para>信号蒸汽表明游戏文件似乎损坏或缺少</para>
		/// </summary>
		public static bool MarkContentCorrupt(bool bMissingFilesOnly) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_MarkContentCorrupt(CSteamAPIContext.GetSteamApps(), bMissingFilesOnly);
		}

		/// <summary>
		/// <para> return installed depots in mount order</para>
		/// <para>返回安装的仓库以安装顺序</para>
		/// </summary>
		public static uint GetInstalledDepots(AppId_t appID, DepotId_t[] pvecDepots, uint cMaxDepots) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_GetInstalledDepots(CSteamAPIContext.GetSteamApps(), appID, pvecDepots, cMaxDepots);
		}

		/// <summary>
		/// <para> returns current app install folder for AppID, returns folder name length</para>
		/// <para>返回当前的应用程序安装文件夹，用于appid，返回文件夹名称长度</para>
		/// </summary>
		public static uint GetAppInstallDir(AppId_t appID, out string pchFolder, uint cchFolderBufferSize) {
			InteropHelp.TestIfAvailableClient();
			IntPtr pchFolder2 = Marshal.AllocHGlobal((int)cchFolderBufferSize);
			uint ret = NativeMethods.ISteamApps_GetAppInstallDir(CSteamAPIContext.GetSteamApps(), appID, pchFolder2, cchFolderBufferSize);
			pchFolder = ret != 0 ? InteropHelp.PtrToStringUTF8(pchFolder2) : null;
			Marshal.FreeHGlobal(pchFolder2);
			return ret;
		}

		/// <summary>
		/// <para> returns true if that app is installed (not necessarily owned)</para>
		/// <para>如果安装该应用程序（不一定拥有），则返回true</para>
		/// </summary>
		public static bool BIsAppInstalled(AppId_t appID) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsAppInstalled(CSteamAPIContext.GetSteamApps(), appID);
		}

		/// <summary>
		/// <para> returns the SteamID of the original owner. If this CSteamID is different from ISteamUser::GetSteamID(),</para>
		/// <para> the user has a temporary license borrowed via Family Sharing</para>
		/// <para>返回原始所有者的蒸汽。如果此csteamid与isteamuser :: getSteamId（）不同，则用户具有通过家庭共享借用的临时许可证</para>
		/// </summary>
		public static CSteamID GetAppOwner() {
			InteropHelp.TestIfAvailableClient();
			return (CSteamID)NativeMethods.ISteamApps_GetAppOwner(CSteamAPIContext.GetSteamApps());
		}

		/// <summary>
		/// <para> Returns the associated launch param if the game is run via steam://run/&lt;appid&gt;//?param1=value1&amp;param2=value2&amp;param3=value3 etc.</para>
		/// <para> Parameter names starting with the character '@' are reserved for internal use and will always return and empty string.</para>
		/// <para> Parameter names starting with an underscore '_' are reserved for steam features -- they can be queried by the game,</para>
		/// <para> but it is advised that you not param names beginning with an underscore for your own features.</para>
		/// <para> Check for new launch parameters on callback NewUrlLaunchParameters_t</para>
		/// <para>返回关联的启动参数，如果游戏是通过Steam运行的：// Run/<Appid> //？param1 = valic1＆param2＆param2＆param2＆param3 = valic3 = value3等。参数名称以字符'@'为内部使用，以供内部使用，并且将始终返回和空字符串。参数名称以强调“ _”开头是为Steam功能保留的 - 可以通过游戏来查询它们，但是建议您不要以底下为您自己的功能开头的参数名称。在回调Newurllaunchparameters_t上查看新的启动参数</para>
		/// </summary>
		public static string GetLaunchQueryParam(string pchKey) {
			InteropHelp.TestIfAvailableClient();
			using (var pchKey2 = new InteropHelp.UTF8StringHandle(pchKey)) {
				return InteropHelp.PtrToStringUTF8(NativeMethods.ISteamApps_GetLaunchQueryParam(CSteamAPIContext.GetSteamApps(), pchKey2));
			}
		}

		/// <summary>
		/// <para> get download progress for optional DLC</para>
		/// <para>获取可选DLC的下载进度</para>
		/// </summary>
		public static bool GetDlcDownloadProgress(AppId_t nAppID, out ulong punBytesDownloaded, out ulong punBytesTotal) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_GetDlcDownloadProgress(CSteamAPIContext.GetSteamApps(), nAppID, out punBytesDownloaded, out punBytesTotal);
		}

		/// <summary>
		/// <para> return the buildid of this app, may change at any time based on backend updates to the game</para>
		/// <para>返回该应用程序的buildid，可能会根据游戏的后端更新随时更改</para>
		/// </summary>
		public static int GetAppBuildId() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_GetAppBuildId(CSteamAPIContext.GetSteamApps());
		}

		/// <summary>
		/// <para> Request all proof of purchase keys for the calling appid and associated DLC.</para>
		/// <para> A series of AppProofOfPurchaseKeyResponse_t callbacks will be sent with</para>
		/// <para> appropriate appid values, ending with a final callback where the m_nAppId</para>
		/// <para> member is k_uAppIdInvalid (zero).</para>
		/// <para>请求有关调用appid和关联DLC的所有购买键的证明。一系列的AppProofOffurchAseKeyResponse_t回调将以适当的appid值发送，最后以最终回调结尾，其中m_nappid成员为k_uappidinvalid（零）。</para>
		/// </summary>
		public static void RequestAllProofOfPurchaseKeys() {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamApps_RequestAllProofOfPurchaseKeys(CSteamAPIContext.GetSteamApps());
		}

		public static SteamAPICall_t GetFileDetails(string pszFileName) {
			InteropHelp.TestIfAvailableClient();
			using (var pszFileName2 = new InteropHelp.UTF8StringHandle(pszFileName)) {
				return (SteamAPICall_t)NativeMethods.ISteamApps_GetFileDetails(CSteamAPIContext.GetSteamApps(), pszFileName2);
			}
		}

		/// <summary>
		/// <para> Get command line if game was launched via Steam URL, e.g. steam://run/&lt;appid&gt;//&lt;command line&gt;/.</para>
		/// <para> This method of passing a connect string (used when joining via rich presence, accepting an</para>
		/// <para> invite, etc) is preferable to passing the connect string on the operating system command</para>
		/// <para> line, which is a security risk.  In order for rich presence joins to go through this</para>
		/// <para> path and not be placed on the OS command line, you must set a value in your app's</para>
		/// <para> configuration on Steam.  Ask Valve for help with this.</para>
		/// <para> If game was already running and launched again, the NewUrlLaunchParameters_t will be fired.</para>
		/// <para>如果通过Steam URL启动游戏，例如Steam：// run/<Appid> // <命令行>/。这种传递连接字符串的方法（通过丰富的存在，接受邀请等加入时使用）比在操作系统命令行上传递连接字符串（这是安全风险）最可取。为了使丰富的存在连接到通过此路径而不是放置在OS命令行上，您必须在应用程序上的应用程序配置中设置一个值。向阀门寻求帮助。 如果游戏已经运行并再次启动，则将解雇NewUrlaunchParameters_t。</para>
		/// </summary>
		public static int GetLaunchCommandLine(out string pszCommandLine, int cubCommandLine) {
			InteropHelp.TestIfAvailableClient();
			IntPtr pszCommandLine2 = Marshal.AllocHGlobal(cubCommandLine);
			int ret = NativeMethods.ISteamApps_GetLaunchCommandLine(CSteamAPIContext.GetSteamApps(), pszCommandLine2, cubCommandLine);
			pszCommandLine = ret != -1 ? InteropHelp.PtrToStringUTF8(pszCommandLine2) : null;
			Marshal.FreeHGlobal(pszCommandLine2);
			return ret;
		}

		/// <summary>
		/// <para> Check if user borrowed this game via Family Sharing, If true, call GetAppOwner() to get the lender SteamID</para>
		/// <para>检查用户是否通过家庭共享（如果为true）借用此游戏，请致电GetAppowner（）获取贷款人Steamid</para>
		/// </summary>
		public static bool BIsSubscribedFromFamilySharing() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsSubscribedFromFamilySharing(CSteamAPIContext.GetSteamApps());
		}

		/// <summary>
		/// <para> check if game is a timed trial with limited playtime</para>
		/// <para>检查游戏是否是定时审判的，并且游戏时间有限</para>
		/// </summary>
		public static bool BIsTimedTrial(out uint punSecondsAllowed, out uint punSecondsPlayed) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsTimedTrial(CSteamAPIContext.GetSteamApps(), out punSecondsAllowed, out punSecondsPlayed);
		}

		/// <summary>
		/// <para> set current DLC AppID being played (or 0 if none). Allows Steam to track usage of major DLC extensions</para>
		/// <para>设置正在播放的当前DLC Appid（或0，如果没有）。允许Steam跟踪主要DLC扩展的使用</para>
		/// </summary>
		public static bool SetDlcContext(AppId_t nAppID) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_SetDlcContext(CSteamAPIContext.GetSteamApps(), nAppID);
		}

		/// <summary>
		/// <para> returns total number of known app branches (including default "public" branch ). nAvailable is number of available betas</para>
		/// <para>返回已知应用程序分支的总数（包括默认的“公共”分支）。可用的是可用的beta数量</para>
		/// </summary>
		public static int GetNumBetas(out int pnAvailable, out int pnPrivate) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_GetNumBetas(CSteamAPIContext.GetSteamApps(), out pnAvailable, out pnPrivate);
		}

		/// <summary>
		/// <para> return beta branch details, name, description, current BuildID and state flags (EBetaBranchFlags)</para>
		/// <para> iterate through</para>
		/// <para>返回beta分支详细信息，名称，描述，当前的buildid和状态标志（ebetabranchflags）遍历</para>
		/// </summary>
		public static bool GetBetaInfo(int iBetaIndex, out uint punFlags, out uint punBuildID, out string pchBetaName, int cchBetaName, out string pchDescription, int cchDescription) {
			InteropHelp.TestIfAvailableClient();
			IntPtr pchBetaName2 = Marshal.AllocHGlobal(cchBetaName);
			IntPtr pchDescription2 = Marshal.AllocHGlobal(cchDescription);
			bool ret = NativeMethods.ISteamApps_GetBetaInfo(CSteamAPIContext.GetSteamApps(), iBetaIndex, out punFlags, out punBuildID, pchBetaName2, cchBetaName, pchDescription2, cchDescription);
			pchBetaName = ret ? InteropHelp.PtrToStringUTF8(pchBetaName2) : null;
			Marshal.FreeHGlobal(pchBetaName2);
			pchDescription = ret ? InteropHelp.PtrToStringUTF8(pchDescription2) : null;
			Marshal.FreeHGlobal(pchDescription2);
			return ret;
		}

		/// <summary>
		/// <para> select this beta branch for this app as active, might need the game to restart so Steam can update to that branch</para>
		/// <para>选择此应用程序为活动的此Beta分支，可能需要游戏才能重新启动，以便Steam可以更新到该分支</para>
		/// </summary>
		public static bool SetActiveBeta(string pchBetaName) {
			InteropHelp.TestIfAvailableClient();
			using (var pchBetaName2 = new InteropHelp.UTF8StringHandle(pchBetaName)) {
				return NativeMethods.ISteamApps_SetActiveBeta(CSteamAPIContext.GetSteamApps(), pchBetaName2);
			}
		}
	}
}

#endif // !DISABLESTEAMWORKS
