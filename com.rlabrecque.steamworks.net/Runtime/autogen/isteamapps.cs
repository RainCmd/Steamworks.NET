// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
	#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	public static class SteamApps {
		public static bool BIsSubscribed() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsSubscribed(CSteamAPIContext.GetSteamApps());
		}

		public static bool BIsLowViolence() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsLowViolence(CSteamAPIContext.GetSteamApps());
		}

		public static bool BIsCybercafe() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsCybercafe(CSteamAPIContext.GetSteamApps());
		}

		public static bool BIsVACBanned() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsVACBanned(CSteamAPIContext.GetSteamApps());
		}

		public static string GetCurrentGameLanguage() {
			InteropHelp.TestIfAvailableClient();
			return InteropHelp.PtrToStringUTF8(NativeMethods.ISteamApps_GetCurrentGameLanguage(CSteamAPIContext.GetSteamApps()));
		}

		public static string GetAvailableGameLanguages() {
			InteropHelp.TestIfAvailableClient();
			return InteropHelp.PtrToStringUTF8(NativeMethods.ISteamApps_GetAvailableGameLanguages(CSteamAPIContext.GetSteamApps()));
		}

		/// <summary>
		/// <para> only use this member if you need to check ownership of another game related to yours, a demo for example</para>
		/// <para>Okay, understood. Please send your content.</para>
		/// </summary>
		public static bool BIsSubscribedApp(AppId_t appID) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsSubscribedApp(CSteamAPIContext.GetSteamApps(), appID);
		}

		/// <summary>
		/// <para> Takes AppID of DLC and checks if the user owns the DLC &amp; if the DLC is installed</para>
		/// <para>获取DLC的AppID并检查用户是否拥有该DLC以及该DLC是否已安装。</para>
		/// </summary>
		public static bool BIsDlcInstalled(AppId_t appID) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsDlcInstalled(CSteamAPIContext.GetSteamApps(), appID);
		}

		/// <summary>
		/// <para> returns the Unix time of the purchase of the app</para>
		/// <para>返回应用购买的 Unix 时间戳</para>
		/// </summary>
		public static uint GetEarliestPurchaseUnixTime(AppId_t nAppID) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_GetEarliestPurchaseUnixTime(CSteamAPIContext.GetSteamApps(), nAppID);
		}

		/// <summary>
		/// <para> Checks if the user is subscribed to the current app through a free weekend</para>
		/// <para> This function will return false for users who have a retail or other type of license</para>
		/// <para> Before using, please ask your Valve technical contact how to package and secure your free weekened</para>
		/// <para>检查用户是否通过免费周末订阅了当前应用。此函数将返回false，对于拥有零售版或其他类型的许可证的用户。在使用前，请咨询您的Valve技术联系人，了解如何打包和安全地进行免费周末。</para>
		/// </summary>
		public static bool BIsSubscribedFromFreeWeekend() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsSubscribedFromFreeWeekend(CSteamAPIContext.GetSteamApps());
		}

		/// <summary>
		/// <para> Returns the number of DLC pieces for the running app</para>
		/// <para>返回正在运行的应用的 DLC 件数</para>
		/// </summary>
		public static int GetDLCCount() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_GetDLCCount(CSteamAPIContext.GetSteamApps());
		}

		/// <summary>
		/// <para> Returns metadata for DLC by index, of range [0, GetDLCCount()]</para>
		/// <para>通过索引、范围[0, GetDLCCount()]返回DLC元数据</para>
		/// </summary>
		public static bool BGetDLCDataByIndex(int iDLC, out AppId_t pAppID, out bool pbAvailable, out string pchName, int cchNameBufferSize) {
			InteropHelp.TestIfAvailableClient();
			IntPtr pchName2 = Marshal.AllocHGlobal(cchNameBufferSize);
			bool ret = NativeMethods.ISteamApps_BGetDLCDataByIndex(CSteamAPIContext.GetSteamApps(), iDLC, out pAppID, out pbAvailable, pchName2, cchNameBufferSize);
			pchName = ret ? InteropHelp.PtrToStringUTF8(pchName2) : null;
			Marshal.FreeHGlobal(pchName2);
			return ret;
		}

		/// <summary>
		/// <para> Install/Uninstall control for optional DLC</para>
		/// <para>安装/卸载可选DLC控制</para>
		/// </summary>
		public static void InstallDLC(AppId_t nAppID) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamApps_InstallDLC(CSteamAPIContext.GetSteamApps(), nAppID);
		}

		public static void UninstallDLC(AppId_t nAppID) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamApps_UninstallDLC(CSteamAPIContext.GetSteamApps(), nAppID);
		}

		/// <summary>
		/// <para> Request legacy cd-key for yourself or owned DLC. If you are interested in this</para>
		/// <para> data then make sure you provide us with a list of valid keys to be distributed</para>
		/// <para> to users when they purchase the game, before the game ships.</para>
		/// <para> You'll receive an AppProofOfPurchaseKeyResponse_t callback when</para>
		/// <para> the key is available (which may be immediately).</para>
		/// <para>如果您需要请求旧版CD-key，请为自己或已购买的DLC提供此信息。如果您对这些数据感兴趣，请在游戏发货前提供有效的密钥列表，以便在用户购买游戏时进行分发。您将收到AppProofOfPurchaseKeyResponse_t回调，当密钥可用时（可能立即）。</para>
		/// </summary>
		public static void RequestAppProofOfPurchaseKey(AppId_t nAppID) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamApps_RequestAppProofOfPurchaseKey(CSteamAPIContext.GetSteamApps(), nAppID);
		}

		/// <summary>
		/// <para> returns current beta branch name, 'public' is the default branch</para>
		/// <para>返回当前 Beta 分支名称，'public' 是默认分支。</para>
		/// </summary>
		public static bool GetCurrentBetaName(out string pchName, int cchNameBufferSize) {
			InteropHelp.TestIfAvailableClient();
			IntPtr pchName2 = Marshal.AllocHGlobal(cchNameBufferSize);
			bool ret = NativeMethods.ISteamApps_GetCurrentBetaName(CSteamAPIContext.GetSteamApps(), pchName2, cchNameBufferSize);
			pchName = ret ? InteropHelp.PtrToStringUTF8(pchName2) : null;
			Marshal.FreeHGlobal(pchName2);
			return ret;
		}

		/// <summary>
		/// <para> signal Steam that game files seems corrupt or missing</para>
		/// <para>信号 Steam 游戏文件似乎已损坏或丢失</para>
		/// </summary>
		public static bool MarkContentCorrupt(bool bMissingFilesOnly) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_MarkContentCorrupt(CSteamAPIContext.GetSteamApps(), bMissingFilesOnly);
		}

		/// <summary>
		/// <para> return installed depots in mount order</para>
		/// <para>返回已安装的仓库顺序</para>
		/// </summary>
		public static uint GetInstalledDepots(AppId_t appID, DepotId_t[] pvecDepots, uint cMaxDepots) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_GetInstalledDepots(CSteamAPIContext.GetSteamApps(), appID, pvecDepots, cMaxDepots);
		}

		/// <summary>
		/// <para> returns current app install folder for AppID, returns folder name length</para>
		/// <para>返回当前应用安装文件夹，返回文件夹名称长度</para>
		/// </summary>
		public static uint GetAppInstallDir(AppId_t appID, out string pchFolder, uint cchFolderBufferSize) {
			InteropHelp.TestIfAvailableClient();
			IntPtr pchFolder2 = Marshal.AllocHGlobal((int)cchFolderBufferSize);
			uint ret = NativeMethods.ISteamApps_GetAppInstallDir(CSteamAPIContext.GetSteamApps(), appID, pchFolder2, cchFolderBufferSize);
			pchFolder = ret != 0 ? InteropHelp.PtrToStringUTF8(pchFolder2) : null;
			Marshal.FreeHGlobal(pchFolder2);
			return ret;
		}

		/// <summary>
		/// <para> returns true if that app is installed (not necessarily owned)</para>
		/// <para>如果该应用已安装（不一定属于您）</para>
		/// </summary>
		public static bool BIsAppInstalled(AppId_t appID) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsAppInstalled(CSteamAPIContext.GetSteamApps(), appID);
		}

		/// <summary>
		/// <para> returns the SteamID of the original owner. If this CSteamID is different from ISteamUser::GetSteamID(),</para>
		/// <para> the user has a temporary license borrowed via Family Sharing</para>
		/// <para>返回原始所有者的 SteamID。如果这个 CSteamID 与 ISteamUser::GetSteamID() 不同，则用户通过家庭共享借用了临时许可证。</para>
		/// </summary>
		public static CSteamID GetAppOwner() {
			InteropHelp.TestIfAvailableClient();
			return (CSteamID)NativeMethods.ISteamApps_GetAppOwner(CSteamAPIContext.GetSteamApps());
		}

		/// <summary>
		/// <para> Returns the associated launch param if the game is run via steam://run/&lt;appid&gt;//?param1=value1&amp;param2=value2&amp;param3=value3 etc.</para>
		/// <para> Parameter names starting with the character '@' are reserved for internal use and will always return and empty string.</para>
		/// <para> Parameter names starting with an underscore '_' are reserved for steam features -- they can be queried by the game,</para>
		/// <para> but it is advised that you not param names beginning with an underscore for your own features.</para>
		/// <para> Check for new launch parameters on callback NewUrlLaunchParameters_t</para>
		/// <para>返回关联的启动参数，如果游戏通过 steam://run/<appid>//?param1=value1&param2=value2&param3=value3 等方式运行。以 '@' 开头的参数名称用于内部用途，始终返回空字符串。以 '_' 开头的参数名称用于 Steam 功能，游戏可以查询它们，但建议不要为自己的功能使用以 '_' 开头的参数名称。检查新的启动参数在 NewUrlLaunchParameters_t 回调中。</para>
		/// </summary>
		public static string GetLaunchQueryParam(string pchKey) {
			InteropHelp.TestIfAvailableClient();
			using (var pchKey2 = new InteropHelp.UTF8StringHandle(pchKey)) {
				return InteropHelp.PtrToStringUTF8(NativeMethods.ISteamApps_GetLaunchQueryParam(CSteamAPIContext.GetSteamApps(), pchKey2));
			}
		}

		/// <summary>
		/// <para> get download progress for optional DLC</para>
		/// <para>获取可选DLC的下载进度</para>
		/// </summary>
		public static bool GetDlcDownloadProgress(AppId_t nAppID, out ulong punBytesDownloaded, out ulong punBytesTotal) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_GetDlcDownloadProgress(CSteamAPIContext.GetSteamApps(), nAppID, out punBytesDownloaded, out punBytesTotal);
		}

		/// <summary>
		/// <para> return the buildid of this app, may change at any time based on backend updates to the game</para>
		/// <para>返回此应用的构建ID，可能会随时根据游戏后端更新而变化。</para>
		/// </summary>
		public static int GetAppBuildId() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_GetAppBuildId(CSteamAPIContext.GetSteamApps());
		}

		/// <summary>
		/// <para> Request all proof of purchase keys for the calling appid and associated DLC.</para>
		/// <para> A series of AppProofOfPurchaseKeyResponse_t callbacks will be sent with</para>
		/// <para> appropriate appid values, ending with a final callback where the m_nAppId</para>
		/// <para> member is k_uAppIdInvalid (zero).</para>
		/// <para>请求所有《Calling》应用ID及其相关DLC的购买凭证密钥。一系列 `AppProofOfPurchaseKeyResponse_t` 回调将发送，带有适当的 `appid` 值，最后以一个回调结束，其中 `m_nAppId` 成员为 `k_uAppIdInvalid`（零）。</para>
		/// </summary>
		public static void RequestAllProofOfPurchaseKeys() {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamApps_RequestAllProofOfPurchaseKeys(CSteamAPIContext.GetSteamApps());
		}

		public static SteamAPICall_t GetFileDetails(string pszFileName) {
			InteropHelp.TestIfAvailableClient();
			using (var pszFileName2 = new InteropHelp.UTF8StringHandle(pszFileName)) {
				return (SteamAPICall_t)NativeMethods.ISteamApps_GetFileDetails(CSteamAPIContext.GetSteamApps(), pszFileName2);
			}
		}

		/// <summary>
		/// <para> Get command line if game was launched via Steam URL, e.g. steam://run/&lt;appid&gt;//&lt;command line&gt;/.</para>
		/// <para> This method of passing a connect string (used when joining via rich presence, accepting an</para>
		/// <para> invite, etc) is preferable to passing the connect string on the operating system command</para>
		/// <para> line, which is a security risk.  In order for rich presence joins to go through this</para>
		/// <para> path and not be placed on the OS command line, you must set a value in your app's</para>
		/// <para> configuration on Steam.  Ask Valve for help with this.</para>
		/// <para> If game was already running and launched again, the NewUrlLaunchParameters_t will be fired.</para>
		/// <para>获取通过 Steam URL 启动游戏时使用的命令行，例如：steam://run/<appid>//<命令行>/. 使用这种方法传递连接字符串（用于通过丰富存在加入或接受邀请等）比在操作系统命令行上传递连接字符串更安全。为了使通过丰富存在加入时，连接字符串通过此路径传递，而不是放置在操作系统命令行上，您需要在应用程序的配置中设置一个值。请向 Valve 寻求帮助。</para>
		/// <para>如果游戏已经在运行，并且再次启动，NewUrlLaunchParameters_t 将会被触发。</para>
		/// </summary>
		public static int GetLaunchCommandLine(out string pszCommandLine, int cubCommandLine) {
			InteropHelp.TestIfAvailableClient();
			IntPtr pszCommandLine2 = Marshal.AllocHGlobal(cubCommandLine);
			int ret = NativeMethods.ISteamApps_GetLaunchCommandLine(CSteamAPIContext.GetSteamApps(), pszCommandLine2, cubCommandLine);
			pszCommandLine = ret != -1 ? InteropHelp.PtrToStringUTF8(pszCommandLine2) : null;
			Marshal.FreeHGlobal(pszCommandLine2);
			return ret;
		}

		/// <summary>
		/// <para> Check if user borrowed this game via Family Sharing, If true, call GetAppOwner() to get the lender SteamID</para>
		/// <para>检查用户是否通过家庭共享借用此游戏，如果为真，调用 GetAppOwner() 以获取借出方的 SteamID。</para>
		/// </summary>
		public static bool BIsSubscribedFromFamilySharing() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsSubscribedFromFamilySharing(CSteamAPIContext.GetSteamApps());
		}

		/// <summary>
		/// <para> check if game is a timed trial with limited playtime</para>
		/// <para>请提供游戏名称，我将检查它是否为限时试玩并有有限的试玩时间。</para>
		/// </summary>
		public static bool BIsTimedTrial(out uint punSecondsAllowed, out uint punSecondsPlayed) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_BIsTimedTrial(CSteamAPIContext.GetSteamApps(), out punSecondsAllowed, out punSecondsPlayed);
		}

		/// <summary>
		/// <para> set current DLC AppID being played (or 0 if none). Allows Steam to track usage of major DLC extensions</para>
		/// <para>设置当前 DLC 应用 ID (或 0 表示未加载任何 DLC)。允许 Steam 跟踪主要 DLC 扩展的使用情况。</para>
		/// </summary>
		public static bool SetDlcContext(AppId_t nAppID) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_SetDlcContext(CSteamAPIContext.GetSteamApps(), nAppID);
		}

		/// <summary>
		/// <para> returns total number of known app branches (including default "public" branch ). nAvailable is number of available betas</para>
		/// <para>返回已知应用分支的总数（包括默认“public”分支）。nAvailable 是可用测试版的数量。</para>
		/// </summary>
		public static int GetNumBetas(out int pnAvailable, out int pnPrivate) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamApps_GetNumBetas(CSteamAPIContext.GetSteamApps(), out pnAvailable, out pnPrivate);
		}

		/// <summary>
		/// <para> return beta branch details, name, description, current BuildID and state flags (EBetaBranchFlags)</para>
		/// <para> iterate through</para>
		/// <para>返回 beta 分支详情，名称、描述、当前 BuildID 和状态标志 (EBetaBranchFlags) 进行迭代。</para>
		/// </summary>
		public static bool GetBetaInfo(int iBetaIndex, out uint punFlags, out uint punBuildID, out string pchBetaName, int cchBetaName, out string pchDescription, int cchDescription) {
			InteropHelp.TestIfAvailableClient();
			IntPtr pchBetaName2 = Marshal.AllocHGlobal(cchBetaName);
			IntPtr pchDescription2 = Marshal.AllocHGlobal(cchDescription);
			bool ret = NativeMethods.ISteamApps_GetBetaInfo(CSteamAPIContext.GetSteamApps(), iBetaIndex, out punFlags, out punBuildID, pchBetaName2, cchBetaName, pchDescription2, cchDescription);
			pchBetaName = ret ? InteropHelp.PtrToStringUTF8(pchBetaName2) : null;
			Marshal.FreeHGlobal(pchBetaName2);
			pchDescription = ret ? InteropHelp.PtrToStringUTF8(pchDescription2) : null;
			Marshal.FreeHGlobal(pchDescription2);
			return ret;
		}

		/// <summary>
		/// <para> select this beta branch for this app as active, might need the game to restart so Steam can update to that branch</para>
		/// <para>选择此测试分支作为该应用的活动分支，可能需要游戏重启，以便Steam更新到该分支。</para>
		/// </summary>
		public static bool SetActiveBeta(string pchBetaName) {
			InteropHelp.TestIfAvailableClient();
			using (var pchBetaName2 = new InteropHelp.UTF8StringHandle(pchBetaName)) {
				return NativeMethods.ISteamApps_SetActiveBeta(CSteamAPIContext.GetSteamApps(), pchBetaName2);
			}
		}
	}
}

#endif // !DISABLESTEAMWORKS
