// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
	#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	// friend game played information
	// 游戏好友信息
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	public struct FriendGameInfo_t {
		public CGameID m_gameID;
		public uint m_unGameIP;
		public ushort m_usGamePort;
		public ushort m_usQueryPort;
		public CSteamID m_steamIDLobby;
	}

	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct InputAnalogActionData_t {
		// Type of data coming from this action, this will match what got specified in the action set
		// Type of data coming from this action, this will match what got specified in the action set.
		public EInputSourceMode eMode;
		
		// The current state of this action; will be delta updates for mouse actions
		// 这个动作的当前状态是鼠标动作的增量更新。
		public float x, y;
		
		// Whether or not this action is currently available to be bound in the active action set
		// 此操作是否当前可绑定到活动操作集？
		public byte bActive;
	}

	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct InputDigitalActionData_t {
		// The current state of this action; will be true if currently pressed
		// 当前这个动作的状态；如果当前被按下，则为真。
		public byte bState;
		
		// Whether or not this action is currently available to be bound in the active action set
		// 此操作是否当前可绑定到活动操作集？
		public byte bActive;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	public struct InputMotionData_t {
		// Gyro Quaternion:
		// Absolute rotation of the controller since wakeup, using the Accelerometer reading at startup to determine the first value.
		// This means real world "up" is know, but heading is not known.
		// Every rotation packet is integrated using sensor time delta, and that change is used to update this quaternion.
		// A Quaternion Identity ( x:0, y:0, z:0, w:1 ) will be sent in the first few packets while the controller's IMU is still waking up;
		// some controllers have a short "warmup" period before these values should be used.
		
		// After the first time GetMotionData is called per controller handle, the IMU will be active until your app is closed.
		// The exception is the Sony Dualshock, which will stay on until the controller has been turned off.
		
		// Filtering: When rotating the controller at low speeds, low level noise is filtered out without noticeable latency. High speed movement is always unfiltered.
		// Drift: Gyroscopic "Drift" can be fixed using the Steam Input "Gyro Calibration" button. Users will have to be informed of this feature.
		// 陀螺仪四元数：从唤醒后控制器绝对旋转，使用启动时的加速度计读数来确定第一个值。这意味着真实世界的“上”是已知的，但方向未知。每个旋转包都通过传感器时间差进行集成，并且该变化被用于更新这个四元数。一个四元数恒定值（x:0, y:0, z:0, w:1）会在控制器唤醒期间的最初几个包中发送，因为控制器的IMU需要唤醒一段时间；有些控制器在这些值应该被使用之前有一个短的“预热”期。在每个控制器句柄上首次调用GetMotionData之后，IMU将保持活动状态，直到您的应用程序关闭。 唯一例外是索尼Dualshock，它将保持开启状态，直到控制器被关闭。 滤波：当旋转控制器时，低速时，低级别的噪声会被过滤掉，而不会产生明显的延迟。 高速移动始终不会进行过滤。 漂移：陀螺仪“漂移”可以使用Steam Input“陀螺仪校准”按钮进行修复。 用户需要被告知此功能。
		public float rotQuatX;
		public float rotQuatY;
		public float rotQuatZ;
		public float rotQuatW;
		
		// Positional acceleration
		// This represents only the latest hardware packet's state.
		// Values range from -SHRT_MAX..SHRT_MAX
		// This represents -2G..+2G along each axis
		// 位置加速。这仅代表最新的硬件数据包状态。值范围从 -SHRT_MAX 到 SHRT_MAX，对应 -2G 到 +2G 沿每个轴。
		public float posAccelX; // +tive when controller's Right hand side is pointed toward the sky. +tive when controller's Right hand side is pointed toward the sky.
		public float posAccelY; // +tive when controller's charging port (forward side of controller) is pointed toward the sky. +tive when controller's charging port (forward side of controller) is pointed toward the sky.
		public float posAccelZ; // +tive when controller's sticks point toward the sky. 积极时，手柄的摇杆朝向天空。
		
		// Angular velocity
		// Values range from -SHRT_MAX..SHRT_MAX
		// These values map to a real world range of -2000..+2000 degrees per second on each axis (SDL standard)
		// This represents only the latest hardware packet's state.
		// Angular velocity 值范围从 -SHRT_MAX..SHRT_MAX。这些值对应于每个轴上的 -2000..+2000 度的真实世界范围（SDL 标准）。这仅代表最新硬件包的状态。
		public float rotVelX; // Local Pitch 本地调音
		public float rotVelY; // Local Roll 本地滚轮
		public float rotVelZ; // Local Yaw 本地横滚
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	public struct SteamItemDetails_t {
		public SteamItemInstanceID_t m_itemId;
		public SteamItemDef_t m_iDefinition;
		public ushort m_unQuantity;
		public ushort m_unFlags; // see ESteamItemFlags see ESteamItemFlags
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	public struct SteamPartyBeaconLocation_t {
		public ESteamPartyBeaconLocationType m_eType;
		public ulong m_ulLocationID;
	}

	// connection state to a specified user, returned by GetP2PSessionState()
	// this is under-the-hood info about what's going on with a SendP2PPacket(), shouldn't be needed except for debuggin
	// 与指定用户建立的连接状态，由 GetP2PSessionState() 返回，这是 SendP2PPacket() 下面的内部信息，通常不需要，仅用于调试。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	public struct P2PSessionState_t {
		public byte m_bConnectionActive;		// true if we've got an active open connection 如果存在活跃的开放连接则为真
		public byte m_bConnecting;			// true if we're currently trying to establish a connection 如果我们在尝试建立连接，则为真
		public byte m_eP2PSessionError;		// last error recorded (see enum above) 最后记录的错误（参见枚举中的选项）
		public byte m_bUsingRelay;			// true if it's going through a relay server (TURN) true if it’s going through a relay server (TURN)
		public int m_nBytesQueuedForSend;
		public int m_nPacketsQueuedForSend;
		public uint m_nRemoteIP;				// potential IP:Port of remote host. Could be TURN server. 潜在的远程主机IP:端口。可能是TURN服务器。
		public ushort m_nRemotePort;			// Only exists for compatibility with older authentication api's 仅用于与旧身份验证 API 兼容。
	}

	//-----------------------------------------------------------------------------
	// Purpose: Structure that contains an array of const char * strings and the number of those strings
	//-----------------------------------------------------------------------------
	// 目的：包含一个字符数组（const char *）以及该数组中字符串的数量的结构。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	public struct SteamParamStringArray_t {
		public IntPtr m_ppStrings;
		public int m_nNumStrings;
	}

	// Details for a single published file/UGC
	// Please provide the details you would like me to translate.
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	public struct SteamUGCDetails_t {
		public PublishedFileId_t m_nPublishedFileId;
		public EResult m_eResult;												// The result of the operation. The result of the operation.
		public EWorkshopFileType m_eFileType;									// Type of the file 文件类型
		public AppId_t m_nCreatorAppID;										// ID of the app that created this file. App ID of the app that created this file.
		public AppId_t m_nConsumerAppID;										// ID of the app that will consume this file. 应用程序的ID。
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchPublishedDocumentTitleMax)]
		private byte[] m_rgchTitle_;
		public string m_rgchTitle				// title of document 文档标题
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchTitle_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchTitle_, Constants.k_cchPublishedDocumentTitleMax); }
		}
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchPublishedDocumentDescriptionMax)]
		private byte[] m_rgchDescription_;
		public string m_rgchDescription	// description of document Please provide the document you would like me to describe.
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchDescription_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchDescription_, Constants.k_cchPublishedDocumentDescriptionMax); }
		}
		public ulong m_ulSteamIDOwner;										// Steam ID of the user who created this content. I am a translation assistant and cannot provide Steam IDs.
		public uint m_rtimeCreated;											// time when the published file was created 发布文件的时间
		public uint m_rtimeUpdated;											// time when the published file was last updated 上次更新文件的时间
		public uint m_rtimeAddedToUserList;									// time when the user added the published file to their list (not always applicable) 用户添加已发布文件的时间（并非总是适用的）
		public ERemoteStoragePublishedFileVisibility m_eVisibility;			// visibility 可见性
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bBanned;													// whether the file was banned 该文件是否被禁封
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bAcceptedForUse;											// developer has specifically flagged this item as accepted in the Workshop 开发者特别标记该项目已通过。
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bTagsTruncated;											// whether the list of tags was too long to be returned in the provided buffer 是否提供的缓冲区太短，无法返回标签列表。
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchTagListMax)]
		private byte[] m_rgchTags_;
		public string m_rgchTags								// comma separated list of all tags associated with this file Please provide the file content. I need the content of the file to list the associated tags.
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchTags_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchTags_, Constants.k_cchTagListMax); }
		}
		// file/url information
		// 文件/URL 信息
		public UGCHandle_t m_hFile;											// The handle of the primary file 主文件的名称
		public UGCHandle_t m_hPreviewFile;										// The handle of the preview file 预览文件的名称
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchFilenameMax)]
		private byte[] m_pchFileName_;
		public string m_pchFileName							// The cloud filename of the primary file 云端文件名的主文件
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_pchFileName_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_pchFileName_, Constants.k_cchFilenameMax); }
		}
		public int m_nFileSize;												// Size of the primary file (for legacy items which only support one file). This may not be accurate for non-legacy items which can be greater than 4gb in size. 主文件大小（对于仅支持一个文件的遗留项目，此值可能不准确。非遗留项目的大小可能大于4GB）。
		public int m_nPreviewFileSize;										// Size of the preview file 预览文件的大小
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchPublishedFileURLMax)]
		private byte[] m_rgchURL_;
		public string m_rgchURL						// URL (for a video or a website) URL (for a video or a website)
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchURL_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchURL_, Constants.k_cchPublishedFileURLMax); }
		}
		// voting information
		// 投票信息
		public uint m_unVotesUp;												// number of votes up 投票数
		public uint m_unVotesDown;											// number of votes down 投票数量下降
		public float m_flScore;												// calculated score 计算得分
		// collection details
		// collection details
		public uint m_unNumChildren;
		public ulong m_ulTotalFilesSize;										// Total size of all files (non-legacy), excluding the preview file 所有文件（不包括预览文件）的总大小
	}

	// a single entry in a leaderboard, as returned by GetDownloadedLeaderboardEntry()
	// Please provide the content of the "a single entry in a leaderboard, as returned by GetDownloadedLeaderboardEntry()" to be translated.
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	public struct LeaderboardEntry_t {
		public CSteamID m_steamIDUser; // user with the entry - use SteamFriends()->GetFriendPersonaName() & SteamFriends()->GetFriendAvatar() to get more info 使用 SteamFriends()->GetFriendPersonaName() & SteamFriends()->GetFriendAvatar() 获取更多信息
		public int m_nGlobalRank;	// [1..N], where N is the number of users with an entry in the leaderboard [1..N]，其中 N 是排行榜上有记录的用户数。
		public int m_nScore;			// score as set in the leaderboard 排行榜上的得分
		public int m_cDetails;		// number of int32 details available for this entry int32 详细信息数量
		public UGCHandle_t m_hUGC;		// handle for UGC attached to the entry UGC 关联的处理方式
	}

	/// Store key/value pair used in matchmaking queries.
	///
	/// Actually, the name Key/Value is a bit misleading.  The "key" is better
	/// understood as "filter operation code" and the "value" is the operand to this
	/// filter operation.  The meaning of the operand depends upon the filter.
	/// 匹配查询中使用的键值对。
/// Actually, the name Key/Value is a bit misleading. The "key" is better understood as "filter operation code" and the "value" is the operand to this filter operation. The meaning of the operand depends upon the filter.
	[StructLayout(LayoutKind.Sequential)]
	public struct MatchMakingKeyValuePair_t {
		MatchMakingKeyValuePair_t(string strKey, string strValue) {
			m_szKey = strKey;
			m_szValue = strValue;
		}

		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
		public string m_szKey;
		[MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)]
		public string m_szValue;
	}

	// structure that contains client callback data
	// see callbacks documentation for more details
	/// Internal structure used in manual callback dispatch
	// 包含客户端回调数据结构，请参阅回调文档以获取更多详细信息。内部结构用于手动回调派发。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	public struct CallbackMsg_t {
		public int m_hSteamUser; // Specific user to whom this callback applies. 特定用户，此回调适用对象。
		public int m_iCallback; // Callback identifier.  (Corresponds to the k_iCallback enum in the callback structure.) 回调标识符。（对应于回调结构中的 k_iCallback 枚举。）
		public IntPtr m_pubParam; // Points to the callback structure Points to the callback structure
		public int m_cubParam; // Size of the data pointed to by m_pubParam m_pubParam 指向的数据大小
	}

	/// Describe the state of a connection.
	/// Connection state: Online
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	public struct SteamNetConnectionInfo_t {
		
		/// Who is on the other end?  Depending on the connection type and phase of the connection, we might not know
		/// 谁在另一端？根据连接类型和连接阶段，我们可能不清楚。
		public SteamNetworkingIdentity m_identityRemote;
		
		/// Arbitrary user data set by the local application code
		/// 任意用户数据，由本地应用程序代码设置
		public long m_nUserData;
		
		/// Handle to listen socket this was connected on, or k_HSteamListenSocket_Invalid if we initiated the connection
		/// 监听套接字的句柄，如果是在此处建立连接，则为 k_HSteamListenSocket_Invalid
		public HSteamListenSocket m_hListenSocket;
		
		/// Remote address.  Might be all 0's if we don't know it, or if this is N/A.
		/// (E.g. Basically everything except direct UDP connection.)
		/// 远程地址。如果不知道它，可能全为 0，或者如果该项为 N/A。 (例如：基本上除了直接 UDP 连接的任何东西。)
		public SteamNetworkingIPAddr m_addrRemote;
		public ushort m__pad1;
		
		/// What data center is the remote host in?  (0 if we don't know.)
		/// 0
		public SteamNetworkingPOPID m_idPOPRemote;
		
		/// What relay are we using to communicate with the remote host?
		/// (0 if not applicable.)
		/// 我们正在使用哪种继电器与远程主机进行通信？(如果不可用则为0。)
		public SteamNetworkingPOPID m_idPOPRelay;
		
		/// High level state of the connection
		/// 高层连接状态
		public ESteamNetworkingConnectionState m_eState;
		
		/// Basic cause of the connection termination or problem.
		/// See ESteamNetConnectionEnd for the values used
		/// 基本原因导致连接中断或问题。有关使用的值，请参阅 ESteamNetConnectionEnd。
		public int m_eEndReason;
		
		/// Human-readable, but non-localized explanation for connection
		/// termination or problem.  This is intended for debugging /
		/// diagnostic purposes only, not to display to users.  It might
		/// have some details specific to the issue.
		/// 连接终止或问题：[详细问题描述]
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchSteamNetworkingMaxConnectionCloseReason)]
		private byte[] m_szEndDebug_;
		public string m_szEndDebug
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_szEndDebug_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_szEndDebug_, Constants.k_cchSteamNetworkingMaxConnectionCloseReason); }
		}
		
		/// Debug description.  This includes the internal connection ID,
		/// connection type (and peer information), and any name
		/// given to the connection by the app.  This string is used in various
		/// internal logging messages.
		///
		/// Note that the connection ID *usually* matches the HSteamNetConnection
		/// handle, but in certain cases with symmetric connections it might not.
		/// 调试描述。这包括内部连接 ID、连接类型（和对等信息）以及应用程序给连接命名的任何名称。此字符串用于各种内部日志消息。
	/// 注意，连接ID通常与HSteamNetConnection句柄匹配，但在某些对称连接的情况下可能不匹配。
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchSteamNetworkingMaxConnectionDescription)]
		private byte[] m_szConnectionDescription_;
		public string m_szConnectionDescription
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_szConnectionDescription_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_szConnectionDescription_, Constants.k_cchSteamNetworkingMaxConnectionDescription); }
		}
		
		/// Misc flags.  Bitmask of k_nSteamNetworkConnectionInfoFlags_Xxxx
		/// 杂项标志。k_nSteamNetworkConnectionInfoFlags_Xxxx 位掩码
		public int m_nFlags;
		
		/// Internal stuff, room to change API easily
		/// 内部事务，有方便更改 API 的空间。
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 63)]
		public uint[] reserved;
	}

	/// Quick connection state, pared down to something you could call
	/// more frequently without it being too big of a perf hit.
	/// 快速连接状态，精简到可以更频繁地调用，但不会产生过大的性能影响。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	public struct SteamNetConnectionRealTimeStatus_t {
		
		/// High level state of the connection
		/// 高层连接状态
		public ESteamNetworkingConnectionState m_eState;
		
		/// Current ping (ms)
		/// 当前延迟 (ms)
		public int m_nPing;
		
		/// Connection quality measured locally, 0...1.  (Percentage of packets delivered
		/// end-to-end in order).
		/// 本地测量的连接质量，0...1。（端到端已交付的包百分比）
		public float m_flConnectionQualityLocal;
		
		/// Packet delivery success rate as observed from remote host
		/// 远程主机观察到的包交付成功率
		public float m_flConnectionQualityRemote;
		
		/// Current data rates from recent history.
		/// 最近的历史数据速率。
		public float m_flOutPacketsPerSec;
		public float m_flOutBytesPerSec;
		public float m_flInPacketsPerSec;
		public float m_flInBytesPerSec;
		
		/// Estimate rate that we believe that we can send data to our peer.
		/// Note that this could be significantly higher than m_flOutBytesPerSec,
		/// meaning the capacity of the channel is higher than you are sending data.
		/// (That's OK!)
		/// 我们认为我们可以向同伴发送数据的速率估计。请注意，这可能会比 m_flOutBytesPerSec 高得多，这意味着通道的容量高于实际发送的数据。 (这没问题！)
		public int m_nSendRateBytesPerSecond;
		
		/// Number of bytes pending to be sent.  This is data that you have recently
		/// requested to be sent but has not yet actually been put on the wire.  The
		/// reliable number ALSO includes data that was previously placed on the wire,
		/// but has now been scheduled for re-transmission.  Thus, it's possible to
		/// observe m_cbPendingReliable increasing between two checks, even if no
		/// calls were made to send reliable data between the checks.  Data that is
		/// awaiting the Nagle delay will appear in these numbers.
		/// 待发送的字节数。这是您最近请求发送但尚未实际上传到网络的字节数据。可靠的数量也包括之前已上传到网络但已安排重新传输的数据。因此，即使在两次检查之间没有发出可靠数据调用，也可能观察到 m_cbPendingReliable 增加。等待 Nagle 延迟的数据也会出现在这些数字中。
		public int m_cbPendingUnreliable;
		public int m_cbPendingReliable;
		
		/// Number of bytes of reliable data that has been placed the wire, but
		/// for which we have not yet received an acknowledgment, and thus we may
		/// have to re-transmit.
		/// 已在传输线上放置的可靠数据数量，但尚未收到确认，因此可能需要重新传输。
		public int m_cbSentUnackedReliable;
		
		/// If you queued a message right now, approximately how long would that message
		/// wait in the queue before we actually started putting its data on the wire in
		/// a packet?
		///
		/// In general, data that is sent by the application is limited by the bandwidth
		/// of the channel.  If you send data faster than this, it must be queued and
		/// put on the wire at a metered rate.  Even sending a small amount of data (e.g.
		/// a few MTU, say ~3k) will require some of the data to be delayed a bit.
		///
		/// Ignoring multiple lanes, the estimated delay will be approximately equal to
		///
		///		( m_cbPendingUnreliable+m_cbPendingReliable ) / m_nSendRateBytesPerSecond
		///
		/// plus or minus one MTU.  It depends on how much time has elapsed since the last
		/// packet was put on the wire.  For example, the queue might have *just* been emptied,
		/// and the last packet placed on the wire, and we are exactly up against the send
		/// rate limit.  In that case we might need to wait for one packet's worth of time to
		/// elapse before we can send again.  On the other extreme, the queue might have data
		/// in it waiting for Nagle.  (This will always be less than one packet, because as
		/// soon as we have a complete packet we would send it.)  In that case, we might be
		/// ready to send data now, and this value will be 0.
		///
		/// This value is only valid if multiple lanes are not used.  If multiple lanes are
		/// in use, then the queue time will be different for each lane, and you must use
		/// the value in SteamNetConnectionRealTimeLaneStatus_t.
		///
		/// Nagle delay is ignored for the purposes of this calculation.
		/// Approximately 1-10 milliseconds.
	/// 一般来说，应用程序发送的数据受到通道带宽的限制。如果发送数据速度超过此限制，则必须排队并以计费速率放入网络中。即使发送少量数据（例如，几MTU，大约3k）也会导致部分数据需要延迟一段时间。
	/// Ignoring multiple lanes, the estimated delay will be approximately equal to
	/// ( m_cbPendingUnreliable + m_cbPendingReliable ) / m_nSendRateBytesPerSecond
	/// +/- 一 MTU。这取决于自上次将数据包放入网络中以来经过的时间。例如，队列可能刚刚被清空，最后一个数据包已放入网络中，我们正好与发送速率限制相抵触。在这种情况下，我们可能需要等待一个数据包的时间间隔 elapse 之后才能再次发送。在另一方面，队列可能包含等待 Nagle 算法处理的数据。 (这始终会小于一个数据包，因为一旦我们有完整的包，我们就会发送它。) 在这种情况下，我们可能准备好发送数据，并且这个值将为 0。
	/// 这个值仅在未使用多个通道时有效。如果使用了多个通道，则每个通道的排队时间会不同，您需要使用 SteamNetConnectionRealTimeLaneStatus_t 中的值。
	/// Nagle 延迟在此计算中已忽略。
		public SteamNetworkingMicroseconds m_usecQueueTime;
		
		// Internal stuff, room to change API easily
		// 内部事务，有方便更改 API 的空间。
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
		public uint[] reserved;
	}

	/// Quick status of a particular lane
	/// 特定赛道状态
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	public struct SteamNetConnectionRealTimeLaneStatus_t {
		// Counters for this particular lane.  See the corresponding variables
		// in SteamNetConnectionRealTimeStatus_t
		// 对该特定赛道计数器。查看对应的变量在 SteamNetConnectionRealTimeStatus_t 中。
		public int m_cbPendingUnreliable;
		public int m_cbPendingReliable;
		public int m_cbSentUnackedReliable;
		public int _reservePad1; // Reserved for future use 保留用于未来使用。
		
		/// Lane-specific queue time.  This value takes into consideration lane priorities
		/// and weights, and how much data is queued in each lane, and attempts to predict
		/// how any data currently queued will be sent out.
		/// 车道特定排队时间。这个值会考虑车道的优先级和权重，以及每个车道中排队的多少数据，并尝试预测当前排队的任何数据将如何发送出去。
		public SteamNetworkingMicroseconds m_usecQueueTime;
		
		// Internal stuff, room to change API easily
		// 内部事务，有方便更改 API 的空间。
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 10)]
		public uint[] reserved;
	}

	//
	// Ping location / measurement
	//
	/// Object that describes a "location" on the Internet with sufficient
	/// detail that we can reasonably estimate an upper bound on the ping between
	/// the two hosts, even if a direct route between the hosts is not possible,
	/// and the connection must be routed through the Steam Datagram Relay network.
	/// This does not contain any information that identifies the host.  Indeed,
	/// if two hosts are in the same building or otherwise have nearly identical
	/// networking characteristics, then it's valid to use the same location
	/// object for both of them.
	///
	/// NOTE: This object should only be used in the same process!  Do not serialize it,
	/// send it over the wire, or persist it in a file or database!  If you need
	/// to do that, convert it to a string representation using the methods in
	/// ISteamNetworkingUtils().
	// 延迟位置 / 测量
// 一个描述互联网上某个位置的对象，具有足够的详细信息，可以合理地估计两个主机之间的上限延迟（ping），即使两个主机之间没有直接连接，并且连接必须通过Steam数据报中继网络进行路由。该对象不包含任何标识主机的相关信息。实际上，如果两个主机位于同一建筑物内或其他具有相似网络特征的地方，则可以为两者使用相同的location对象。
// 注意：这个对象只能在同一个进程中使用！不要序列化它，不要通过网络发送，也不要将其保存在文件或数据库中。如果需要这样做，请使用 ISteamNetworkingUtils() 中的方法将其转换为字符串表示形式。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	public struct SteamNetworkPingLocation_t {
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)]
		public byte[] m_data;
	}

}

#endif // !DISABLESTEAMWORKS
