// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
	#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	// callbacks
	//-----------------------------------------------------------------------------
	// Purpose: posted after the user gains ownership of DLC & that DLC is installed
	//-----------------------------------------------------------------------------
	// 回调函数
// 目的：在用户获得DLC所有权并安装该DLC后发布
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamAppsCallbacks + 5)]
	public struct DlcInstalled_t {
		public const int k_iCallback = Constants.k_iSteamAppsCallbacks + 5;
		public AppId_t m_nAppID;		// AppID of the DLC DLC的AppID
	}

	//---------------------------------------------------------------------------------
	// Purpose: posted after the user gains executes a Steam URL with command line or query parameters
	// such as steam://run/<appid>//-commandline/?param1=value1&param2=value2&param3=value3 etc
	// while the game is already running.  The new params can be queried
	// with GetLaunchQueryParam and GetLaunchCommandLine
	//---------------------------------------------------------------------------------
	// 目的：在用户获得执行权限后，执行 Steam URL，例如 steam://run/<appid>//-commandline/?param1=value1&param2=value2&param3=value3 等，同时游戏已经在运行。新的参数可以通过 GetLaunchQueryParam 和 GetLaunchCommandLine 获取。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamAppsCallbacks + 14)]
	public struct NewUrlLaunchParameters_t {
		public const int k_iCallback = Constants.k_iSteamAppsCallbacks + 14;
	}

	//-----------------------------------------------------------------------------
	// Purpose: response to RequestAppProofOfPurchaseKey/RequestAllProofOfPurchaseKeys
	// for supporting third-party CD keys, or other proof-of-purchase systems.
	//-----------------------------------------------------------------------------
	// 目的：响应 RequestAppProofOfPurchaseKey/RequestAllProofOfPurchaseKeys 请求，以支持第三方 CD 密钥或其他购买凭证系统。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamAppsCallbacks + 21)]
	public struct AppProofOfPurchaseKeyResponse_t {
		public const int k_iCallback = Constants.k_iSteamAppsCallbacks + 21;
		public EResult m_eResult;
		public uint m_nAppID;
		public uint m_cchKeyLength;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cubAppProofOfPurchaseKeyMax)]
		private byte[] m_rgchKey_;
		public string m_rgchKey
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchKey_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchKey_, Constants.k_cubAppProofOfPurchaseKeyMax); }
		}
	}

	//-----------------------------------------------------------------------------
	// Purpose: response to GetFileDetails
	//-----------------------------------------------------------------------------
	// 目的：响应 GetFileDetails
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamAppsCallbacks + 23)]
	public struct FileDetailsResult_t {
		public const int k_iCallback = Constants.k_iSteamAppsCallbacks + 23;
		public EResult m_eResult;
		public ulong m_ulFileSize;	// original file size in bytes 原始文件大小（字节）
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 20)]
		public byte[] m_FileSHA;	// original file SHA1 hash 原始文件 SHA1 哈希值
		public uint m_unFlags;		//
	}

	//-----------------------------------------------------------------------------
	// Purpose: called for games in Timed Trial mode
	//-----------------------------------------------------------------------------
	// 目的：呼吁在Timed Trial模式中的游戏
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamAppsCallbacks + 30)]
	public struct TimedTrialStatus_t {
		public const int k_iCallback = Constants.k_iSteamAppsCallbacks + 30;
		public AppId_t m_unAppID;			// appID 应用ID
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bIsOffline;		// if true, time allowed / played refers to offline time, not total time 如果为真，time allowed / played 指的是离线时间，而不是总时间。
		public uint m_unSecondsAllowed;	// how many seconds the app can be played in total 应用可以总共播放多少秒？
		public uint m_unSecondsPlayed;	// how many seconds the app was already played 该应用已经运行了多少秒？
	}

	// callbacks
	//-----------------------------------------------------------------------------
	// Purpose: called when a friends' status changes
	//-----------------------------------------------------------------------------
	// 回调函数
// 目的：当好友状态发生变化时调用
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 4)]
	public struct PersonaStateChange_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 4;
		
		public ulong m_ulSteamID;		// steamID of the friend who changed 朋友更改后的SteamID
		public EPersonaChange m_nChangeFlags;		// what's changed 发生了什么变化？
	}

	//-----------------------------------------------------------------------------
	// Purpose: posted when game overlay activates or deactivates
	//			the game can use this to be pause or resume single player games
	//-----------------------------------------------------------------------------
	// 目的：当游戏叠加激活或停用时发布此条目，可用于暂停或恢复单人游戏。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 31)]
	public struct GameOverlayActivated_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 31;
		public byte m_bActive;		// true if it's just been activated, false otherwise 如果是刚激活的，则为真；否则为假。
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bUserInitiated;	// true if the user asked for the overlay to be activated/deactivated 如果用户要求激活/停用叠加显示。
		public AppId_t m_nAppID;		// the appID of the game (should always be the current game) 游戏的 AppID (应始终为当前游戏)
		public uint m_dwOverlayPID;	// used internally 内部使用
	}

	//-----------------------------------------------------------------------------
	// Purpose: called when the user tries to join a different game server from their friends list
	//			game client should attempt to connect to specified server when this is received
	//-----------------------------------------------------------------------------
	// 目的：当用户从好友列表中尝试加入不同的游戏服务器时，客户端应尝试连接到指定服务器。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 32)]
	public struct GameServerChangeRequested_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 32;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
		private byte[] m_rgchServer_;
		public string m_rgchServer		// server address ("127.0.0.1:27015", "tf2.valvesoftware.com") 服务器地址 (“127.0.0.1:27015”, “tf2.valvesoftware.com”)
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchServer_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchServer_, 64); }
		}
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 64)]
		private byte[] m_rgchPassword_;
		public string m_rgchPassword	// server password, if any 服务器密码，如果存在
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchPassword_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchPassword_, 64); }
		}
	}

	//-----------------------------------------------------------------------------
	// Purpose: called when the user tries to join a lobby from their friends list
	//			game client should attempt to connect to specified lobby when this is received
	//-----------------------------------------------------------------------------
	// 目的：当用户从好友列表中尝试加入游戏大厅时，客户端应尝试连接到指定的大厅。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 33)]
	public struct GameLobbyJoinRequested_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 33;
		public CSteamID m_steamIDLobby;
		
		// The friend they did the join via (will be invalid if not directly via a friend)
		//
		// On PS3, the friend will be invalid if this was triggered by a PSN invite via the XMB, but
		// the account type will be console user so you can tell at least that this was from a PSN friend
		// rather than a Steam friend.
		// 他们通过(如果不是直接通过朋友)加入会失效。
	// 在PS3上，如果这个操作是通过XMB（主菜单）进行的PSN邀请触发的，则好友将失效；但账户类型仍然是“主机用户”，因此至少可以确定这是来自PSN好友而不是Steam好友。
		public CSteamID m_steamIDFriend;
	}

	//-----------------------------------------------------------------------------
	// Purpose: called when an avatar is loaded in from a previous GetLargeFriendAvatar() call
	//			if the image wasn't already available
	//-----------------------------------------------------------------------------
	// 目的：当从之前的 GetLargeFriendAvatar() 调用中加载头像时，如果图像尚未可用，则调用此函数。
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 34)]
	public struct AvatarImageLoaded_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 34;
		public CSteamID m_steamID; // steamid the avatar has been loaded for steamid 该头像已加载
		public int m_iImage; // the image index of the now loaded image 现在加载的图像的图像索引
		public int m_iWide; // width of the loaded image 加载图片的宽度
		public int m_iTall; // height of the loaded image 加载图像的高度
	}

	//-----------------------------------------------------------------------------
	// Purpose: marks the return of a request officer list call
	//-----------------------------------------------------------------------------
	// 目的：标记请求官员列表通话的返回
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 35)]
	public struct ClanOfficerListResponse_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 35;
		public CSteamID m_steamIDClan;
		public int m_cOfficers;
		public byte m_bSuccess;
	}

	//-----------------------------------------------------------------------------
	// Purpose: callback indicating updated data about friends rich presence information
	//-----------------------------------------------------------------------------
	// 目的：回调指示关于好友丰富度信息更新的数据
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 36)]
	public struct FriendRichPresenceUpdate_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 36;
		public CSteamID m_steamIDFriend;	// friend who's rich presence has changed 富有的朋友的存在改变了…
		public AppId_t m_nAppID;			// the appID of the game (should always be the current game) 游戏的App ID（应始终为当前游戏）
	}

	//-----------------------------------------------------------------------------
	// Purpose: called when the user tries to join a game from their friends list
	//			rich presence will have been set with the "connect" key which is set here
	//-----------------------------------------------------------------------------
	// 目的：当用户从好友列表中尝试加入游戏时调用。 丰富的存在状态（rich presence）将被设置为“connect”键，此处设置。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 37)]
	public struct GameRichPresenceJoinRequested_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 37;
		public CSteamID m_steamIDFriend;		// the friend they did the join via (will be invalid if not directly via a friend) 如果不是直接通过朋友，这个加入方式将失效。
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchMaxRichPresenceValueLength)]
		private byte[] m_rgchConnect_;
		public string m_rgchConnect
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchConnect_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchConnect_, Constants.k_cchMaxRichPresenceValueLength); }
		}
	}

	//-----------------------------------------------------------------------------
	// Purpose: a chat message has been received for a clan chat the game has joined
	//-----------------------------------------------------------------------------
	// 目的：收到一个氏族聊天消息，已加入游戏。
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 38)]
	public struct GameConnectedClanChatMsg_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 38;
		public CSteamID m_steamIDClanChat;
		public CSteamID m_steamIDUser;
		public int m_iMessageID;
	}

	//-----------------------------------------------------------------------------
	// Purpose: a user has joined a clan chat
	//-----------------------------------------------------------------------------
	// 目的：用户加入氏族聊天。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 39)]
	public struct GameConnectedChatJoin_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 39;
		public CSteamID m_steamIDClanChat;
		public CSteamID m_steamIDUser;
	}

	//-----------------------------------------------------------------------------
	// Purpose: a user has left the chat we're in
	//-----------------------------------------------------------------------------
	// 目的：一位用户离开了我们所在的聊天室。
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 40)]
	public struct GameConnectedChatLeave_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 40;
		public CSteamID m_steamIDClanChat;
		public CSteamID m_steamIDUser;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bKicked;		// true if admin kicked 如果管理员踢出
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bDropped;	// true if Steam connection dropped 如果Steam连接中断
	}

	//-----------------------------------------------------------------------------
	// Purpose: a DownloadClanActivityCounts() call has finished
	//-----------------------------------------------------------------------------
	// 目的：一个 DownloadClanActivityCounts() 调用已完成。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 41)]
	public struct DownloadClanActivityCountsResult_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 41;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bSuccess;
	}

	//-----------------------------------------------------------------------------
	// Purpose: a JoinClanChatRoom() call has finished
	//-----------------------------------------------------------------------------
	// 目的：一个 JoinClanChatRoom() 调用已完成。
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 42)]
	public struct JoinClanChatRoomCompletionResult_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 42;
		public CSteamID m_steamIDClanChat;
		public EChatRoomEnterResponse m_eChatRoomEnterResponse;
	}

	//-----------------------------------------------------------------------------
	// Purpose: a chat message has been received from a user
	//-----------------------------------------------------------------------------
	// 目的：收到用户发送的消息
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 43)]
	public struct GameConnectedFriendChatMsg_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 43;
		public CSteamID m_steamIDUser;
		public int m_iMessageID;
	}

	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 44)]
	public struct FriendsGetFollowerCount_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 44;
		public EResult m_eResult;
		public CSteamID m_steamID;
		public int m_nCount;
	}

	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 45)]
	public struct FriendsIsFollowing_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 45;
		public EResult m_eResult;
		public CSteamID m_steamID;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bIsFollowing;
	}

	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 46)]
	public struct FriendsEnumerateFollowingList_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 46;
		public EResult m_eResult;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cEnumerateFollowersMax)]
		public CSteamID[] m_rgSteamID;
		public int m_nResultsReturned;
		public int m_nTotalResultCount;
	}

	//-----------------------------------------------------------------------------
	// Purpose: reports the result of an attempt to change the user's persona name
	//-----------------------------------------------------------------------------
	// 目的：报告尝试更改用户个性化名称的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 47)]
	public struct SetPersonaNameResponse_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 47;
		
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bSuccess; // true if name change succeeded completely. 如果名称更改完全成功则返回true。
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bLocalSuccess; // true if name change was retained locally.  (We might not have been able to communicate with Steam) 如果名称更改已本地保留。 (我们可能无法与Steam通信)
		public EResult m_result; // detailed result code 详细结果代码
	}

	//-----------------------------------------------------------------------------
	// Purpose: Invoked when the status of unread messages changes
	//-----------------------------------------------------------------------------
	// 目的：当未读消息的状态发生变化时调用
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 48)]
	public struct UnreadChatMessagesChanged_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 48;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Dispatched when an overlay browser instance is navigated to a protocol/scheme registered by RegisterProtocolInOverlayBrowser()
	//-----------------------------------------------------------------------------
	// 目的：当一个覆盖层浏览器实例导航到一个通过 RegisterProtocolInOverlayBrowser() 注册的协议/方案时触发。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 49)]
	public struct OverlayBrowserProtocolNavigation_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 49;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 1024)]
		private byte[] rgchURI_;
		public string rgchURI
		{
			get { return InteropHelp.ByteArrayToStringUTF8(rgchURI_); }
			set { InteropHelp.StringToByteArrayUTF8(value, rgchURI_, 1024); }
		}
	}

	//-----------------------------------------------------------------------------
	// Purpose: A user's equipped profile items have changed
	//-----------------------------------------------------------------------------
	// 目的：用户的装备配置文件项已更改
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 50)]
	public struct EquippedProfileItemsChanged_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 50;
		public CSteamID m_steamID;
	}

	//-----------------------------------------------------------------------------
	// Purpose:
	//-----------------------------------------------------------------------------
	// 目的：
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamFriendsCallbacks + 51)]
	public struct EquippedProfileItems_t {
		public const int k_iCallback = Constants.k_iSteamFriendsCallbacks + 51;
		public EResult m_eResult;
		public CSteamID m_steamID;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bHasAnimatedAvatar;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bHasAvatarFrame;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bHasProfileModifier;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bHasProfileBackground;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bHasMiniProfileBackground;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bFromCache;
	}

	// callbacks
	// callback notification - A new message is available for reading from the message queue
	// 回调 回调通知 - 消息队列中有一个新的消息可供读取
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamGameCoordinatorCallbacks + 1)]
	public struct GCMessageAvailable_t {
		public const int k_iCallback = Constants.k_iSteamGameCoordinatorCallbacks + 1;
		public uint m_nMessageSize;
	}

	// callback notification - A message failed to make it to the GC. It may be down temporarily
	// 回调通知 - 消息未能到达 GC。它可能暂时不可用。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamGameCoordinatorCallbacks + 2)]
	public struct GCMessageFailed_t {
		public const int k_iCallback = Constants.k_iSteamGameCoordinatorCallbacks + 2;
	}

	// callbacks
	// client has been approved to connect to this game server
	// 回调客户端已批准连接到此游戏服务器。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamGameServerCallbacks + 1)]
	public struct GSClientApprove_t {
		public const int k_iCallback = Constants.k_iSteamGameServerCallbacks + 1;
		public CSteamID m_SteamID;			// SteamID of approved player 已批准玩家的SteamID
		public CSteamID m_OwnerSteamID;	// SteamID of original owner for game license 游戏许可证原始所有者的SteamID
	}

	// client has been denied to connection to this game server
	// 客户端被拒绝连接到此游戏服务器。
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	[CallbackIdentity(Constants.k_iSteamGameServerCallbacks + 2)]
	public struct GSClientDeny_t {
		public const int k_iCallback = Constants.k_iSteamGameServerCallbacks + 2;
		public CSteamID m_SteamID;
		public EDenyReason m_eDenyReason;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
		private byte[] m_rgchOptionalText_;
		public string m_rgchOptionalText
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchOptionalText_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchOptionalText_, 128); }
		}
	}

	// request the game server should kick the user
	// 请求服务器将用户踢下线
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	[CallbackIdentity(Constants.k_iSteamGameServerCallbacks + 3)]
	public struct GSClientKick_t {
		public const int k_iCallback = Constants.k_iSteamGameServerCallbacks + 3;
		public CSteamID m_SteamID;
		public EDenyReason m_eDenyReason;
	}

	// NOTE: callback values 4 and 5 are skipped because they are used for old deprecated callbacks,
	// do not reuse them here.
	// client achievement info
	// 注意：回调值 4 和 5 被跳过，因为它们用于旧的已弃用回调，这里不要重复使用它们。客户端成就信息
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamGameServerCallbacks + 6)]
	public struct GSClientAchievementStatus_t {
		public const int k_iCallback = Constants.k_iSteamGameServerCallbacks + 6;
		public ulong m_SteamID;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 128)]
		private byte[] m_pchAchievement_;
		public string m_pchAchievement
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_pchAchievement_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_pchAchievement_, 128); }
		}
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bUnlocked;
	}

	// received when the game server requests to be displayed as secure (VAC protected)
	// m_bSecure is true if the game server should display itself as secure to users, false otherwise
	// 收到请求，将游戏服务器显示为安全（VAC保护）时。m_bSecure 为 true 表示游戏服务器应将自身显示为安全给用户，否则为 false。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserCallbacks + 15)]
	public struct GSPolicyResponse_t {
		public const int k_iCallback = Constants.k_iSteamUserCallbacks + 15;
		public byte m_bSecure;
	}

	// GS gameplay stats info
	// 游戏玩法统计信息
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamGameServerCallbacks + 7)]
	public struct GSGameplayStats_t {
		public const int k_iCallback = Constants.k_iSteamGameServerCallbacks + 7;
		public EResult m_eResult;					// Result of the call 通话结果
		public int m_nRank;					// Overall rank of the server (0-based) 服务器总排名（0-基于）
		public uint m_unTotalConnects;			// Total number of clients who have ever connected to the server 所有曾经连接过服务器的客户端总数
		public uint m_unTotalMinutesPlayed;		// Total number of minutes ever played on the server 服务器上总共已玩分钟数
	}

	// send as a reply to RequestUserGroupStatus()
	// 回复 RequestUserGroupStatus()
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	[CallbackIdentity(Constants.k_iSteamGameServerCallbacks + 8)]
	public struct GSClientGroupStatus_t {
		public const int k_iCallback = Constants.k_iSteamGameServerCallbacks + 8;
		public CSteamID m_SteamIDUser;
		public CSteamID m_SteamIDGroup;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bMember;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bOfficer;
	}

	// Sent as a reply to GetServerReputation()
	// 作为对GetServerReputation()的回复
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamGameServerCallbacks + 9)]
	public struct GSReputation_t {
		public const int k_iCallback = Constants.k_iSteamGameServerCallbacks + 9;
		public EResult m_eResult;				// Result of the call; 通话结果；
		public uint m_unReputationScore;	// The reputation score for the game server 游戏服务器的声誉得分
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bBanned;				// True if the server is banned from the Steam 如果服务器在Steam上被禁封
										// master servers
		
		// The following members are only filled out if m_bBanned is true. They will all
		// be set to zero otherwise. Master server bans are by IP so it is possible to be
		// banned even when the score is good high if there is a bad server on another port.
		// This information can be used to determine which server is bad.
		
										// 主服务器：以下成员仅在 m_bBanned 为 true 时才会被填写。否则，所有成员都将设置为零。主服务器的封禁基于 IP 地址，即使分数很高，如果连接到其他端口的服务器有问题，也可能被封禁。此信息可用于确定哪个服务器有问题。
		public uint m_unBannedIP;		// The IP of the banned server 被封禁服务器的IP地址
		public ushort m_usBannedPort;		// The port of the banned server 被禁用的端口
		public ulong m_ulBannedGameID;	// The game ID the banned server is serving 该游戏ID是被禁用的服务器所使用的。
		public uint m_unBanExpires;		// Time the ban expires, expressed in the Unix epoch (seconds since 1/1/1970) 禁令失效时间，以 Unix 时间戳（1/1/1970 以来经过的秒数）表示。
	}

	// Sent as a reply to AssociateWithClan()
	// 作为回复 AssociateWithClan()
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamGameServerCallbacks + 10)]
	public struct AssociateWithClanResult_t {
		public const int k_iCallback = Constants.k_iSteamGameServerCallbacks + 10;
		public EResult m_eResult;				// Result of the call; 通话结果；
	}

	// Sent as a reply to ComputeNewPlayerCompatibility()
	// 作为回复 ComputeNewPlayerCompatibility()
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamGameServerCallbacks + 11)]
	public struct ComputeNewPlayerCompatibilityResult_t {
		public const int k_iCallback = Constants.k_iSteamGameServerCallbacks + 11;
		public EResult m_eResult;				// Result of the call; 通话结果；
		public int m_cPlayersThatDontLikeCandidate;
		public int m_cPlayersThatCandidateDoesntLike;
		public int m_cClanPlayersThatDontLikeCandidate;
		public CSteamID m_SteamIDCandidate;
	}

	// callbacks
	//-----------------------------------------------------------------------------
	// Purpose: called when the latests stats and achievements have been received
	//			from the server
	//-----------------------------------------------------------------------------
	// 回调函数
// 目的：当从服务器接收到最新的统计数据和成就时调用。
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	[CallbackIdentity(Constants.k_iSteamGameServerStatsCallbacks)]
	public struct GSStatsReceived_t {
		public const int k_iCallback = Constants.k_iSteamGameServerStatsCallbacks;
		public EResult m_eResult;		// Success / error fetching the stats 获取统计信息失败 / 成功
		public CSteamID m_steamIDUser;	// The user for whom the stats are retrieved for 为检索统计数据的用户
	}

	//-----------------------------------------------------------------------------
	// Purpose: result of a request to store the user stats for a game
	//-----------------------------------------------------------------------------
	// 目的：对游戏的用户统计数据进行存储的请求结果
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	[CallbackIdentity(Constants.k_iSteamGameServerStatsCallbacks + 1)]
	public struct GSStatsStored_t {
		public const int k_iCallback = Constants.k_iSteamGameServerStatsCallbacks + 1;
		public EResult m_eResult;		// success / error 成功 / 错误
		public CSteamID m_steamIDUser;	// The user for whom the stats were stored 为该用户存储的统计数据
	}

	//-----------------------------------------------------------------------------
	// Purpose: Callback indicating that a user's stats have been unloaded.
	//  Call RequestUserStats again to access stats for this user
	//-----------------------------------------------------------------------------
	// 目的：回调指示用户统计数据已卸载。为了访问该用户的统计数据，请再次调用 RequestUserStats。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserStatsCallbacks + 8)]
	public struct GSStatsUnloaded_t {
		public const int k_iCallback = Constants.k_iSteamUserStatsCallbacks + 8;
		public CSteamID m_steamIDUser;	// User whose stats have been unloaded 已卸载统计数据的用户
	}

	// callbacks
	//-----------------------------------------------------------------------------
	// Purpose: The browser is ready for use
	//-----------------------------------------------------------------------------
	// 回调函数
// 目的：浏览器已准备好使用
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 1)]
	public struct HTML_BrowserReady_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 1;
		public HHTMLBrowser unBrowserHandle; // this browser is now fully created and ready to navigate to pages 这个浏览器现在已完全创建并准备好浏览网页。
	}

	//-----------------------------------------------------------------------------
	// Purpose: the browser has a pending paint
	//-----------------------------------------------------------------------------
	// 目的：浏览器有未完成的绘制。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 2)]
	public struct HTML_NeedsPaint_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 2;
		public HHTMLBrowser unBrowserHandle; // the browser that needs the paint 需要油漆的浏览器
		public IntPtr pBGRA; // a pointer to the B8G8R8A8 data for this surface, valid until SteamAPI_RunCallbacks is next called 指向此表面上的 B8G8R8A8 数据的一个指针，在 SteamAPI_RunCallbacks 下次被调用时有效。
		public uint unWide; // the total width of the pBGRA texture pBGRA 纹理的总宽度
		public uint unTall; // the total height of the pBGRA texture pBGRA 纹理的总高度
		public uint unUpdateX; // the offset in X for the damage rect for this update 本次更新的 X 轴偏移量用于伤害矩形
		public uint unUpdateY; // the offset in Y for the damage rect for this update 本次更新的 Y 偏移量用于伤害矩形
		public uint unUpdateWide; // the width of the damage rect for this update 本次更新的损坏矩形宽度
		public uint unUpdateTall; // the height of the damage rect for this update 本次更新的伤害矩形高度
		public uint unScrollX; // the page scroll the browser was at when this texture was rendered 当该纹理渲染时，浏览器的滚动页是哪个。
		public uint unScrollY; // the page scroll the browser was at when this texture was rendered 当此纹理渲染时，浏览器的滚动页是哪个。
		public float flPageScale; // the page scale factor on this page when rendered 此页面的缩放比例
		public uint unPageSerial; // incremented on each new page load, you can use this to reject draws while navigating to new pages 在每次页面加载时递增，你可以使用它来拒绝在导航到新页面时进行的抽样。
	}

	//-----------------------------------------------------------------------------
	// Purpose: The browser wanted to navigate to a new page
	//   NOTE - you MUST call AllowStartRequest in response to this callback
	//-----------------------------------------------------------------------------
	// 目的：浏览器想要导航到新页面 注意 - 您必须在收到此回调时调用 AllowStartRequest
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 3)]
	public struct HTML_StartRequest_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 3;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface navigating 表面导航手柄
		public string pchURL; // the url they wish to navigate to 他们想要浏览的网址
		public string pchTarget; // the html link target type  (i.e _blank, _self, _parent, _top ) HTML 链接目标类型（即 _blank、_self、_parent、_top）
		public string pchPostData; // any posted data for the request 请求中任何已发布的数据
		[MarshalAs(UnmanagedType.I1)]
		public bool bIsRedirect; // true if this was a http/html redirect from the last load request 如果这是上一次加载请求的 HTTP/HTML 重定向，则为真。
	}

	//-----------------------------------------------------------------------------
	// Purpose: The browser has been requested to close due to user interaction (usually from a javascript window.close() call)
	//-----------------------------------------------------------------------------
	// 目的：浏览器由于用户交互（通常来自 JavaScript 的 window.close() 调用）而被要求关闭。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 4)]
	public struct HTML_CloseBrowser_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 4;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface Surface 的把手
	}

	//-----------------------------------------------------------------------------
	// Purpose: the browser is navigating to a new url
	//-----------------------------------------------------------------------------
	// 目的：浏览器正在导航到新的URL。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 5)]
	public struct HTML_URLChanged_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 5;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface navigating 表面导航手柄
		public string pchURL; // the url they wish to navigate to 他们想要浏览的网址
		public string pchPostData; // any posted data for the request 请求中任何已发布的数据
		[MarshalAs(UnmanagedType.I1)]
		public bool bIsRedirect; // true if this was a http/html redirect from the last load request 如果这是上一次加载请求的 HTTP/HTML 重定向，则为真。
		public string pchPageTitle; // the title of the page 页面标题
		[MarshalAs(UnmanagedType.I1)]
		public bool bNewNavigation; // true if this was from a fresh tab and not a click on an existing page 如果这是从新标签页打开的，而不是点击现有页面。
	}

	//-----------------------------------------------------------------------------
	// Purpose: A page is finished loading
	//-----------------------------------------------------------------------------
	// 目的：页面已完成加载
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 6)]
	public struct HTML_FinishedRequest_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 6;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface Surface 的把手
		public string pchURL; //
		public string pchPageTitle; //
	}

	//-----------------------------------------------------------------------------
	// Purpose: a request to load this url in a new tab
	//-----------------------------------------------------------------------------
	// 目的：请求在新标签页中加载此 URL
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 7)]
	public struct HTML_OpenLinkInNewTab_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 7;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface Surface 的把手
		public string pchURL; //
	}

	//-----------------------------------------------------------------------------
	// Purpose: the page has a new title now
	//-----------------------------------------------------------------------------
	// 目的：该页面现在有新的标题。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 8)]
	public struct HTML_ChangedTitle_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 8;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface Surface 的把手
		public string pchTitle; //
	}

	//-----------------------------------------------------------------------------
	// Purpose: results from a search
	//-----------------------------------------------------------------------------
	// 目的：来自搜索结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 9)]
	public struct HTML_SearchResults_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 9;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface Surface 的把手
		public uint unResults; //
		public uint unCurrentMatch; //
	}

	//-----------------------------------------------------------------------------
	// Purpose: page history status changed on the ability to go backwards and forward
	//-----------------------------------------------------------------------------
	// 目的：页面历史状态已更改，支持向后和向前浏览。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 10)]
	public struct HTML_CanGoBackAndForward_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 10;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface Surface 的把手
		[MarshalAs(UnmanagedType.I1)]
		public bool bCanGoBack; //
		[MarshalAs(UnmanagedType.I1)]
		public bool bCanGoForward; //
	}

	//-----------------------------------------------------------------------------
	// Purpose: details on the visibility and size of the horizontal scrollbar
	//-----------------------------------------------------------------------------
	// 目的：关于水平滚动条的可见性和大小的详细信息
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 11)]
	public struct HTML_HorizontalScroll_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 11;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface Surface 的把手
		public uint unScrollMax; //
		public uint unScrollCurrent; //
		public float flPageScale; //
		[MarshalAs(UnmanagedType.I1)]
		public bool bVisible; //
		public uint unPageSize; //
	}

	//-----------------------------------------------------------------------------
	// Purpose: details on the visibility and size of the vertical scrollbar
	//-----------------------------------------------------------------------------
	// 目的：关于垂直滚动条的可见性和大小的详细信息
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 12)]
	public struct HTML_VerticalScroll_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 12;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface Surface 的把手
		public uint unScrollMax; //
		public uint unScrollCurrent; //
		public float flPageScale; //
		[MarshalAs(UnmanagedType.I1)]
		public bool bVisible; //
		public uint unPageSize; //
	}

	//-----------------------------------------------------------------------------
	// Purpose: response to GetLinkAtPosition call
	//-----------------------------------------------------------------------------
	// 目的：响应 GetLinkAtPosition 调用
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 13)]
	public struct HTML_LinkAtPosition_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 13;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface Surface 的把手
		public uint x; // NOTE - Not currently set 注意 - 目前未设置
		public uint y; // NOTE - Not currently set 注意 - 目前未设置
		public string pchURL; //
		[MarshalAs(UnmanagedType.I1)]
		public bool bInput; //
		[MarshalAs(UnmanagedType.I1)]
		public bool bLiveLink; //
	}

	//-----------------------------------------------------------------------------
	// Purpose: show a Javascript alert dialog, call JSDialogResponse
	//   when the user dismisses this dialog (or right away to ignore it)
	//-----------------------------------------------------------------------------
	// 目的：显示一个 JavaScript 提示对话框，当用户关闭该对话框（或立即忽略它）时调用 JSDialogResponse。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 14)]
	public struct HTML_JSAlert_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 14;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface Surface 的把手
		public string pchMessage; //
	}

	//-----------------------------------------------------------------------------
	// Purpose: show a Javascript confirmation dialog, call JSDialogResponse
	//   when the user dismisses this dialog (or right away to ignore it)
	//-----------------------------------------------------------------------------
	// 目的：显示一个 JavaScript 确认对话框，当用户关闭该对话框（或立即忽略它）时，调用 JSDialogResponse。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 15)]
	public struct HTML_JSConfirm_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 15;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface Surface 的把手
		public string pchMessage; //
	}

	//-----------------------------------------------------------------------------
	// Purpose: when received show a file open dialog
	//   then call FileLoadDialogResponse with the file(s) the user selected.
	//-----------------------------------------------------------------------------
	// 目的：收到消息时，显示文件打开对话框，然后调用 FileLoadDialogResponse，传入用户选择的文件(们)。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 16)]
	public struct HTML_FileOpenDialog_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 16;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface Surface 的把手
		public string pchTitle; //
		public string pchInitialFile; //
	}

	//-----------------------------------------------------------------------------
	// Purpose: a new html window is being created.
	//
	// IMPORTANT NOTE: at this time, the API does not allow you to acknowledge or
	// render the contents of this new window, so the new window is always destroyed
	// immediately. The URL and other parameters of the new window are passed here
	// to give your application the opportunity to call CreateBrowser and set up
	// a new browser in response to the attempted popup, if you wish to do so.
	//-----------------------------------------------------------------------------
	// 目的：正在创建一个新的 HTML 窗口。
// 重要提示：目前，API 不允许您确认或渲染此新窗口的内容，因此新窗口会立即被销毁。新窗口的 URL 和其他参数会传递过来，以便您的应用程序有机会调用 CreateBrowser 并根据尝试弹窗的请求设置一个新的浏览器，如果您希望这样做的话。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 21)]
	public struct HTML_NewWindow_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 21;
		public HHTMLBrowser unBrowserHandle; // the handle of the current surface 当前表面的把手
		public string pchURL; // the page to load 加载的页面
		public uint unX; // the x pos into the page to display the popup 将x坐标放入页面以显示弹出窗口
		public uint unY; // the y pos into the page to display the popup 将y坐标移动到页面上显示弹窗。
		public uint unWide; // the total width of the pBGRA texture pBGRA 纹理的总宽度
		public uint unTall; // the total height of the pBGRA texture pBGRA 纹理的总高度
		public HHTMLBrowser unNewWindow_BrowserHandle_IGNORE;
	}

	//-----------------------------------------------------------------------------
	// Purpose: change the cursor to display
	//-----------------------------------------------------------------------------
	// 目的：更改光标以显示
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 22)]
	public struct HTML_SetCursor_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 22;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface Surface 的把手
		public uint eMouseCursor; // the EMouseCursor to display 显示 EMouseCursor
	}

	//-----------------------------------------------------------------------------
	// Purpose: informational message from the browser
	//-----------------------------------------------------------------------------
	// 目的：浏览器发出的信息提示
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 23)]
	public struct HTML_StatusText_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 23;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface Surface 的把手
		public string pchMsg; // the EMouseCursor to display 显示 EMouseCursor
	}

	//-----------------------------------------------------------------------------
	// Purpose: show a tooltip
	//-----------------------------------------------------------------------------
	// 目的：显示工具提示
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 24)]
	public struct HTML_ShowToolTip_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 24;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface Surface 的把手
		public string pchMsg; // the EMouseCursor to display 显示 EMouseCursor
	}

	//-----------------------------------------------------------------------------
	// Purpose: update the text of an existing tooltip
	//-----------------------------------------------------------------------------
	// 目的：更新现有工具提示的文本
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 25)]
	public struct HTML_UpdateToolTip_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 25;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface Surface 的把手
		public string pchMsg; // the EMouseCursor to display 显示 EMouseCursor
	}

	//-----------------------------------------------------------------------------
	// Purpose: hide the tooltip you are showing
	//-----------------------------------------------------------------------------
	// 目的：隐藏你正在显示的工具提示。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 26)]
	public struct HTML_HideToolTip_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 26;
		public HHTMLBrowser unBrowserHandle; // the handle of the surface Surface 的把手
	}

	//-----------------------------------------------------------------------------
	// Purpose: The browser has restarted due to an internal failure, use this new handle value
	//-----------------------------------------------------------------------------
	// 目的：由于内部错误，浏览器已重启，请使用此新句柄值。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTMLSurfaceCallbacks + 27)]
	public struct HTML_BrowserRestarted_t {
		public const int k_iCallback = Constants.k_iSteamHTMLSurfaceCallbacks + 27;
		public HHTMLBrowser unBrowserHandle; // this is the new browser handle after the restart 这是重启后新的浏览器窗口。
		public HHTMLBrowser unOldBrowserHandle; // the handle for the browser before the restart, if your handle was this then switch to using unBrowserHandle for API calls 在重启之前，为浏览器设置句柄，如果你的句柄是这样的，则切换到使用 unBrowserHandle 进行 API 调用。
	}

	// callbacks
	// 回调函数
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTTPCallbacks + 1)]
	public struct HTTPRequestCompleted_t {
		public const int k_iCallback = Constants.k_iSteamHTTPCallbacks + 1;
		
		// Handle value for the request that has completed.
		// 请求完成时的句柄值。
		public HTTPRequestHandle m_hRequest;
		
		// Context value that the user defined on the request that this callback is associated with, 0 if
		// no context value was set.
		// 与该回调关联的请求中用户定义的上下文值，如果未设置上下文值，则为0。
		public ulong m_ulContextValue;
		
		// This will be true if we actually got any sort of response from the server (even an error).
		// It will be false if we failed due to an internal error or client side network failure.
		// 如果服务器确实有任何响应（包括错误），则为真。如果由于内部错误或客户端网络故障而失败，则为假。
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bRequestSuccessful;
		
		// Will be the HTTP status code value returned by the server, k_EHTTPStatusCode200OK is the normal
		// OK response, if you get something else you probably need to treat it as a failure.
		// 将返回的 HTTP 状态码值，k_EHTTPStatusCode200OK 是正常的 OK 响应，如果得到其他值，你可能需要将其视为失败。
		public EHTTPStatusCode m_eStatusCode;
		
		public uint m_unBodySize; // Same as GetHTTPResponseBodySize() 与GetHTTPResponseBodySize()相同
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTTPCallbacks + 2)]
	public struct HTTPRequestHeadersReceived_t {
		public const int k_iCallback = Constants.k_iSteamHTTPCallbacks + 2;
		
		// Handle value for the request that has received headers.
		// 请求已接收头部值的句柄。
		public HTTPRequestHandle m_hRequest;
		
		// Context value that the user defined on the request that this callback is associated with, 0 if
		// no context value was set.
		// 与该回调关联的请求中用户定义的上下文值，如果未设置上下文值，则为0。
		public ulong m_ulContextValue;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamHTTPCallbacks + 3)]
	public struct HTTPRequestDataReceived_t {
		public const int k_iCallback = Constants.k_iSteamHTTPCallbacks + 3;
		
		// Handle value for the request that has received data.
		// 请求接收到的数据的句柄。
		public HTTPRequestHandle m_hRequest;
		
		// Context value that the user defined on the request that this callback is associated with, 0 if
		// no context value was set.
		// 与该回调关联的请求中用户定义的上下文值，如果未设置上下文值，则为0。
		public ulong m_ulContextValue;
		
		
		// Offset to provide to GetHTTPStreamingResponseBodyData to get this chunk of data
		// 提供给 GetHTTPStreamingResponseBodyData 的偏移量，以获取该数据块。
		public uint m_cOffset;
		
		// Size to provide to GetHTTPStreamingResponseBodyData to get this chunk of data
		// 提供给 GetHTTPStreamingResponseBodyData 的大小来获取这个数据块
		public uint m_cBytesReceived;
	}

	//-----------------------------------------------------------------------------
	// Purpose: called when a new controller has been connected, will fire once
	// per controller if multiple new controllers connect in the same frame
	//-----------------------------------------------------------------------------
	// 目的：当新控制器连接时调用，如果同一帧中连接了多个新控制器，则会一次触发一次。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamControllerCallbacks + 1)]
	public struct SteamInputDeviceConnected_t {
		public const int k_iCallback = Constants.k_iSteamControllerCallbacks + 1;
		public InputHandle_t m_ulConnectedDeviceHandle;	// Handle for device 设备句柄
	}

	//-----------------------------------------------------------------------------
	// Purpose: called when a new controller has been connected, will fire once
	// per controller if multiple new controllers connect in the same frame
	//-----------------------------------------------------------------------------
	// 目的：当新控制器连接时调用，如果同一帧中连接了多个新控制器，则会一次触发一次。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamControllerCallbacks + 2)]
	public struct SteamInputDeviceDisconnected_t {
		public const int k_iCallback = Constants.k_iSteamControllerCallbacks + 2;
		public InputHandle_t m_ulDisconnectedDeviceHandle;	// Handle for device 设备句柄
	}

	//-----------------------------------------------------------------------------
	// Purpose: called when a controller configuration has been loaded, will fire once
	// per controller per focus change for Steam Input enabled controllers
	//-----------------------------------------------------------------------------
	// 目的：当控制器配置已加载时调用，对于启用了 Steam Input 的控制器，每次焦点变化都会触发一次（每个控制器一次）。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamControllerCallbacks + 3)]
	public struct SteamInputConfigurationLoaded_t {
		public const int k_iCallback = Constants.k_iSteamControllerCallbacks + 3;
		public AppId_t m_unAppID;
		public InputHandle_t m_ulDeviceHandle;		// Handle for device 设备句柄
		public CSteamID m_ulMappingCreator;		// May differ from local user when using 可能与本地用户不同
												// an unmodified community or official config
												// 未修改的社区或官方配置
		public uint m_unMajorRevision;		// Binding revision from In-game Action File. 游戏内动作文件修订版
												// Same value as queried by GetDeviceBindingRevision
												// 与 GetDeviceBindingRevision 查询到的相同值
		public uint m_unMinorRevision;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bUsesSteamInputAPI;	// Does the configuration contain any Analog/Digital actions? 配置中包含任何模拟/数字动作吗？
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bUsesGamepadAPI;		// Does the configuration contain any Xinput bindings? 配置中包含任何 Xinput 绑定吗？
	}

	//-----------------------------------------------------------------------------
	// Purpose: called when controller gamepad slots change - on Linux/macOS these
	// slots are shared for all running apps.
	//-----------------------------------------------------------------------------
	// 目的：当控制器游戏手柄插槽更改时调用 - 在Linux/macOS上，这些插槽对所有正在运行的应用程序共享。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamControllerCallbacks + 4)]
	public struct SteamInputGamepadSlotChange_t {
		public const int k_iCallback = Constants.k_iSteamControllerCallbacks + 4;
		public AppId_t m_unAppID;
		public InputHandle_t m_ulDeviceHandle;		// Handle for device 设备句柄
		public ESteamInputType m_eDeviceType;			// Type of device 设备类型
		public int m_nOldGamepadSlot;		// Previous GamepadSlot - can be -1 controller doesn't uses gamepad bindings 之前的游戏手柄槽位 - 可以是 -1，控制器不使用手柄绑定
		public int m_nNewGamepadSlot;		// New Gamepad Slot - can be -1 controller doesn't uses gamepad bindings 新手柄插槽 - 可以是 -1 控制器不使用手柄绑定
	}

	// SteamInventoryResultReady_t callbacks are fired whenever asynchronous
	// results transition from "Pending" to "OK" or an error state. There will
	// always be exactly one callback per handle.
	// SteamInventoryResultReady_t 回调函数会在异步结果从“Pending”状态变为“OK”状态或错误状态时触发。每个句柄下始终只会有一个回调。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamInventoryCallbacks + 0)]
	public struct SteamInventoryResultReady_t {
		public const int k_iCallback = Constants.k_iSteamInventoryCallbacks + 0;
		public SteamInventoryResult_t m_handle;
		public EResult m_result;
	}

	// SteamInventoryFullUpdate_t callbacks are triggered when GetAllItems
	// successfully returns a result which is newer / fresher than the last
	// known result. (It will not trigger if the inventory hasn't changed,
	// or if results from two overlapping calls are reversed in flight and
	// the earlier result is already known to be stale/out-of-date.)
	// The normal ResultReady callback will still be triggered immediately
	// afterwards; this is an additional notification for your convenience.
	// SteamInventoryFullUpdate_t 回调会在 GetAllItems 成功返回比上次已知结果更新/新鲜的结果时触发。 (如果库存没有改变，或者两个重叠的调用结果被反转，并且较早的结果已经被已知为过时/过时，则不会触发。) 正常的 ResultReady 回调仍将在之后立即触发；这是一个额外的通知，方便您使用。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamInventoryCallbacks + 1)]
	public struct SteamInventoryFullUpdate_t {
		public const int k_iCallback = Constants.k_iSteamInventoryCallbacks + 1;
		public SteamInventoryResult_t m_handle;
	}

	// A SteamInventoryDefinitionUpdate_t callback is triggered whenever
	// item definitions have been updated, which could be in response to
	// LoadItemDefinitions() or any other async request which required
	// a definition update in order to process results from the server.
	// 当物品定义被更新时，会触发一个SteamInventoryDefinitionUpdate_t回调，这可能是由于LoadItemDefinitions()或其他任何异步请求，为了处理来自服务器的结果而需要进行定义更新。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamInventoryCallbacks + 2)]
	public struct SteamInventoryDefinitionUpdate_t {
		public const int k_iCallback = Constants.k_iSteamInventoryCallbacks + 2;
	}

	// Returned
	// 已退回
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamInventoryCallbacks + 3)]
	public struct SteamInventoryEligiblePromoItemDefIDs_t {
		public const int k_iCallback = Constants.k_iSteamInventoryCallbacks + 3;
		public EResult m_result;
		public CSteamID m_steamID;
		public int m_numEligiblePromoItemDefs;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bCachedData;	// indicates that the data was retrieved from the cache and not the server 表明数据是从缓存中获取的，而不是从服务器。
	}

	// Triggered from StartPurchase call
	// 从 StartPurchase 调用触发
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamInventoryCallbacks + 4)]
	public struct SteamInventoryStartPurchaseResult_t {
		public const int k_iCallback = Constants.k_iSteamInventoryCallbacks + 4;
		public EResult m_result;
		public ulong m_ulOrderID;
		public ulong m_ulTransID;
	}

	// Triggered from RequestPrices
	// 从请求价格触发
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamInventoryCallbacks + 5)]
	public struct SteamInventoryRequestPricesResult_t {
		public const int k_iCallback = Constants.k_iSteamInventoryCallbacks + 5;
		public EResult m_result;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
		private byte[] m_rgchCurrency_;
		public string m_rgchCurrency
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchCurrency_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchCurrency_, 4); }
		}
	}

	//-----------------------------------------------------------------------------
	// Callbacks for ISteamMatchmaking (which go through the regular Steam callback registration system)
	//-----------------------------------------------------------------------------
	// Purpose: a server was added/removed from the favorites list, you should refresh now
	//-----------------------------------------------------------------------------
	// 通过常规 Steam 回调注册系统提供的 ISteamMatchmaking 回调
// 目的：从收藏列表中添加/删除服务器，请刷新一下。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMatchmakingCallbacks + 2)]
	public struct FavoritesListChanged_t {
		public const int k_iCallback = Constants.k_iSteamMatchmakingCallbacks + 2;
		public uint m_nIP; // an IP of 0 means reload the whole list, any other value means just one server 一个 IP 为 0 表示重新加载整个列表，任何其他值都只加载一个服务器。
		public uint m_nQueryPort;
		public uint m_nConnPort;
		public uint m_nAppID;
		public uint m_nFlags;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bAdd; // true if this is adding the entry, otherwise it is a remove 如果这是添加条目，则为真，否则为假。
		public AccountID_t m_unAccountId;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Someone has invited you to join a Lobby
	//			normally you don't need to do anything with this, since
	//			the Steam UI will also display a '<user> has invited you to the lobby, join?' dialog
	//
	//			if the user outside a game chooses to join, your game will be launched with the parameter "+connect_lobby <64-bit lobby id>",
	//			or with the callback GameLobbyJoinRequested_t if they're already in-game
	//-----------------------------------------------------------------------------
	// 目的：有人邀请你加入一个Lobby，通常你不需要为此做任何事情，因为Steam UI也会显示一个'<user>邀请你加入Lobby，是否加入？'对话框。
// 如果玩家在游戏外选择加入，你的游戏将使用 "+connect_lobby <64-bit lobby id>" 参数启动，或者如果他们已经在游戏中，则使用 GameLobbyJoinRequested_t 回调函数。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMatchmakingCallbacks + 3)]
	public struct LobbyInvite_t {
		public const int k_iCallback = Constants.k_iSteamMatchmakingCallbacks + 3;
		
		public ulong m_ulSteamIDUser;		// Steam ID of the person making the invite 邀请人的Steam ID
		public ulong m_ulSteamIDLobby;	// Steam ID of the Lobby Steam 房间 ID
		public ulong m_ulGameID;			// GameID of the Lobby 游戏ID（Lobby）
	}

	//-----------------------------------------------------------------------------
	// Purpose: Sent on entering a lobby, or on failing to enter
	//			m_EChatRoomEnterResponse will be set to k_EChatRoomEnterResponseSuccess on success,
	//			or a higher value on failure (see enum EChatRoomEnterResponse)
	//-----------------------------------------------------------------------------
	// 目的：在进入大厅时发送，或如果未能进入，`m_EChatRoomEnterResponse` 将设置为 `k_EChatRoomEnterResponseSuccess` 成功时，或在失败时设置为更高值（参见 `EChatRoomEnterResponse` 枚举）。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMatchmakingCallbacks + 4)]
	public struct LobbyEnter_t {
		public const int k_iCallback = Constants.k_iSteamMatchmakingCallbacks + 4;
		
		public ulong m_ulSteamIDLobby;							// SteamID of the Lobby you have entered 进入的房间的SteamID
		public uint m_rgfChatPermissions;						// Permissions of the current user 当前用户的权限
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bLocked;										// If true, then only invited users may join 如果为真，则只有邀请用户才能加入。
		public uint m_EChatRoomEnterResponse;	// EChatRoomEnterResponse EChatRoomEnterResponse
	}

	//-----------------------------------------------------------------------------
	// Purpose: The lobby metadata has changed
	//			if m_ulSteamIDMember is the steamID of a lobby member, use GetLobbyMemberData() to access per-user details
	//			if m_ulSteamIDMember == m_ulSteamIDLobby, use GetLobbyData() to access lobby metadata
	//-----------------------------------------------------------------------------
	// 目的：如果 m_ulSteamIDMember 是一个游戏大厅成员的 steamID，则使用 GetLobbyMemberData() 函数来访问每位用户的详细信息。如果 m_ulSteamIDMember 等于 m_ulSteamIDLobby，则使用 GetLobbyData() 函数来访问游戏大厅元数据。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMatchmakingCallbacks + 5)]
	public struct LobbyDataUpdate_t {
		public const int k_iCallback = Constants.k_iSteamMatchmakingCallbacks + 5;
		
		public ulong m_ulSteamIDLobby;		// steamID of the Lobby Lobby的SteamID
		public ulong m_ulSteamIDMember;		// steamID of the member whose data changed, or the room itself 成员数据的更改的SteamID，或房间本身
		public byte m_bSuccess;				// true if we lobby data was successfully changed; 如果游说数据成功更改，则为真。
										// will only be false if RequestLobbyData() was called on a lobby that no longer exists
										// 只有在 RequestLobbyData() 被调用于不存在的房间时，才会返回错误。
	}

	//-----------------------------------------------------------------------------
	// Purpose: The lobby chat room state has changed
	//			this is usually sent when a user has joined or left the lobby
	//-----------------------------------------------------------------------------
	// 目的：聊天室状态已更改，通常在用户加入或离开时发送。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMatchmakingCallbacks + 6)]
	public struct LobbyChatUpdate_t {
		public const int k_iCallback = Constants.k_iSteamMatchmakingCallbacks + 6;
		
		public ulong m_ulSteamIDLobby;			// Lobby ID Lobby ID
		public ulong m_ulSteamIDUserChanged;		// user who's status in the lobby just changed - can be recipient 用户状态在大厅中发生了变化 - 可以是收件人
		public ulong m_ulSteamIDMakingChange;		// Chat member who made the change (different from SteamIDUserChange if kicking, muting, etc.) 聊天成员，该更改者（不同于踢出、静音等操作的 SteamIDUserChange）
											// for example, if one user kicks another from the lobby, this will be set to the id of the user who initiated the kick
											// 例如，如果一个用户将另一个用户从大厅踢出，则会将其设置为发起踢出操作的用户ID。
		public uint m_rgfChatMemberStateChange;	// bitfield of EChatMemberStateChange values EChatMemberStateChange 值的位域
	}

	//-----------------------------------------------------------------------------
	// Purpose: A chat message for this lobby has been sent
	//			use GetLobbyChatEntry( m_iChatID ) to retrieve the contents of this message
	//-----------------------------------------------------------------------------
	// 目的：本大厅已发送一条聊天消息，使用 GetLobbyChatEntry( m_iChatID ) 可以检索该消息的内容。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMatchmakingCallbacks + 7)]
	public struct LobbyChatMsg_t {
		public const int k_iCallback = Constants.k_iSteamMatchmakingCallbacks + 7;
		
		public ulong m_ulSteamIDLobby;			// the lobby id this is in 这个房间的ID是这个
		public ulong m_ulSteamIDUser;			// steamID of the user who has sent this message 发送此消息的用户 SteamID
		public byte m_eChatEntryType;			// type of message 消息类型
		public uint m_iChatID;				// index of the chat entry to lookup 聊天条目的索引以进行查找
	}

	//-----------------------------------------------------------------------------
	// Purpose: A game created a game for all the members of the lobby to join,
	//			as triggered by a SetLobbyGameServer()
	//			it's up to the individual clients to take action on this; the usual
	//			game behavior is to leave the lobby and connect to the specified game server
	//-----------------------------------------------------------------------------
	// 目的：创建一个游戏，供房间内的所有成员参与，当调用 SetLobbyGameServer() 时，由各个客户端自行采取行动；通常的游戏行为是离开房间并连接到指定的游戏服务器。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMatchmakingCallbacks + 9)]
	public struct LobbyGameCreated_t {
		public const int k_iCallback = Constants.k_iSteamMatchmakingCallbacks + 9;
		
		public ulong m_ulSteamIDLobby;		// the lobby we were in 我们所在的休息区
		public ulong m_ulSteamIDGameServer;	// the new game server that has been created or found for the lobby members 新创建或发现的用于大厅成员的游戏服务器
		public uint m_unIP;					// IP & Port of the game server (if any) 游戏服务器的IP和端口（如果存在）
		public ushort m_usPort;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Number of matching lobbies found
	//			iterate the returned lobbies with GetLobbyByIndex(), from values 0 to m_nLobbiesMatching-1
	//-----------------------------------------------------------------------------
	// 目的：迭代返回的Lobby，通过调用GetLobbyByIndex()，从值0到m_nLobbiesMatching-1。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMatchmakingCallbacks + 10)]
	public struct LobbyMatchList_t {
		public const int k_iCallback = Constants.k_iSteamMatchmakingCallbacks + 10;
		public uint m_nLobbiesMatching;		// Number of lobbies that matched search criteria and we have SteamIDs for 匹配搜索条件的大厅数量，并且我们有SteamID为…
	}

	//-----------------------------------------------------------------------------
	// Purpose: posted if a user is forcefully removed from a lobby
	//			can occur if a user loses connection to Steam
	//-----------------------------------------------------------------------------
	// 目的：当用户被强制从游戏大厅中移除时出现，可能发生在用户与Steam失去连接时。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMatchmakingCallbacks + 12)]
	public struct LobbyKicked_t {
		public const int k_iCallback = Constants.k_iSteamMatchmakingCallbacks + 12;
		public ulong m_ulSteamIDLobby;			// Lobby Lobby
		public ulong m_ulSteamIDAdmin;			// User who kicked you - possibly the ID of the lobby itself 用户踢你 - 可能就是游戏大厅的ID本身
		public byte m_bKickedDueToDisconnect;		// true if you were kicked from the lobby due to the user losing connection to Steam (currently always true) 如果因用户断开与Steam的连接而被踢出大厅，则为真（目前始终为真）
	}

	//-----------------------------------------------------------------------------
	// Purpose: Result of our request to create a Lobby
	//			m_eResult == k_EResultOK on success
	//			at this point, the lobby has been joined and is ready for use
	//			a LobbyEnter_t callback will also be received (since the local user is joining their own lobby)
	//-----------------------------------------------------------------------------
	// 目的：请求创建Lobby m_eResult == k_EResultOK 的结果。 在此成功后，Lobby已加入并已准备好使用。 还会收到LobbyEnter_t回调（因为本地用户正在加入他们自己的Lobby）
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMatchmakingCallbacks + 13)]
	public struct LobbyCreated_t {
		public const int k_iCallback = Constants.k_iSteamMatchmakingCallbacks + 13;
		
		public EResult m_eResult;		// k_EResultOK - the lobby was successfully created k_EResultOK - 房间创建成功
								// k_EResultNoConnection - your Steam client doesn't have a connection to the back-end
								// k_EResultTimeout - you the message to the Steam servers, but it didn't respond
								// k_EResultFail - the server responded, but with an unknown internal error
								// k_EResultAccessDenied - your game isn't set to allow lobbies, or your client does haven't rights to play the game
								// k_EResultLimitExceeded - your game client has created too many lobbies
		
								// k_EResultNoConnection - 你的Steam客户端与后端没有连接 k_EResultTimeout - 你的消息已发送到Steam服务器，但未收到响应 k_EResultFail - 服务器已响应，但存在未知内部错误 k_EResultAccessDenied - 你的游戏未设置为允许创建公会，或者你的客户端没有权限玩游戏 k_EResultLimitExceeded - 你的游戏客户端已创建过多公会
		public ulong m_ulSteamIDLobby;		// chat room, zero if failed 聊天室, 失败则为零
	}

	//-----------------------------------------------------------------------------
	// Purpose: Result of our request to create a Lobby
	//			m_eResult == k_EResultOK on success
	//			at this point, the lobby has been joined and is ready for use
	//			a LobbyEnter_t callback will also be received (since the local user is joining their own lobby)
	//-----------------------------------------------------------------------------
	// 目的：请求创建Lobby m_eResult == k_EResultOK 的结果。 在此成功后，Lobby已加入并可用于使用。 还会收到LobbyEnter_t回调（因为本地用户正在加入他们自己的Lobby）
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMatchmakingCallbacks + 16)]
	public struct FavoritesListAccountsUpdated_t {
		public const int k_iCallback = Constants.k_iSteamMatchmakingCallbacks + 16;
		
		public EResult m_eResult;
	}

	//-----------------------------------------------------------------------------
	// Callbacks for ISteamGameSearch (which go through the regular Steam callback registration system)
	// 对于 ISteamGameSearch 的回调（通过常规 Steam 回调注册系统）
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamGameSearchCallbacks + 1)]
	public struct SearchForGameProgressCallback_t {
		public const int k_iCallback = Constants.k_iSteamGameSearchCallbacks + 1;
		
		public ulong m_ullSearchID;	// all future callbacks referencing this search will include this Search ID 所有未来的回调函数都将包含此搜索 ID。
		
		public EResult m_eResult; // if search has started this result will be k_EResultOK, any other value indicates search has failed to start or has terminated 如果搜索已启动，则结果将为 k_EResultOK，任何其他值表示搜索启动失败或已终止。
		public CSteamID m_lobbyID; // lobby ID if lobby search, invalid steamID otherwise Lobby ID 如果 Lobby 搜索无效，否则为 SteamID
		public CSteamID m_steamIDEndedSearch; // if search was terminated, steamID that terminated search 如果搜索被终止，终止搜索的SteamID
		
		public int m_nSecondsRemainingEstimate;
		public int m_cPlayersSearching;
	}

	// notification to all players searching that a game has been found
	// 所有玩家搜索到游戏时收到通知
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamGameSearchCallbacks + 2)]
	public struct SearchForGameResultCallback_t {
		public const int k_iCallback = Constants.k_iSteamGameSearchCallbacks + 2;
		
		public ulong m_ullSearchID;
		
		public EResult m_eResult; // if game/host was lost this will be an error value 如果游戏/主机丢失，这将是一个错误值
		
		// if m_bGameFound is true the following are non-zero
		// 如果 m_bGameFound 为真，则以下值不为零
		public int m_nCountPlayersInGame;
		public int m_nCountAcceptedGame;
		// if m_steamIDHost is valid the host has started the game
		// 如果 m_steamIDHost 有效，则主机已启动游戏
		public CSteamID m_steamIDHost;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bFinalCallback;
	}

	//-----------------------------------------------------------------------------
	// ISteamGameSearch : Game Host API callbacks
	// callback from RequestPlayersForGame when the matchmaking service has started or ended search
	// callback will also follow a call from CancelRequestPlayersForGame - m_bSearchInProgress will be false
	// ISteamGameSearch : Game Host API 回调，从 RequestPlayersForGame 调用中，当匹配服务开始或结束搜索时，也会跟随 CancelRequestPlayersForGame 的调用 - m_bSearchInProgress 将会为 false
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamGameSearchCallbacks + 11)]
	public struct RequestPlayersForGameProgressCallback_t {
		public const int k_iCallback = Constants.k_iSteamGameSearchCallbacks + 11;
		
		public EResult m_eResult;		// m_ullSearchID will be non-zero if this is k_EResultOK m_ullSearchID 如果这个值为 k_EResultOK，则会是非零值。
		public ulong m_ullSearchID; 	// all future callbacks referencing this search will include this Search ID 所有未来的回调函数都将包含此搜索 ID。
	}

	// callback from RequestPlayersForGame
	// one of these will be sent per player
	// followed by additional callbacks when players accept or decline the game
	// 从 RequestPlayersForGame 请求回收到一个回调，每个玩家会收到一个回调，随后在玩家接受或拒绝游戏时会收到额外的回调。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamGameSearchCallbacks + 12)]
	public struct RequestPlayersForGameResultCallback_t {
		public const int k_iCallback = Constants.k_iSteamGameSearchCallbacks + 12;
		
		public EResult m_eResult;		// m_ullSearchID will be non-zero if this is k_EResultOK m_ullSearchID 如果这个值为 k_EResultOK，则会是非零值。
		public ulong m_ullSearchID;
		
		public CSteamID m_SteamIDPlayerFound; // player steamID 玩家 SteamID
		public CSteamID m_SteamIDLobby;	// if the player is in a lobby, the lobby ID 如果玩家在Lobby中，则Lobby ID
		public PlayerAcceptState_t m_ePlayerAcceptState;
		public int m_nPlayerIndex;
		public int m_nTotalPlayersFound;		// expect this many callbacks at minimum 至少预期会有这么多的回访。
		public int m_nTotalPlayersAcceptedGame;
		public int m_nSuggestedTeamIndex;
		public ulong m_ullUniqueGameID;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamGameSearchCallbacks + 13)]
	public struct RequestPlayersForGameFinalResultCallback_t {
		public const int k_iCallback = Constants.k_iSteamGameSearchCallbacks + 13;
		
		public EResult m_eResult;
		public ulong m_ullSearchID;
		public ulong m_ullUniqueGameID;
	}

	// this callback confirms that results were received by the matchmaking service for this player
	// 这个回调确认该玩家已收到匹配服务的结果。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamGameSearchCallbacks + 14)]
	public struct SubmitPlayerResultResultCallback_t {
		public const int k_iCallback = Constants.k_iSteamGameSearchCallbacks + 14;
		
		public EResult m_eResult;
		public ulong ullUniqueGameID;
		public CSteamID steamIDPlayer;
	}

	// this callback confirms that the game is recorded as complete on the matchmaking service
	// the next call to RequestPlayersForGame will generate a new unique game ID
	// 这个回调确认游戏在匹配服务上已标记为完成。下一次调用 RequestPlayersForGame 将生成一个新的唯一游戏ID。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamGameSearchCallbacks + 15)]
	public struct EndGameResultCallback_t {
		public const int k_iCallback = Constants.k_iSteamGameSearchCallbacks + 15;
		
		public EResult m_eResult;
		public ulong ullUniqueGameID;
	}

	// Steam has responded to the user request to join a party via the given Beacon ID.
	// If successful, the connect string contains game-specific instructions to connect
	// to the game with that party.
	// Steam 已经响应了通过给定 Beacon ID 加入派对的用户请求。如果成功，连接字符串包含游戏特定的指令，用于连接到该派队中的游戏。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamPartiesCallbacks + 1)]
	public struct JoinPartyCallback_t {
		public const int k_iCallback = Constants.k_iSteamPartiesCallbacks + 1;
		
		public EResult m_eResult;
		public PartyBeaconID_t m_ulBeaconID;
		public CSteamID m_SteamIDBeaconOwner;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
		private byte[] m_rgchConnectString_;
		public string m_rgchConnectString
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchConnectString_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchConnectString_, 256); }
		}
	}

	// Response to CreateBeacon request. If successful, the beacon ID is provided.
	// 对 CreateBeacon 请求作出响应。如果成功，将提供 Beacon ID。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamPartiesCallbacks + 2)]
	public struct CreateBeaconCallback_t {
		public const int k_iCallback = Constants.k_iSteamPartiesCallbacks + 2;
		
		public EResult m_eResult;
		public PartyBeaconID_t m_ulBeaconID;
	}

	// Someone has used the beacon to join your party - they are in-flight now
	// and we've reserved one of the open slots for them.
	// You should confirm when they join your party by calling OnReservationCompleted().
	// Otherwise, Steam may timeout their reservation eventually.
	// 有人使用了传送锚点加入你的队伍 - 他们现在正在传送，我们已经为他们预留了一个空位。你应该在他们加入队伍时通过调用OnReservationCompleted()进行确认。否则，Steam可能会超时他们的预订。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamPartiesCallbacks + 3)]
	public struct ReservationNotificationCallback_t {
		public const int k_iCallback = Constants.k_iSteamPartiesCallbacks + 3;
		
		public PartyBeaconID_t m_ulBeaconID;
		public CSteamID m_steamIDJoiner;
	}

	// Response to ChangeNumOpenSlots call
	// 对 ChangeNumOpenSlots 调用
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamPartiesCallbacks + 4)]
	public struct ChangeNumOpenSlotsCallback_t {
		public const int k_iCallback = Constants.k_iSteamPartiesCallbacks + 4;
		
		public EResult m_eResult;
	}

	// The list of possible Party beacon locations has changed
	// 派对信号点可能位置列表已更改
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamPartiesCallbacks + 5)]
	public struct AvailableBeaconLocationsUpdated_t {
		public const int k_iCallback = Constants.k_iSteamPartiesCallbacks + 5;
	}

	// The list of active beacons may have changed
	// 活跃的信号器列表可能已更改
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamPartiesCallbacks + 6)]
	public struct ActiveBeaconsUpdated_t {
		public const int k_iCallback = Constants.k_iSteamPartiesCallbacks + 6;
	}

	// callbacks
	// 回调函数
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamMusicCallbacks + 1)]
	public struct PlaybackStatusHasChanged_t {
		public const int k_iCallback = Constants.k_iSteamMusicCallbacks + 1;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMusicCallbacks + 2)]
	public struct VolumeHasChanged_t {
		public const int k_iCallback = Constants.k_iSteamMusicCallbacks + 2;
		public float m_flNewVolume;
	}

	// callbacks
	// 回调
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamMusicRemoteCallbacks + 1)]
	public struct MusicPlayerRemoteWillActivate_t {
		public const int k_iCallback = Constants.k_iSteamMusicRemoteCallbacks + 1;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamMusicRemoteCallbacks + 2)]
	public struct MusicPlayerRemoteWillDeactivate_t {
		public const int k_iCallback = Constants.k_iSteamMusicRemoteCallbacks + 2;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamMusicRemoteCallbacks + 3)]
	public struct MusicPlayerRemoteToFront_t {
		public const int k_iCallback = Constants.k_iSteamMusicRemoteCallbacks + 3;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamMusicRemoteCallbacks + 4)]
	public struct MusicPlayerWillQuit_t {
		public const int k_iCallback = Constants.k_iSteamMusicRemoteCallbacks + 4;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamMusicRemoteCallbacks + 5)]
	public struct MusicPlayerWantsPlay_t {
		public const int k_iCallback = Constants.k_iSteamMusicRemoteCallbacks + 5;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamMusicRemoteCallbacks + 6)]
	public struct MusicPlayerWantsPause_t {
		public const int k_iCallback = Constants.k_iSteamMusicRemoteCallbacks + 6;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamMusicRemoteCallbacks + 7)]
	public struct MusicPlayerWantsPlayPrevious_t {
		public const int k_iCallback = Constants.k_iSteamMusicRemoteCallbacks + 7;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamMusicRemoteCallbacks + 8)]
	public struct MusicPlayerWantsPlayNext_t {
		public const int k_iCallback = Constants.k_iSteamMusicRemoteCallbacks + 8;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMusicRemoteCallbacks + 9)]
	public struct MusicPlayerWantsShuffled_t {
		public const int k_iCallback = Constants.k_iSteamMusicRemoteCallbacks + 9;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bShuffled;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMusicRemoteCallbacks + 10)]
	public struct MusicPlayerWantsLooped_t {
		public const int k_iCallback = Constants.k_iSteamMusicRemoteCallbacks + 10;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bLooped;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMusicCallbacks + 11)]
	public struct MusicPlayerWantsVolume_t {
		public const int k_iCallback = Constants.k_iSteamMusicCallbacks + 11;
		public float m_flNewVolume;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMusicCallbacks + 12)]
	public struct MusicPlayerSelectsQueueEntry_t {
		public const int k_iCallback = Constants.k_iSteamMusicCallbacks + 12;
		public int nID;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMusicCallbacks + 13)]
	public struct MusicPlayerSelectsPlaylistEntry_t {
		public const int k_iCallback = Constants.k_iSteamMusicCallbacks + 13;
		public int nID;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamMusicRemoteCallbacks + 14)]
	public struct MusicPlayerWantsPlayingRepeatStatus_t {
		public const int k_iCallback = Constants.k_iSteamMusicRemoteCallbacks + 14;
		public int m_nPlayingRepeatStatus;
	}

	// callbacks
	// callback notification - a user wants to talk to us over the P2P channel via the SendP2PPacket() API
	// in response, a call to AcceptP2PPacketsFromUser() needs to be made, if you want to talk with them
	// 回调通知 - 用户想通过 SendP2PPacket() API 在 P2P 通道上与我们联系，需要调用 AcceptP2PPacketsFromUser() 函数。如果你想与他们交流。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamNetworkingCallbacks + 2)]
	public struct P2PSessionRequest_t {
		public const int k_iCallback = Constants.k_iSteamNetworkingCallbacks + 2;
		public CSteamID m_steamIDRemote;			// user who wants to talk to us 想要和我们聊聊的用户
	}

	// callback notification - packets can't get through to the specified user via the SendP2PPacket() API
	// all packets queued packets unsent at this point will be dropped
	// further attempts to send will retry making the connection (but will be dropped if we fail again)
	// 回调通知 - 包裹无法通过 SendP2PPacket() API 传递到指定用户。所有排队的包裹将在此处被丢弃。再次尝试发送将重试连接（但如果再次失败则会断开连接）。
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	[CallbackIdentity(Constants.k_iSteamNetworkingCallbacks + 3)]
	public struct P2PSessionConnectFail_t {
		public const int k_iCallback = Constants.k_iSteamNetworkingCallbacks + 3;
		public CSteamID m_steamIDRemote;			// user we were sending packets to 我们正在发送数据包。
		public byte m_eP2PSessionError;			// EP2PSessionError indicating why we're having trouble EP2PSessionError 表示我们正在遇到问题的原因。
	}

	// callback notification - status of a socket has changed
	// used as part of the CreateListenSocket() / CreateP2PConnectionSocket()
	// 回调通知 - 套接字状态已改变，用于 CreateListenSocket() / CreateP2PConnectionSocket() 中。
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	[CallbackIdentity(Constants.k_iSteamNetworkingCallbacks + 1)]
	public struct SocketStatusCallback_t {
		public const int k_iCallback = Constants.k_iSteamNetworkingCallbacks + 1;
		public SNetSocket_t m_hSocket;				// the socket used to send/receive data to the remote host 用于向远程主机发送/接收数据的套接字
		public SNetListenSocket_t m_hListenSocket;	// this is the server socket that we were listening on; NULL if this was an outgoing connection 这是我们正在监听的服务器套接字；如果这是一个出站连接，则为NULL。
		public CSteamID m_steamIDRemote;			// remote steamID we have connected to, if it has one 已连接的远程 SteamID，如果有的话。
		public int m_eSNetSocketState;				// socket state, ESNetSocketState socket状态, ESNetSocketState
	}

	//
	// Callbacks
	//
	/// Posted when a remote host is sending us a message, and we do not already have a session with them
	// 回调函数
// 当一个远程主机向我们发送消息，且我们尚未与其建立会话时发布。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamNetworkingMessagesCallbacks + 1)]
	public struct SteamNetworkingMessagesSessionRequest_t {
		public const int k_iCallback = Constants.k_iSteamNetworkingMessagesCallbacks + 1;
		public SteamNetworkingIdentity m_identityRemote;			// user who wants to talk to us 想要和我们聊聊的用户
	}

	/// Posted when we fail to establish a connection, or we detect that communications
	/// have been disrupted it an unusual way.  There is no notification when a peer proactively
	/// closes the session.  ("Closed by peer" is not a concept of UDP-style communications, and
	/// SteamNetworkingMessages is primarily intended to make porting UDP code easy.)
	///
	/// Remember: callbacks are asynchronous.   See notes on SendMessageToUser,
	/// and k_nSteamNetworkingSend_AutoRestartBrokenSession in particular.
	///
	/// Also, if a session times out due to inactivity, no callbacks will be posted.  The only
	/// way to detect that this is happening is that querying the session state may return
	/// none, connecting, and findingroute again.
	/// 当我们未能建立连接，或者以某种不寻常的方式检测到通信中断时发布。当同伴主动关闭会话时不会有通知。“被同伴关闭”不是 UDP 风格通信的概念，SteamNetworkingMessages 主要旨在简化 UDP 代码的移植。
/// 记住：回调是异步的。请参阅 SendMessageToUser 和 k_nSteamNetworkingSend_AutoRestartBrokenSession 相关的说明。
/// 此外，如果由于无操作会话超时，则不会发布任何回调。检测这种情况下唯一的方法是查询会话状态可能返回空值、连接或重新查找route。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamNetworkingMessagesCallbacks + 2)]
	public struct SteamNetworkingMessagesSessionFailed_t {
		public const int k_iCallback = Constants.k_iSteamNetworkingMessagesCallbacks + 2;
		
		/// Detailed info about the session that failed.
		/// SteamNetConnectionInfo_t::m_identityRemote indicates who this session
		/// was with.
		/// 关于该会话失败的详细信息。SteamNetConnectionInfo_t::m_identityRemote 指示该会话与谁进行中的。
		public SteamNetConnectionInfo_t m_info;
	}

	/// Callback struct used to notify when a connection has changed state
	/// This callback is posted whenever a connection is created, destroyed, or changes state.
	/// The m_info field will contain a complete description of the connection at the time the
	/// change occurred and the callback was posted.  In particular, m_eState will have the
	/// new connection state.
	///
	/// You will usually need to listen for this callback to know when:
	/// - A new connection arrives on a listen socket.
	///   m_info.m_hListenSocket will be set, m_eOldState = k_ESteamNetworkingConnectionState_None,
	///   and m_info.m_eState = k_ESteamNetworkingConnectionState_Connecting.
	///   See ISteamNetworkigSockets::AcceptConnection.
	/// - A connection you initiated has been accepted by the remote host.
	///   m_eOldState = k_ESteamNetworkingConnectionState_Connecting, and
	///   m_info.m_eState = k_ESteamNetworkingConnectionState_Connected.
	///   Some connections might transition to k_ESteamNetworkingConnectionState_FindingRoute first.
	/// - A connection has been actively rejected or closed by the remote host.
	///   m_eOldState = k_ESteamNetworkingConnectionState_Connecting or k_ESteamNetworkingConnectionState_Connected,
	///   and m_info.m_eState = k_ESteamNetworkingConnectionState_ClosedByPeer.  m_info.m_eEndReason
	///   and m_info.m_szEndDebug will have for more details.
	///   NOTE: upon receiving this callback, you must still destroy the connection using
	///   ISteamNetworkingSockets::CloseConnection to free up local resources.  (The details
	///   passed to the function are not used in this case, since the connection is already closed.)
	/// - A problem was detected with the connection, and it has been closed by the local host.
	///   The most common failure is timeout, but other configuration or authentication failures
	///   can cause this.  m_eOldState = k_ESteamNetworkingConnectionState_Connecting or
	///   k_ESteamNetworkingConnectionState_Connected, and m_info.m_eState = k_ESteamNetworkingConnectionState_ProblemDetectedLocally.
	///   m_info.m_eEndReason and m_info.m_szEndDebug will have for more details.
	///   NOTE: upon receiving this callback, you must still destroy the connection using
	///   ISteamNetworkingSockets::CloseConnection to free up local resources.  (The details
	///   passed to the function are not used in this case, since the connection is already closed.)
	///
	/// Remember that callbacks are posted to a queue, and networking connections can
	/// change at any time.  It is possible that the connection has already changed
	/// state by the time you process this callback.
	///
	/// Also note that callbacks will be posted when connections are created and destroyed by your own API calls.
	/// 回调结构用于在连接状态发生变化时通知。此回调会在连接创建、销毁或状态发生变化时发布。m_info 字段将包含在状态发生变化时以及回调发布时连接的完整描述信息。特别是，m_eState 将包含新的连接状态。
/// 你通常需要监听这个回调以了解以下情况：  - 新连接到达监听套接字时。`m_info.m_hListenSocket` 将被设置，`m_eOldState` 设置为 `k_ESteamNetworkingConnectionState_None`，`m_info.m_eState` 设置为 `k_ESteamNetworkingConnectionState_Connecting`。请参考 `ISteamNetworkigSockets::AcceptConnection`。 - 你发起连接后，远程主机已接受该连接。`m_eOldState` 设置为 `k_ESteamNetworkingConnectionState_Connecting`，`m_info.m_eState` 设置为 `k_ESteamNetworkingConnectionState_Connected`。某些连接可能会先过渡到 `k_ESteamNetworkingConnectionState_FindingRoute`。 - 远程主机主动拒绝或关闭了该连接。`m_eOldState` 设置为 `k_ESteamNetworkingConnectionState_Connecting` 或 `k_ESteamNetworkingConnectionState_Connected`，`m_info.m_eState` 设置为 `k_ESteamNetworkingConnectionState_ClosedByPeer`。`m_info.m_eEndReason` 和 `m_info.m_szEndDebug` 包含更多详细信息。 注意：接收到此回调后，你仍然必须使用 `ISteamNetworkingSockets::CloseConnection` 关闭连接以释放本地资源。（此处的函数传递的细节在此时不被使用，因为连接已关闭。） - 检测到连接问题，并且本地主机已关闭该连接。最常见的故障是超时，但其他配置或身份验证失败也可能导致此问题。`m_eOldState` 设置为 `k_ESteamNetworkingConnectionState_Connecting` 或 `k_ESteamNetworkingConnectionState_Connected`，`m_info.m_eState` 设置为 `k_ESteamNetworkingConnectionState_ProblemDetectedLocally`。`m_info.m_eEndReason` 和 `m_info.m_szEndDebug` 包含更多详细信息。 注意：接收到此回调后，你仍然必须使用 `ISteamNetworkingSockets::CloseConnection` 关闭连接以释放本地资源。（此处的函数传递的细节在此时不被使用，因为连接已关闭。）
/// 请记住，回调被发布到队列中，并且网络连接随时可能改变。 此时处理回调时，连接状态可能已经改变。
/// 请注意，连接创建和销毁时，你的API调用也会发布回调。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamNetworkingSocketsCallbacks + 1)]
	public struct SteamNetConnectionStatusChangedCallback_t {
		public const int k_iCallback = Constants.k_iSteamNetworkingSocketsCallbacks + 1;
		
		/// Connection handle
		/// 连接句柄
		public HSteamNetConnection m_hConn;
		
		/// Full connection info
		/// 完整连接信息
		public SteamNetConnectionInfo_t m_info;
		
		/// Previous state.  (Current state is in m_info.m_eState)
		/// 先前状态。(当前状态在 m_info.m_eState)
		public ESteamNetworkingConnectionState m_eOldState;
	}

	/// A struct used to describe our readiness to participate in authenticated,
	/// encrypted communication.  In order to do this we need:
	///
	/// - The list of trusted CA certificates that might be relevant for this
	///   app.
	/// - A valid certificate issued by a CA.
	///
	/// This callback is posted whenever the state of our readiness changes.
	/// 一个结构体，用于描述我们参与身份验证和加密通信的准备程度。为了做到这一点，我们需要：
/// - 信任的 CA 证书列表，可能与此应用相关。 - 一个由 CA 颁发的有效证书。
/// 这个回调会在我们准备状态改变时被发布。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamNetworkingSocketsCallbacks + 2)]
	public struct SteamNetAuthenticationStatus_t {
		public const int k_iCallback = Constants.k_iSteamNetworkingSocketsCallbacks + 2;
		
		/// Status
		/// 状态
		public ESteamNetworkingAvailability m_eAvail;
		
		/// Non-localized English language status.  For diagnostic/debugging
		/// purposes only.
		/// 非本地化英文语言状态。仅供诊断/调试用途。
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
		private byte[] m_debugMsg_;
		public string m_debugMsg
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_debugMsg_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_debugMsg_, 256); }
		}
	}

	/// A struct used to describe our readiness to use the relay network.
	/// To do this we first need to fetch the network configuration,
	/// which describes what POPs are available.
	/// 一个结构体，用于描述我们使用中继网络的准备状态。为此，我们首先需要获取网络配置，该配置描述了哪些 POPs 可用。
	[CallbackIdentity(Constants.k_iSteamNetworkingUtilsCallbacks + 1)]
	public struct SteamRelayNetworkStatus_t {
		public const int k_iCallback = Constants.k_iSteamNetworkingUtilsCallbacks + 1;
		
		/// Summary status.  When this is "current", initialization has
		/// completed.  Anything else means you are not ready yet, or
		/// there is a significant problem.
		/// 状态摘要。当此项为“current”，表示初始化已完成。其他任何值表示你尚未准备好，或者存在严重问题。
		public ESteamNetworkingAvailability m_eAvail;
		
		/// Nonzero if latency measurement is in progress (or pending,
		/// awaiting a prerequisite).
		/// 如果延迟测量正在进行中（或正在等待，等待先决条件）。
		public int m_bPingMeasurementInProgress;
		
		/// Status obtaining the network config.  This is a prerequisite
		/// for relay network access.
		///
		/// Failure to obtain the network config almost always indicates
		/// a problem with the local internet connection.
		/// 获取网络配置中。这是访问网络相关的先决条件。
	/// 未能获取网络配置几乎总是表明本地互联网连接存在问题。
		public ESteamNetworkingAvailability m_eAvailNetworkConfig;
		
		/// Current ability to communicate with ANY relay.  Note that
		/// the complete failure to communicate with any relays almost
		/// always indicates a problem with the local Internet connection.
		/// (However, just because you can reach a single relay doesn't
		/// mean that the local connection is in perfect health.)
		/// 当前能够与任何中继通信的能力。请注意，与任何中继完全无法通信几乎总是表明本地互联网连接存在问题。（但是，能够与单个中继通信并不意味着本地连接处于完美健康状态。）
		public ESteamNetworkingAvailability m_eAvailAnyRelay;
		
		/// Non-localized English language status.  For diagnostic/debugging
		/// purposes only.
		/// 非本地化英文语言状态。仅供诊断/调试用途。
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
		private byte[] m_debugMsg_;
		public string m_debugMsg
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_debugMsg_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_debugMsg_, 256); }
		}
	}

	//-----------------------------------------------------------------------------
	// Purpose: Callback for querying UGC
	//-----------------------------------------------------------------------------
	// 目的：回调函数用于查询 UGC
	[CallbackIdentity(Constants.k_ISteamParentalSettingsCallbacks + 1)]
	public struct SteamParentalSettingsChanged_t {
		public const int k_iCallback = Constants.k_ISteamParentalSettingsCallbacks + 1;
	}

	// callbacks
	// 回调函数
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemotePlayCallbacks + 1)]
	public struct SteamRemotePlaySessionConnected_t {
		public const int k_iCallback = Constants.k_iSteamRemotePlayCallbacks + 1;
		public RemotePlaySessionID_t m_unSessionID;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemotePlayCallbacks + 2)]
	public struct SteamRemotePlaySessionDisconnected_t {
		public const int k_iCallback = Constants.k_iSteamRemotePlayCallbacks + 2;
		public RemotePlaySessionID_t m_unSessionID;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemotePlayCallbacks + 3)]
	public struct SteamRemotePlayTogetherGuestInvite_t {
		public const int k_iCallback = Constants.k_iSteamRemotePlayCallbacks + 3;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 1024)]
		private byte[] m_szConnectURL_;
		public string m_szConnectURL
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_szConnectURL_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_szConnectURL_, 1024); }
		}
	}

	// callbacks
	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to FileShare()
	//-----------------------------------------------------------------------------
	// 回调函数
// 目的：对 FileShare() 函数调用的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 7)]
	public struct RemoteStorageFileShareResult_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 7;
		public EResult m_eResult;			// The result of the operation 操作的结果
		public UGCHandle_t m_hFile;		// The handle that can be shared with users and features 可与用户共享的柄和功能
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchFilenameMax)]
		private byte[] m_rgchFilename_;
		public string m_rgchFilename // The name of the file that was shared 共享的文件名
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchFilename_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchFilename_, Constants.k_cchFilenameMax); }
		}
	}

	// k_iSteamRemoteStorageCallbacks + 8 is deprecated! Do not reuse
	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to PublishFile()
	//-----------------------------------------------------------------------------
	// k_iSteamRemoteStorageCallbacks + 8 已被废弃！不要重复使用
// 目的：PublishFile() 函数的返回值
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 9)]
	public struct RemoteStoragePublishFileResult_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 9;
		public EResult m_eResult;				// The result of the operation. 操作的结果。
		public PublishedFileId_t m_nPublishedFileId;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bUserNeedsToAcceptWorkshopLegalAgreement;
	}

	// k_iSteamRemoteStorageCallbacks + 10 is deprecated! Do not reuse
	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to DeletePublishedFile()
	//-----------------------------------------------------------------------------
	// k_iSteamRemoteStorageCallbacks + 10 已被废弃！不要重复使用
// 目的：调用 DeletePublishedFile() 的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 11)]
	public struct RemoteStorageDeletePublishedFileResult_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 11;
		public EResult m_eResult;				// The result of the operation. 操作的结果。
		public PublishedFileId_t m_nPublishedFileId;
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to EnumerateUserPublishedFiles()
	//-----------------------------------------------------------------------------
	// 目的：调用 EnumerateUserPublishedFiles() 的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 12)]
	public struct RemoteStorageEnumerateUserPublishedFilesResult_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 12;
		public EResult m_eResult;				// The result of the operation. 操作的结果。
		public int m_nResultsReturned;
		public int m_nTotalResultCount;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_unEnumeratePublishedFilesMaxResults)]
		public PublishedFileId_t[] m_rgPublishedFileId;
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to SubscribePublishedFile()
	//-----------------------------------------------------------------------------
	// 目的：调用 SubscribePublishedFile() 的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 13)]
	public struct RemoteStorageSubscribePublishedFileResult_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 13;
		public EResult m_eResult;				// The result of the operation. 操作的结果。
		public PublishedFileId_t m_nPublishedFileId;
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to EnumerateSubscribePublishedFiles()
	//-----------------------------------------------------------------------------
	// 目的：调用 EnumerateSubscribePublishedFiles() 的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 14)]
	public struct RemoteStorageEnumerateUserSubscribedFilesResult_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 14;
		public EResult m_eResult;				// The result of the operation. 操作的结果。
		public int m_nResultsReturned;
		public int m_nTotalResultCount;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_unEnumeratePublishedFilesMaxResults)]
		public PublishedFileId_t[] m_rgPublishedFileId;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_unEnumeratePublishedFilesMaxResults)]
		public uint[] m_rgRTimeSubscribed;
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to UnsubscribePublishedFile()
	//-----------------------------------------------------------------------------
	// 目的：调用 UnsubscribePublishedFile() 的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 15)]
	public struct RemoteStorageUnsubscribePublishedFileResult_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 15;
		public EResult m_eResult;				// The result of the operation. 操作的结果。
		public PublishedFileId_t m_nPublishedFileId;
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to CommitPublishedFileUpdate()
	//-----------------------------------------------------------------------------
	// 目的：调用 CommitPublishedFileUpdate() 的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 16)]
	public struct RemoteStorageUpdatePublishedFileResult_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 16;
		public EResult m_eResult;				// The result of the operation. 操作的结果。
		public PublishedFileId_t m_nPublishedFileId;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bUserNeedsToAcceptWorkshopLegalAgreement;
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to UGCDownload()
	//-----------------------------------------------------------------------------
	// 目的：对UGCDownload()函数的调用结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 17)]
	public struct RemoteStorageDownloadUGCResult_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 17;
		public EResult m_eResult;				// The result of the operation. 操作的结果。
		public UGCHandle_t m_hFile;			// The handle to the file that was attempted to be downloaded. 下载尝试的文件句柄。
		public AppId_t m_nAppID;				// ID of the app that created this file. 该文件的创建应用ID。
		public int m_nSizeInBytes;			// The size of the file that was downloaded, in bytes. 下载的文件的大小，以字节为单位。
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchFilenameMax)]
		private byte[] m_pchFileName_;
		public string m_pchFileName		// The name of the file that was downloaded. 下载的文件名。
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_pchFileName_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_pchFileName_, Constants.k_cchFilenameMax); }
		}
		public ulong m_ulSteamIDOwner;		// Steam ID of the user who created this content. 该内容创建者的Steam ID。
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to GetPublishedFileDetails()
	//-----------------------------------------------------------------------------
	// 目的：调用 GetPublishedFileDetails() 的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 18)]
	public struct RemoteStorageGetPublishedFileDetailsResult_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 18;
		public EResult m_eResult;				// The result of the operation. 操作的结果。
		public PublishedFileId_t m_nPublishedFileId;
		public AppId_t m_nCreatorAppID;		// ID of the app that created this file. 该文件的创建应用ID。
		public AppId_t m_nConsumerAppID;		// ID of the app that will consume this file. 将消费此文件的应用程序的ID。
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchPublishedDocumentTitleMax)]
		private byte[] m_rgchTitle_;
		public string m_rgchTitle		// title of document 文档标题
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchTitle_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchTitle_, Constants.k_cchPublishedDocumentTitleMax); }
		}
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchPublishedDocumentDescriptionMax)]
		private byte[] m_rgchDescription_;
		public string m_rgchDescription	// description of document 文档描述
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchDescription_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchDescription_, Constants.k_cchPublishedDocumentDescriptionMax); }
		}
		public UGCHandle_t m_hFile;			// The handle of the primary file 主文件的句柄
		public UGCHandle_t m_hPreviewFile;		// The handle of the preview file 预览文件的柄
		public ulong m_ulSteamIDOwner;		// Steam ID of the user who created this content. 该内容创建者的Steam ID。
		public uint m_rtimeCreated;			// time when the published file was created 发布文件创建时间
		public uint m_rtimeUpdated;			// time when the published file was last updated 上次发布文件更新时间
		public ERemoteStoragePublishedFileVisibility m_eVisibility;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bBanned;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchTagListMax)]
		private byte[] m_rgchTags_;
		public string m_rgchTags	// comma separated list of all tags associated with this file 所有与此文件相关的标签，以逗号分隔
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchTags_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchTags_, Constants.k_cchTagListMax); }
		}
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bTagsTruncated;			// whether the list of tags was too long to be returned in the provided buffer 是否列表中的标签太长，无法在提供的缓冲区中返回。
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchFilenameMax)]
		private byte[] m_pchFileName_;
		public string m_pchFileName		// The name of the primary file 主要文件的名称
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_pchFileName_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_pchFileName_, Constants.k_cchFilenameMax); }
		}
		public int m_nFileSize;				// Size of the primary file 主文件大小
		public int m_nPreviewFileSize;		// Size of the preview file 预览文件大小
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchPublishedFileURLMax)]
		private byte[] m_rgchURL_;
		public string m_rgchURL	// URL (for a video or a website) URL (用于视频或网站)
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchURL_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchURL_, Constants.k_cchPublishedFileURLMax); }
		}
		public EWorkshopFileType m_eFileType;	// Type of the file 文件类型
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bAcceptedForUse;			// developer has specifically flagged this item as accepted in the Workshop 开发者已明确标记该项目在工作坊中已接受。
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 19)]
	public struct RemoteStorageEnumerateWorkshopFilesResult_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 19;
		public EResult m_eResult;
		public int m_nResultsReturned;
		public int m_nTotalResultCount;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_unEnumeratePublishedFilesMaxResults)]
		public PublishedFileId_t[] m_rgPublishedFileId;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_unEnumeratePublishedFilesMaxResults)]
		public float[] m_rgScore;
		public AppId_t m_nAppId;
		public uint m_unStartIndex;
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of GetPublishedItemVoteDetails
	//-----------------------------------------------------------------------------
	// 目的：GetPublishedItemVoteDetails的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 20)]
	public struct RemoteStorageGetPublishedItemVoteDetailsResult_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 20;
		public EResult m_eResult;
		public PublishedFileId_t m_unPublishedFileId;
		public int m_nVotesFor;
		public int m_nVotesAgainst;
		public int m_nReports;
		public float m_fScore;
	}

	//-----------------------------------------------------------------------------
	// Purpose: User subscribed to a file for the app (from within the app or on the web)
	//-----------------------------------------------------------------------------
	// 目的：用户订阅了应用程序的文件（从应用程序内部或在网页上）
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 21)]
	public struct RemoteStoragePublishedFileSubscribed_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 21;
		public PublishedFileId_t m_nPublishedFileId;	// The published file id 已发布的文件ID
		public AppId_t m_nAppID;						// ID of the app that will consume this file. 将消费此文件的应用程序的ID。
	}

	//-----------------------------------------------------------------------------
	// Purpose: User unsubscribed from a file for the app (from within the app or on the web)
	//-----------------------------------------------------------------------------
	// 目的：用户从应用（在应用内或在网页上）取消订阅文件。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 22)]
	public struct RemoteStoragePublishedFileUnsubscribed_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 22;
		public PublishedFileId_t m_nPublishedFileId;	// The published file id 已发布的文件ID
		public AppId_t m_nAppID;						// ID of the app that will consume this file. 将消费此文件的应用程序的ID。
	}

	//-----------------------------------------------------------------------------
	// Purpose: Published file that a user owns was deleted (from within the app or the web)
	//-----------------------------------------------------------------------------
	// 目的：用户拥有的已发布文件被删除（从应用内或网页中）
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 23)]
	public struct RemoteStoragePublishedFileDeleted_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 23;
		public PublishedFileId_t m_nPublishedFileId;	// The published file id 已发布的文件ID
		public AppId_t m_nAppID;						// ID of the app that will consume this file. 将消费此文件的应用程序的ID。
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to UpdateUserPublishedItemVote()
	//-----------------------------------------------------------------------------
	// 目的：调用 UpdateUserPublishedItemVote() 的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 24)]
	public struct RemoteStorageUpdateUserPublishedItemVoteResult_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 24;
		public EResult m_eResult;				// The result of the operation. 操作的结果。
		public PublishedFileId_t m_nPublishedFileId;	// The published file id 已发布的文件ID
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to GetUserPublishedItemVoteDetails()
	//-----------------------------------------------------------------------------
	// 目的：调用 GetUserPublishedItemVoteDetails() 的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 25)]
	public struct RemoteStorageUserVoteDetails_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 25;
		public EResult m_eResult;				// The result of the operation. 操作的结果。
		public PublishedFileId_t m_nPublishedFileId;	// The published file id 已发布的文件ID
		public EWorkshopVote m_eVote;			// what the user voted 用户投票的内容
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 26)]
	public struct RemoteStorageEnumerateUserSharedWorkshopFilesResult_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 26;
		public EResult m_eResult;				// The result of the operation. 操作的结果。
		public int m_nResultsReturned;
		public int m_nTotalResultCount;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_unEnumeratePublishedFilesMaxResults)]
		public PublishedFileId_t[] m_rgPublishedFileId;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 27)]
	public struct RemoteStorageSetUserPublishedFileActionResult_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 27;
		public EResult m_eResult;				// The result of the operation. 操作的结果。
		public PublishedFileId_t m_nPublishedFileId;	// The published file id 已发布的文件ID
		public EWorkshopFileAction m_eAction;	// the action that was attempted 所尝试的行动
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 28)]
	public struct RemoteStorageEnumeratePublishedFilesByUserActionResult_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 28;
		public EResult m_eResult;				// The result of the operation. 操作的结果。
		public EWorkshopFileAction m_eAction;	// the action that was filtered on 被过滤的动作
		public int m_nResultsReturned;
		public int m_nTotalResultCount;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_unEnumeratePublishedFilesMaxResults)]
		public PublishedFileId_t[] m_rgPublishedFileId;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_unEnumeratePublishedFilesMaxResults)]
		public uint[] m_rgRTimeUpdated;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Called periodically while a PublishWorkshopFile is in progress
	//-----------------------------------------------------------------------------
	// 目的：在 PublishWorkshopFile 正在进行时，周期性调用。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 29)]
	public struct RemoteStoragePublishFileProgress_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 29;
		public double m_dPercentFile;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bPreview;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Called when the content for a published file is updated
	//-----------------------------------------------------------------------------
	// 目的：当已发布文件的内容更新时调用
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 30)]
	public struct RemoteStoragePublishedFileUpdated_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 30;
		public PublishedFileId_t m_nPublishedFileId;	// The published file id 已发布的文件ID
		public AppId_t m_nAppID;						// ID of the app that will consume this file. 将消费此文件的应用程序的ID。
		public ulong m_ulUnused;						// not used anymore 不再使用
	}

	//-----------------------------------------------------------------------------
	// Purpose: Called when a FileWriteAsync completes
	//-----------------------------------------------------------------------------
	// 目的：当 FileWriteAsync 完成时调用
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 31)]
	public struct RemoteStorageFileWriteAsyncComplete_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 31;
		public EResult m_eResult;						// result 结果
	}

	//-----------------------------------------------------------------------------
	// Purpose: Called when a FileReadAsync completes
	//-----------------------------------------------------------------------------
	// 目的：当 FileReadAsync 完成时调用
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 32)]
	public struct RemoteStorageFileReadAsyncComplete_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 32;
		public SteamAPICall_t m_hFileReadAsync;		// call handle of the async read which was made 处理异步读取的调用
		public EResult m_eResult;						// result 结果
		public uint m_nOffset;						// offset in the file this read was at 文件读取的位置偏移量
		public uint m_cubRead;						// amount read - will the <= the amount requested 已读量 - 是否小于要求的数量
	}

	//-----------------------------------------------------------------------------
	// Purpose: one or more files for this app have changed locally after syncing
	//			to remote session changes
	//			Note: only posted if this happens DURING the local app session
	//-----------------------------------------------------------------------------
	// 目的：此应用中的一个或多个文件在同步到远程会话更改后本地更改了。注意：仅在这一过程发生在本地应用会话期间才会发布。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamRemoteStorageCallbacks + 33)]
	public struct RemoteStorageLocalFileChange_t {
		public const int k_iCallback = Constants.k_iSteamRemoteStorageCallbacks + 33;
	}

	// callbacks
	//-----------------------------------------------------------------------------
	// Purpose: Screenshot successfully written or otherwise added to the library
	// and can now be tagged
	//-----------------------------------------------------------------------------
	// 回调函数
// 目的：截图已成功写入或添加到库中，现在可以进行标记。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamScreenshotsCallbacks + 1)]
	public struct ScreenshotReady_t {
		public const int k_iCallback = Constants.k_iSteamScreenshotsCallbacks + 1;
		public ScreenshotHandle m_hLocal;
		public EResult m_eResult;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Screenshot has been requested by the user.  Only sent if
	// HookScreenshots() has been called, in which case Steam will not take
	// the screenshot itself.
	//-----------------------------------------------------------------------------
	// 目的：用户已请求截屏。仅在 HookScreenshots() 被调用时发送，此时Steam不会自行截取屏幕截图。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamScreenshotsCallbacks + 2)]
	public struct ScreenshotRequested_t {
		public const int k_iCallback = Constants.k_iSteamScreenshotsCallbacks + 2;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Callback for querying UGC
	//-----------------------------------------------------------------------------
	// 目的：回调函数用于查询 UGC
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamTimelineCallbacks + 1)]
	public struct SteamTimelineGamePhaseRecordingExists_t {
		public const int k_iCallback = Constants.k_iSteamTimelineCallbacks + 1;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchMaxPhaseIDLength)]
		private byte[] m_rgchPhaseID_;
		public string m_rgchPhaseID
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchPhaseID_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchPhaseID_, Constants.k_cchMaxPhaseIDLength); }
		}
		public ulong m_ulRecordingMS;
		public ulong m_ulLongestClipMS;
		public uint m_unClipCount;
		public uint m_unScreenshotCount;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Callback for querying UGC
	//-----------------------------------------------------------------------------
	// 目的：回调函数用于查询 UGC
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamTimelineCallbacks + 2)]
	public struct SteamTimelineEventRecordingExists_t {
		public const int k_iCallback = Constants.k_iSteamTimelineCallbacks + 2;
		public ulong m_ulEventID;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bRecordingExists;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Callback for querying UGC
	//-----------------------------------------------------------------------------
	// 目的：回调函数用于查询 UGC
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 1)]
	public struct SteamUGCQueryCompleted_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 1;
		public UGCQueryHandle_t m_handle;
		public EResult m_eResult;
		public uint m_unNumResultsReturned;
		public uint m_unTotalMatchingResults;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bCachedData;	// indicates whether this data was retrieved from the local on-disk cache 指示该数据是否从本地磁盘缓存中检索而来
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchPublishedFileURLMax)]
		private byte[] m_rgchNextCursor_;
		public string m_rgchNextCursor // If a paging cursor was used, then this will be the next cursor to get the next result set. 如果使用了分页光标，则这将是获取下一结果集的下一个光标。
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchNextCursor_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchNextCursor_, Constants.k_cchPublishedFileURLMax); }
		}
	}

	//-----------------------------------------------------------------------------
	// Purpose: Callback for requesting details on one piece of UGC
	//-----------------------------------------------------------------------------
	// 目的：回调函数，用于请求有关一个 UGC（用户生成内容）的详细信息。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 2)]
	public struct SteamUGCRequestUGCDetailsResult_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 2;
		public SteamUGCDetails_t m_details;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bCachedData; // indicates whether this data was retrieved from the local on-disk cache 指示该数据是否从本地磁盘缓存中检索而来
	}

	//-----------------------------------------------------------------------------
	// Purpose: result for ISteamUGC::CreateItem()
	//-----------------------------------------------------------------------------
	// 目的：结果对于 ISteamUGC::CreateItem()
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 3)]
	public struct CreateItemResult_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 3;
		public EResult m_eResult;
		public PublishedFileId_t m_nPublishedFileId; // new item got this UGC PublishFileID 新物品获得了这个UGC PublishFileID
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bUserNeedsToAcceptWorkshopLegalAgreement;
	}

	//-----------------------------------------------------------------------------
	// Purpose: result for ISteamUGC::SubmitItemUpdate()
	//-----------------------------------------------------------------------------
	// 目的：结果 for ISteamUGC::SubmitItemUpdate()
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 4)]
	public struct SubmitItemUpdateResult_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 4;
		public EResult m_eResult;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bUserNeedsToAcceptWorkshopLegalAgreement;
		public PublishedFileId_t m_nPublishedFileId;
	}

	//-----------------------------------------------------------------------------
	// Purpose: a Workshop item has been installed or updated
	//-----------------------------------------------------------------------------
	// 目的：一个工作坊项目已安装或更新。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 5)]
	public struct ItemInstalled_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 5;
		public AppId_t m_unAppID;
		public PublishedFileId_t m_nPublishedFileId;
		public UGCHandle_t m_hLegacyContent;
		public ulong m_unManifestID;
	}

	//-----------------------------------------------------------------------------
	// Purpose: result of DownloadItem(), existing item files can be accessed again
	//-----------------------------------------------------------------------------
	// 目的：result of DownloadItem(), 现有的文件可以再次访问。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 6)]
	public struct DownloadItemResult_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 6;
		public AppId_t m_unAppID;
		public PublishedFileId_t m_nPublishedFileId;
		public EResult m_eResult;
	}

	//-----------------------------------------------------------------------------
	// Purpose: result of AddItemToFavorites() or RemoveItemFromFavorites()
	//-----------------------------------------------------------------------------
	// 目的：AddItemToFavorites() 或 RemoveItemFromFavorites() 的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 7)]
	public struct UserFavoriteItemsListChanged_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 7;
		public PublishedFileId_t m_nPublishedFileId;
		public EResult m_eResult;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bWasAddRequest;
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to SetUserItemVote()
	//-----------------------------------------------------------------------------
	// 目的：调用 SetUserItemVote() 的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 8)]
	public struct SetUserItemVoteResult_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 8;
		public PublishedFileId_t m_nPublishedFileId;
		public EResult m_eResult;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bVoteUp;
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to GetUserItemVote()
	//-----------------------------------------------------------------------------
	// 目的：调用 GetUserItemVote() 的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 9)]
	public struct GetUserItemVoteResult_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 9;
		public PublishedFileId_t m_nPublishedFileId;
		public EResult m_eResult;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bVotedUp;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bVotedDown;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bVoteSkipped;
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to StartPlaytimeTracking()
	//-----------------------------------------------------------------------------
	// 目的：对 StartPlaytimeTracking() 函数调用的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 10)]
	public struct StartPlaytimeTrackingResult_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 10;
		public EResult m_eResult;
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to StopPlaytimeTracking()
	//-----------------------------------------------------------------------------
	// 目的：StopPlaytimeTracking() 函数的返回值
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 11)]
	public struct StopPlaytimeTrackingResult_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 11;
		public EResult m_eResult;
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to AddDependency
	//-----------------------------------------------------------------------------
	// 目的：对 AddDependency 函数调用的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 12)]
	public struct AddUGCDependencyResult_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 12;
		public EResult m_eResult;
		public PublishedFileId_t m_nPublishedFileId;
		public PublishedFileId_t m_nChildPublishedFileId;
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to RemoveDependency
	//-----------------------------------------------------------------------------
	// 目的：RemoveDependency函数的调用结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 13)]
	public struct RemoveUGCDependencyResult_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 13;
		public EResult m_eResult;
		public PublishedFileId_t m_nPublishedFileId;
		public PublishedFileId_t m_nChildPublishedFileId;
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to AddAppDependency
	//-----------------------------------------------------------------------------
	// 目的：调用 AddAppDependency 的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 14)]
	public struct AddAppDependencyResult_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 14;
		public EResult m_eResult;
		public PublishedFileId_t m_nPublishedFileId;
		public AppId_t m_nAppID;
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to RemoveAppDependency
	//-----------------------------------------------------------------------------
	// 目的：RemoveAppDependency调用的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 15)]
	public struct RemoveAppDependencyResult_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 15;
		public EResult m_eResult;
		public PublishedFileId_t m_nPublishedFileId;
		public AppId_t m_nAppID;
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to GetAppDependencies.  Callback may be called
	//			multiple times until all app dependencies have been returned.
	//-----------------------------------------------------------------------------
	// 目的：调用 GetAppDependencies 的结果。回调可能会多次被调用，直到所有应用程序依赖项都已返回。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 16)]
	public struct GetAppDependenciesResult_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 16;
		public EResult m_eResult;
		public PublishedFileId_t m_nPublishedFileId;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]
		public AppId_t[] m_rgAppIDs;
		public uint m_nNumAppDependencies;		// number returned in this struct 该结构体返回的数字
		public uint m_nTotalNumAppDependencies;	// total found 总计找到
	}

	//-----------------------------------------------------------------------------
	// Purpose: The result of a call to DeleteItem
	//-----------------------------------------------------------------------------
	// 目的：调用 DeleteItem 的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 17)]
	public struct DeleteItemResult_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 17;
		public EResult m_eResult;
		public PublishedFileId_t m_nPublishedFileId;
	}

	//-----------------------------------------------------------------------------
	// Purpose: signal that the list of subscribed items changed
	//-----------------------------------------------------------------------------
	// 目的：指示已订阅的项目列表已更改
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 18)]
	public struct UserSubscribedItemsListChanged_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 18;
		public AppId_t m_nAppID;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Status of the user's acceptable/rejection of the app's specific Workshop EULA
	//-----------------------------------------------------------------------------
	// 目的：用户对应用特定Workshop EULA的接受/拒绝状态
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUGCCallbacks + 20)]
	public struct WorkshopEULAStatus_t {
		public const int k_iCallback = Constants.k_iSteamUGCCallbacks + 20;
		public EResult m_eResult;
		public AppId_t m_nAppID;
		public uint m_unVersion;
		public RTime32 m_rtAction;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bAccepted;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bNeedsAction;
	}

	// callbacks
	//-----------------------------------------------------------------------------
	// Purpose: Called when an authenticated connection to the Steam back-end has been established.
	//			This means the Steam client now has a working connection to the Steam servers.
	//			Usually this will have occurred before the game has launched, and should
	//			only be seen if the user has dropped connection due to a networking issue
	//			or a Steam server update.
	//-----------------------------------------------------------------------------
	// 回调函数
// 目的：当已建立对Steam后端的认证连接时调用。这意味着Steam客户端现在已与Steam服务器建立有效的连接。通常，这将在游戏启动之前发生，并且只有在用户因网络问题或Steam服务器更新导致连接中断时才会出现。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamUserCallbacks + 1)]
	public struct SteamServersConnected_t {
		public const int k_iCallback = Constants.k_iSteamUserCallbacks + 1;
	}

	//-----------------------------------------------------------------------------
	// Purpose: called when a connection attempt has failed
	//			this will occur periodically if the Steam client is not connected,
	//			and has failed in it's retry to establish a connection
	//-----------------------------------------------------------------------------
	// 目的：当连接尝试失败时调用此函数。如果Steam客户端未连接且在尝试建立连接时失败，则会定期触发。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserCallbacks + 2)]
	public struct SteamServerConnectFailure_t {
		public const int k_iCallback = Constants.k_iSteamUserCallbacks + 2;
		public EResult m_eResult;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bStillRetrying;
	}

	//-----------------------------------------------------------------------------
	// Purpose: called if the client has lost connection to the Steam servers
	//			real-time services will be disabled until a matching SteamServersConnected_t has been posted
	//-----------------------------------------------------------------------------
	// 目的：当客户端与Steam服务器的实时服务失去连接时调用。实时服务将一直保持禁用状态，直到收到一个SteamServersConnected_t消息。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserCallbacks + 3)]
	public struct SteamServersDisconnected_t {
		public const int k_iCallback = Constants.k_iSteamUserCallbacks + 3;
		public EResult m_eResult;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Sent by the Steam server to the client telling it to disconnect from the specified game server,
	//			which it may be in the process of or already connected to.
	//			The game client should immediately disconnect upon receiving this message.
	//			This can usually occur if the user doesn't have rights to play on the game server.
	//-----------------------------------------------------------------------------
	// 目的：Steam服务器发送给客户端的消息，指示其断开与指定游戏服务器的连接，无论该客户端是否正在连接或已经连接。游戏客户端在收到此消息后应立即断开连接。这通常发生在用户没有权限在游戏服务器上游玩时。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserCallbacks + 13)]
	public struct ClientGameServerDeny_t {
		public const int k_iCallback = Constants.k_iSteamUserCallbacks + 13;
		
		public uint m_uAppID;
		public uint m_unGameServerIP;
		public ushort m_usGameServerPort;
		public ushort m_bSecure;
		public uint m_uReason;
	}

	//-----------------------------------------------------------------------------
	// Purpose: called when the callback system for this client is in an error state (and has flushed pending callbacks)
	//			When getting this message the client should disconnect from Steam, reset any stored Steam state and reconnect.
	//			This usually occurs in the rare event the Steam client has some kind of fatal error.
	//-----------------------------------------------------------------------------
	// 目的：当此客户端的回调系统处于错误状态（并且已刷新所有待处理的回调）时调用。收到此消息时，客户端应断开与Steam的连接，重置任何已存储的Steam状态，然后重新连接。这通常发生在Steam客户端出现某种致命错误时。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserCallbacks + 17)]
	public struct IPCFailure_t {
		public const int k_iCallback = Constants.k_iSteamUserCallbacks + 17;
		public byte m_eFailureType;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Signaled whenever licenses change
	//-----------------------------------------------------------------------------
	// 目的：当许可证发生变化时发出信号
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamUserCallbacks + 25)]
	public struct LicensesUpdated_t {
		public const int k_iCallback = Constants.k_iSteamUserCallbacks + 25;
	}

	//-----------------------------------------------------------------------------
	// callback for BeginAuthSession
	//-----------------------------------------------------------------------------
	// BeginAuthSession的回调
	[StructLayout(LayoutKind.Sequential, Pack = 4)]
	[CallbackIdentity(Constants.k_iSteamUserCallbacks + 43)]
	public struct ValidateAuthTicketResponse_t {
		public const int k_iCallback = Constants.k_iSteamUserCallbacks + 43;
		public CSteamID m_SteamID;
		public EAuthSessionResponse m_eAuthSessionResponse;
		public CSteamID m_OwnerSteamID; // different from m_SteamID if borrowed 如果借用的，与 m_SteamID 不同
	}

	//-----------------------------------------------------------------------------
	// Purpose: called when a user has responded to a microtransaction authorization request
	//-----------------------------------------------------------------------------
	// 目的：当用户响应微型交易授权请求时调用
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserCallbacks + 52)]
	public struct MicroTxnAuthorizationResponse_t {
		public const int k_iCallback = Constants.k_iSteamUserCallbacks + 52;
		
		public uint m_unAppID;			// AppID for this microtransaction 该交易的AppID
		public ulong m_ulOrderID;			// OrderID provided for the microtransaction 交易订单已提供
		public byte m_bAuthorized;		// if user authorized transaction 如果用户授权交易
	}

	//-----------------------------------------------------------------------------
	// Purpose: Result from RequestEncryptedAppTicket
	//-----------------------------------------------------------------------------
	// 目的：来自 RequestEncryptedAppTicket 的结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserCallbacks + 54)]
	public struct EncryptedAppTicketResponse_t {
		public const int k_iCallback = Constants.k_iSteamUserCallbacks + 54;
		
		public EResult m_eResult;
	}

	//-----------------------------------------------------------------------------
	// callback for GetAuthSessionTicket
	//-----------------------------------------------------------------------------
	// GetAuthSessionTicket的回调
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserCallbacks + 63)]
	public struct GetAuthSessionTicketResponse_t {
		public const int k_iCallback = Constants.k_iSteamUserCallbacks + 63;
		public HAuthTicket m_hAuthTicket;
		public EResult m_eResult;
	}

	//-----------------------------------------------------------------------------
	// Purpose: sent to your game in response to a steam://gamewebcallback/ command
	//-----------------------------------------------------------------------------
	// 目的：发送到您的游戏中，响应 steam://gamewebcallback/ 命令
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserCallbacks + 64)]
	public struct GameWebCallback_t {
		public const int k_iCallback = Constants.k_iSteamUserCallbacks + 64;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
		private byte[] m_szURL_;
		public string m_szURL
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_szURL_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_szURL_, 256); }
		}
	}

	//-----------------------------------------------------------------------------
	// Purpose: sent to your game in response to ISteamUser::RequestStoreAuthURL
	//-----------------------------------------------------------------------------
	// 目的：发送到您的游戏中，作为对 ISteamUser::RequestStoreAuthURL 的响应。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserCallbacks + 65)]
	public struct StoreAuthURLResponse_t {
		public const int k_iCallback = Constants.k_iSteamUserCallbacks + 65;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)]
		private byte[] m_szURL_;
		public string m_szURL
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_szURL_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_szURL_, 512); }
		}
	}

	//-----------------------------------------------------------------------------
	// Purpose: sent in response to ISteamUser::GetMarketEligibility
	//-----------------------------------------------------------------------------
	// 目的：发送响应 ISteamUser::GetMarketEligibility
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserCallbacks + 66)]
	public struct MarketEligibilityResponse_t {
		public const int k_iCallback = Constants.k_iSteamUserCallbacks + 66;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bAllowed;
		public EMarketNotAllowedReasonFlags m_eNotAllowedReason;
		public RTime32 m_rtAllowedAtTime;
		
		public int m_cdaySteamGuardRequiredDays; // The number of days any user is required to have had Steam Guard before they can use the market 用户必须拥有多少天的 Steam Guard 才能使用市场
		public int m_cdayNewDeviceCooldown; // The number of days after initial device authorization a user must wait before using the market on that device 用户在设备首次授权后，必须等待的天数才能在该设备上使用市场。
	}

	//-----------------------------------------------------------------------------
	// Purpose: sent for games with enabled anti indulgence / duration control, for
	// enabled users. Lets the game know whether the user can keep playing or
	// whether the game should exit, and returns info about remaining gameplay time.
	//
	// This callback is fired asynchronously in response to timers triggering.
	// It is also fired in response to calls to GetDurationControl().
	//-----------------------------------------------------------------------------
	// 目的：为启用了反沉迷/时间控制的游戏，以及启用了这些功能的玩家，提供支持。让游戏知道玩家是否可以继续游玩，或者游戏应该退出，并返回剩余游戏时间信息。
// 这个回调是在响应定时器触发时异步执行的。它还会在响应对 GetDurationControl() 的调用时触发。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserCallbacks + 67)]
	public struct DurationControl_t {
		public const int k_iCallback = Constants.k_iSteamUserCallbacks + 67;
		
		public EResult m_eResult;								// result of call (always k_EResultOK for asynchronous timer-based notifications) 异步定时器通知的结果 (始终为 k_EResultOK)
		public AppId_t m_appid;								// appid generating playtime AppID 生成游戏时间
		
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bApplicable;							// is duration control applicable to user + game combination 用户 + 游戏组合是否适用时长控制？
		public int m_csecsLast5h;							// playtime since most recent 5 hour gap in playtime, only counting up to regulatory limit of playtime, in seconds 最近5小时的游玩时间，只计算到监管规定的游玩时间上限，以秒为单位。
		
		public EDurationControlProgress m_progress;			// recommended progress (either everything is fine, or please exit game) 推荐进度 (要么一切正常，要么请退出游戏)
		public EDurationControlNotification m_notification;	// notification to show, if any (always k_EDurationControlNotification_None for API calls) 如果存在，显示通知 (API 调用始终为 k_EDurationControlNotification_None)
		
		public int m_csecsToday;							// playtime on current calendar day 当前日历上的游戏时间
		public int m_csecsRemaining;						// playtime remaining until the user hits a regulatory limit 用户达到监管限制剩余游戏时间
	}

	//-----------------------------------------------------------------------------
	// callback for GetTicketForWebApi
	//-----------------------------------------------------------------------------
	// GetTicketForWebApi 的回调
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserCallbacks + 68)]
	public struct GetTicketForWebApiResponse_t {
		public const int k_iCallback = Constants.k_iSteamUserCallbacks + 68;
		public HAuthTicket m_hAuthTicket;
		public EResult m_eResult;
		public int m_cubTicket;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_nCubTicketMaxLength)]
		public byte[] m_rgubTicket;
	}

	// callbacks
	//-----------------------------------------------------------------------------
	// Purpose: called when the latests stats and achievements have been received
	//			from the server
	//-----------------------------------------------------------------------------
	// 回调函数
// 目的：当从服务器接收到最新的统计数据和成就时调用。
	[StructLayout(LayoutKind.Explicit, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserStatsCallbacks + 1)]
	public struct UserStatsReceived_t {
		public const int k_iCallback = Constants.k_iSteamUserStatsCallbacks + 1;
		[FieldOffset(0)]
		public ulong m_nGameID;		// Game these stats are for 这些数据是为游戏准备的
		[FieldOffset(8)]
		public EResult m_eResult;		// Success / error fetching the stats 获取统计信息失败 / 成功
		[FieldOffset(12)]
		public CSteamID m_steamIDUser;	// The user for whom the stats are retrieved for 为检索统计数据的用户
	}

	//-----------------------------------------------------------------------------
	// Purpose: result of a request to store the user stats for a game
	//-----------------------------------------------------------------------------
	// 目的：对游戏的用户统计数据进行存储的请求结果
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserStatsCallbacks + 2)]
	public struct UserStatsStored_t {
		public const int k_iCallback = Constants.k_iSteamUserStatsCallbacks + 2;
		public ulong m_nGameID;		// Game these stats are for 这些数据是为游戏准备的
		public EResult m_eResult;		// success / error 成功 / 错误
	}

	//-----------------------------------------------------------------------------
	// Purpose: result of a request to store the achievements for a game, or an
	//			"indicate progress" call. If both m_nCurProgress and m_nMaxProgress
	//			are zero, that means the achievement has been fully unlocked.
	//-----------------------------------------------------------------------------
	// 目的：对存储游戏成就请求的结果，或“指示进度”调用。如果同时 m_nCurProgress 和 m_nMaxProgress 都为零，则表示该成就已完全解锁。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserStatsCallbacks + 3)]
	public struct UserAchievementStored_t {
		public const int k_iCallback = Constants.k_iSteamUserStatsCallbacks + 3;
		
		public ulong m_nGameID;				// Game this is for 这款游戏
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bGroupAchievement;	// if this is a "group" achievement 如果这是“group”成就
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchStatNameMax)]
		private byte[] m_rgchAchievementName_;
		public string m_rgchAchievementName		// name of the achievement 成就名称
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchAchievementName_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchAchievementName_, Constants.k_cchStatNameMax); }
		}
		public uint m_nCurProgress;			// current progress towards the achievement 当前进度 towards the achievement
		public uint m_nMaxProgress;			// "out of" this many 这个数量的
	}

	//-----------------------------------------------------------------------------
	// Purpose: call result for finding a leaderboard, returned as a result of FindOrCreateLeaderboard() or FindLeaderboard()
	//			use CCallResult<> to map this async result to a member function
	//-----------------------------------------------------------------------------
	// 目的：查找排行榜的结果，以 FindOrCreateLeaderboard() 或 FindLeaderboard() 的结果返回。使用 CCallResult<> 将此异步结果映射到成员函数。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserStatsCallbacks + 4)]
	public struct LeaderboardFindResult_t {
		public const int k_iCallback = Constants.k_iSteamUserStatsCallbacks + 4;
		public SteamLeaderboard_t m_hSteamLeaderboard;	// handle to the leaderboard serarched for, 0 if no leaderboard found 用于搜索的排行榜句柄，如果未找到排行榜则为0
		public byte m_bLeaderboardFound;				// 0 if no leaderboard found 如果没有找到排行榜
	}

	//-----------------------------------------------------------------------------
	// Purpose: call result indicating scores for a leaderboard have been downloaded and are ready to be retrieved, returned as a result of DownloadLeaderboardEntries()
	//			use CCallResult<> to map this async result to a member function
	//-----------------------------------------------------------------------------
	// 目的：调用结果表明排行榜的分数已下载并已准备好检索，作为 DownloadLeaderboardEntries() 的结果返回，使用 CCallResult<> 将此异步结果映射到成员函数。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserStatsCallbacks + 5)]
	public struct LeaderboardScoresDownloaded_t {
		public const int k_iCallback = Constants.k_iSteamUserStatsCallbacks + 5;
		public SteamLeaderboard_t m_hSteamLeaderboard;
		public SteamLeaderboardEntries_t m_hSteamLeaderboardEntries;	// the handle to pass into GetDownloadedLeaderboardEntries() 将句柄传递到 GetDownloadedLeaderboardEntries()
		public int m_cEntryCount; // the number of entries downloaded 下载的条目数量
	}

	//-----------------------------------------------------------------------------
	// Purpose: call result indicating scores has been uploaded, returned as a result of UploadLeaderboardScore()
	//			use CCallResult<> to map this async result to a member function
	//-----------------------------------------------------------------------------
	// 目的：调用结果，指示分数已上传，作为 `UploadLeaderboardScore()` 的结果返回，使用 `CCallResult<>` 将此异步结果映射到成员函数。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserStatsCallbacks + 6)]
	public struct LeaderboardScoreUploaded_t {
		public const int k_iCallback = Constants.k_iSteamUserStatsCallbacks + 6;
		public byte m_bSuccess;			// 1 if the call was successful 如果调用成功
		public SteamLeaderboard_t m_hSteamLeaderboard;	// the leaderboard handle that was 这个排行榜的名称是
		public int m_nScore;				// the score that was attempted to set 试图设定的分数
		public byte m_bScoreChanged;		// true if the score in the leaderboard change, false if the existing score was better 如果排行榜的分数发生变化，则为真；如果现有分数更好，则为假。
		public int m_nGlobalRankNew;		// the new global rank of the user in this leaderboard 用户在排行榜中的新全球排名
		public int m_nGlobalRankPrevious;	// the previous global rank of the user in this leaderboard; 0 if the user had no existing entry in the leaderboard 用户在本次排行榜上的前一轮全球排名；如果用户没有在排行榜中存在记录，则为0
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserStatsCallbacks + 7)]
	public struct NumberOfCurrentPlayers_t {
		public const int k_iCallback = Constants.k_iSteamUserStatsCallbacks + 7;
		public byte m_bSuccess;			// 1 if the call was successful 如果调用成功
		public int m_cPlayers;			// Number of players currently playing 当前正在玩游戏的玩家人数
	}

	//-----------------------------------------------------------------------------
	// Purpose: Callback indicating that a user's stats have been unloaded.
	//  Call RequestUserStats again to access stats for this user
	//-----------------------------------------------------------------------------
	// 目的：回调指示用户统计数据已卸载。为了访问该用户的统计数据，请再次调用 RequestUserStats。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserStatsCallbacks + 8)]
	public struct UserStatsUnloaded_t {
		public const int k_iCallback = Constants.k_iSteamUserStatsCallbacks + 8;
		public CSteamID m_steamIDUser;	// User whose stats have been unloaded 已卸载统计数据的用户
	}

	//-----------------------------------------------------------------------------
	// Purpose: Callback indicating that an achievement icon has been fetched
	//-----------------------------------------------------------------------------
	// 目的：回调指示一个成就图标已获取。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserStatsCallbacks + 9)]
	public struct UserAchievementIconFetched_t {
		public const int k_iCallback = Constants.k_iSteamUserStatsCallbacks + 9;
		
		public CGameID m_nGameID;				// Game this is for 这款游戏
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_cchStatNameMax)]
		private byte[] m_rgchAchievementName_;
		public string m_rgchAchievementName		// name of the achievement 成就名称
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchAchievementName_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchAchievementName_, Constants.k_cchStatNameMax); }
		}
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bAchieved;		// Is the icon for the achieved or not achieved version? 图标是显示已达成或未达成版本？
		public int m_nIconHandle;		// Handle to the image, which can be used in SteamUtils()->GetImageRGBA(), 0 means no image is set for the achievement 对图像的处理句柄，可用于 SteamUtils()->GetImageRGBA()，0 表示未设置任何图像用于徽章。
	}

	//-----------------------------------------------------------------------------
	// Purpose: Callback indicating that global achievement percentages are fetched
	//-----------------------------------------------------------------------------
	// 目的：回调指示全球成就百分比已获取
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserStatsCallbacks + 10)]
	public struct GlobalAchievementPercentagesReady_t {
		public const int k_iCallback = Constants.k_iSteamUserStatsCallbacks + 10;
		
		public ulong m_nGameID;				// Game this is for 这款游戏
		public EResult m_eResult;				// Result of the operation 操作结果
	}

	//-----------------------------------------------------------------------------
	// Purpose: call result indicating UGC has been uploaded, returned as a result of SetLeaderboardUGC()
	//-----------------------------------------------------------------------------
	// 目的：调用结果，指示UGC（用户生成内容）已上传，作为SetLeaderboardUGC()的返回值。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserStatsCallbacks + 11)]
	public struct LeaderboardUGCSet_t {
		public const int k_iCallback = Constants.k_iSteamUserStatsCallbacks + 11;
		public EResult m_eResult;				// The result of the operation 操作的结果
		public SteamLeaderboard_t m_hSteamLeaderboard;	// the leaderboard handle that was 这个排行榜的名称是
	}

	//-----------------------------------------------------------------------------
	// Purpose: callback indicating global stats have been received.
	//	Returned as a result of RequestGlobalStats()
	//-----------------------------------------------------------------------------
	// 目的：回调指示全局统计信息已接收。作为 RequestGlobalStats() 的结果返回。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUserStatsCallbacks + 12)]
	public struct GlobalStatsReceived_t {
		public const int k_iCallback = Constants.k_iSteamUserStatsCallbacks + 12;
		public ulong m_nGameID;				// Game global stats were requested for 请求游戏全球统计数据
		public EResult m_eResult;				// The result of the request 请求的结果
	}

	// callbacks
	//-----------------------------------------------------------------------------
	// Purpose: The country of the user changed
	//-----------------------------------------------------------------------------
	// 回调函数
// 目的：用户的国家已更改
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamUtilsCallbacks + 1)]
	public struct IPCountry_t {
		public const int k_iCallback = Constants.k_iSteamUtilsCallbacks + 1;
	}

	//-----------------------------------------------------------------------------
	// Purpose: Fired when running on a handheld PC or laptop with less than 10 minutes of battery is left, fires then every minute
	//-----------------------------------------------------------------------------
	// 目的：在运行于手持PC或笔记本电脑且电池剩余时间小于10分钟时触发，然后每分钟触发一次。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUtilsCallbacks + 2)]
	public struct LowBatteryPower_t {
		public const int k_iCallback = Constants.k_iSteamUtilsCallbacks + 2;
		public byte m_nMinutesBatteryLeft;
	}

	//-----------------------------------------------------------------------------
	// Purpose: called when a SteamAsyncCall_t has completed (or failed)
	//-----------------------------------------------------------------------------
	// 目的：当 SteamAsyncCall_t 完成（或失败）时调用。
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUtilsCallbacks + 3)]
	public struct SteamAPICallCompleted_t {
		public const int k_iCallback = Constants.k_iSteamUtilsCallbacks + 3;
		public SteamAPICall_t m_hAsyncCall;
		public int m_iCallback;
		public uint m_cubParam;
	}

	//-----------------------------------------------------------------------------
	// called when Steam wants to shutdown
	//-----------------------------------------------------------------------------
	// 当Steam想要关闭时调用
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamUtilsCallbacks + 4)]
	public struct SteamShutdown_t {
		public const int k_iCallback = Constants.k_iSteamUtilsCallbacks + 4;
	}

	//-----------------------------------------------------------------------------
	// callback for CheckFileSignature
	//-----------------------------------------------------------------------------
	// 检查文件签名回调
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUtilsCallbacks + 5)]
	public struct CheckFileSignature_t {
		public const int k_iCallback = Constants.k_iSteamUtilsCallbacks + 5;
		public ECheckFileSignature m_eCheckFileSignature;
	}

	// k_iSteamUtilsCallbacks + 13 is taken
	//-----------------------------------------------------------------------------
	// Full Screen gamepad text input has been closed
	//-----------------------------------------------------------------------------
	// k_iSteamUtilsCallbacks + 13 is taken
// 全屏手柄文本输入已关闭
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUtilsCallbacks + 14)]
	public struct GamepadTextInputDismissed_t {
		public const int k_iCallback = Constants.k_iSteamUtilsCallbacks + 14;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bSubmitted;										// true if user entered & accepted text (Call ISteamUtils::GetEnteredGamepadTextInput() for text), false if canceled input 如果用户已输入并接受文本（调用 ISteamUtils::GetEnteredGamepadTextInput() 获取文本），则为真；如果取消了输入，则为假。
		public uint m_unSubmittedText;
		public AppId_t m_unAppID;
	}

	// k_iSteamUtilsCallbacks + 15 through 35 are taken
	// k_iSteamUtilsCallbacks + 15 through 35 are taken
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamUtilsCallbacks + 36)]
	public struct AppResumingFromSuspend_t {
		public const int k_iCallback = Constants.k_iSteamUtilsCallbacks + 36;
	}

	// k_iSteamUtilsCallbacks + 37 is taken
	//-----------------------------------------------------------------------------
	// The floating on-screen keyboard has been closed
	//-----------------------------------------------------------------------------
	// k_iSteamUtilsCallbacks + 37 is taken
// 浮动屏幕键盘已关闭
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value, Size = 1)]
	[CallbackIdentity(Constants.k_iSteamUtilsCallbacks + 38)]
	public struct FloatingGamepadTextInputDismissed_t {
		public const int k_iCallback = Constants.k_iSteamUtilsCallbacks + 38;
	}

	//-----------------------------------------------------------------------------
	// The text filtering dictionary has changed
	//-----------------------------------------------------------------------------
	// 文本过滤词典已更改
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamUtilsCallbacks + 39)]
	public struct FilterTextDictionaryChanged_t {
		public const int k_iCallback = Constants.k_iSteamUtilsCallbacks + 39;
		public int m_eLanguage;	// One of ELanguage, or k_LegallyRequiredFiltering One of ELanguage, or k_LegallyRequiredFiltering
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamVideoCallbacks + 11)]
	public struct GetVideoURLResult_t {
		public const int k_iCallback = Constants.k_iSteamVideoCallbacks + 11;
		public EResult m_eResult;
		public AppId_t m_unVideoAppID;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]
		private byte[] m_rgchURL_;
		public string m_rgchURL
		{
			get { return InteropHelp.ByteArrayToStringUTF8(m_rgchURL_); }
			set { InteropHelp.StringToByteArrayUTF8(value, m_rgchURL_, 256); }
		}
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamVideoCallbacks + 24)]
	public struct GetOPFSettingsResult_t {
		public const int k_iCallback = Constants.k_iSteamVideoCallbacks + 24;
		public EResult m_eResult;
		public AppId_t m_unVideoAppID;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamVideoCallbacks + 4)]
	public struct BroadcastUploadStart_t {
		public const int k_iCallback = Constants.k_iSteamVideoCallbacks + 4;
		[MarshalAs(UnmanagedType.I1)]
		public bool m_bIsRTMP;
	}

	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamVideoCallbacks + 5)]
	public struct BroadcastUploadStop_t {
		public const int k_iCallback = Constants.k_iSteamVideoCallbacks + 5;
		public EBroadcastUploadResult m_eResult;
	}

	/// Callback struct used to notify when a connection has changed state
	/// A struct used to describe a "fake IP" we have been assigned to
	/// use as an identifier.  This callback is posted when
	/// ISteamNetworkingSoockets::BeginAsyncRequestFakeIP completes.
	/// See also ISteamNetworkingSockets::GetFakeIP
	/// 回调结构用于在连接状态发生变化时通知。一个结构体用于描述我们被分配使用的作为标识符的“假 IP”。当 ISteamNetworkingSockets::BeginAsyncRequestFakeIP 完成时，会发布此回调。 参见 ISteamNetworkingSockets::GetFakeIP
	[StructLayout(LayoutKind.Sequential, Pack = Packsize.value)]
	[CallbackIdentity(Constants.k_iSteamNetworkingSocketsCallbacks + 3)]
	public struct SteamNetworkingFakeIPResult_t {
		public const int k_iCallback = Constants.k_iSteamNetworkingSocketsCallbacks + 3;
		
		/// Status/result of the allocation request.  Possible failure values are:
		/// - k_EResultBusy - you called GetFakeIP but the request has not completed.
		/// - k_EResultInvalidParam - you called GetFakeIP with an invalid port index
		/// - k_EResultLimitExceeded - You asked for too many ports, or made an
		///   additional request after one had already succeeded
		/// - k_EResultNoMatch - GetFakeIP was called, but no request has been made
		///
		/// Note that, with the exception of k_EResultBusy (if you are polling),
		/// it is highly recommended to treat all failures as fatal.
		/// 状态/结果分配请求。可能的错误值： - k_EResultBusy - 你调用了 GetFakeIP 但请求未完成。 - k_EResultInvalidParam - 你使用无效端口索引调用 GetFakeIP。 - k_EResultLimitExceeded - 你请求了过多的端口，或者在已成功完成的一个请求之后又进行了其他请求。 - k_EResultNoMatch - 调用 GetFakeIP，但没有进行任何请求。
	/// 请注意，除了 k_EResultBusy (如果进行轮询) 之外，强烈建议将所有失败情况都视为致命错误。
		public EResult m_eResult;
		
		/// Local identity of the ISteamNetworkingSockets object that made
		/// this request and is assigned the IP.  This is needed in the callback
		/// in the case where there are multiple ISteamNetworkingSockets objects.
		/// (E.g. one for the user, and another for the local gameserver).
		/// 发起此请求的 ISteamNetworkingSockets 对象的本地身份，并且分配了 IP。这在回调中是需要的，以防有多个 ISteamNetworkingSockets 对象（例如，一个用于用户，另一个用于本地游戏服务器）。
		public SteamNetworkingIdentity m_identity;
		
		/// Fake IPv4 IP address that we have been assigned.  NOTE: this
		/// IP address is not exclusively ours!  Steam tries to avoid sharing
		/// IP addresses, but this may not always be possible.  The IP address
		/// may be currently in use by another host, but with different port(s).
		/// The exact same IP:port address may have been used previously.
		/// Steam tries to avoid reusing ports until they have not been in use for
		/// some time, but this may not always be possible.
		/// 虚假的 IPv4 IP 地址，我们被分配的。请注意：此 IP 地址不属于我们独占使用！Steam 尝试避免共享 IP 地址，但这并不总是可以实现。该 IP 地址可能当前正在由另一个主机使用，但使用不同的端口(s)。 确切相同的 IP:端口地址可能之前已被使用。Steam 尝试避免在一段时间未使用后才重复使用端口，但此行为并不总是可以实现。
		public uint m_unIP;
		[MarshalAs(UnmanagedType.ByValArray, SizeConst = Constants.k_nMaxReturnPorts)]
		public ushort[] m_unPorts;
	}

}

#endif // !DISABLESTEAMWORKS
