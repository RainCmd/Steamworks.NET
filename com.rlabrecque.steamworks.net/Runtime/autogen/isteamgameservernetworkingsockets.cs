// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
	#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	public static class SteamGameServerNetworkingSockets {
		/// <summary>
		/// <para> Creates a "server" socket that listens for clients to connect to by</para>
		/// <para> calling ConnectByIPAddress, over ordinary UDP (IPv4 or IPv6)</para>
		/// <para> You must select a specific local port to listen on and set it</para>
		/// <para> the port field of the local address.</para>
		/// <para> Usually you will set the IP portion of the address to zero (SteamNetworkingIPAddr::Clear()).</para>
		/// <para> This means that you will not bind to any particular local interface (i.e. the same</para>
		/// <para> as INADDR_ANY in plain socket code).  Furthermore, if possible the socket will be bound</para>
		/// <para> in "dual stack" mode, which means that it can accept both IPv4 and IPv6 client connections.</para>
		/// <para> If you really do wish to bind a particular interface, then set the local address to the</para>
		/// <para> appropriate IPv4 or IPv6 IP.</para>
		/// <para> If you need to set any initial config options, pass them here.  See</para>
		/// <para> SteamNetworkingConfigValue_t for more about why this is preferable to</para>
		/// <para> setting the options "immediately" after creation.</para>
		/// <para> When a client attempts to connect, a SteamNetConnectionStatusChangedCallback_t</para>
		/// <para> will be posted.  The connection will be in the connecting state.</para>
		/// <para>创建一个“服务器”套接字，通过调用 ConnectByIPAddress，监听客户端的连接，使用普通 UDP（IPv4 或 IPv6）。</para>
		/// <para>您必须选择一个特定的本地端口进行监听，并在“本地地址”字段中设置该端口。</para>
		/// <para>通常，您会设置地址的 IP 部分为零 (SteamNetworkingIPAddr::Clear())。这意味着您不会绑定到任何特定的本地接口（即与 INADDR_ANY 在普通套接字代码中的含义相同）。 此外，如果可能，套接字将以“双栈”模式进行绑定，这意味着它可以接受 IPv4 和 IPv6 客户端连接。 如果您确实希望绑定特定的接口，则将本地地址设置为适当的 IPv4 或 IPv6 IP。</para>
		/// <para>如果需要设置任何初始配置选项，请在此处传递它们。请参阅 SteamNetworkingConfigValue_t 以了解为什么这种方法比在创建后“立即”设置选项更可取。</para>
		/// <para>当客户端尝试连接时，将会发布一个 SteamNetConnectionStatusChangedCallback_t。连接状态将处于连接中状态。</para>
		/// </summary>
		public static HSteamListenSocket CreateListenSocketIP(ref SteamNetworkingIPAddr localAddress, int nOptions, SteamNetworkingConfigValue_t[] pOptions) {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamListenSocket)NativeMethods.ISteamNetworkingSockets_CreateListenSocketIP(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), ref localAddress, nOptions, pOptions);
		}

		/// <summary>
		/// <para> Creates a connection and begins talking to a "server" over UDP at the</para>
		/// <para> given IPv4 or IPv6 address.  The remote host must be listening with a</para>
		/// <para> matching call to CreateListenSocketIP on the specified port.</para>
		/// <para> A SteamNetConnectionStatusChangedCallback_t callback will be triggered when we start</para>
		/// <para> connecting, and then another one on either timeout or successful connection.</para>
		/// <para> If the server does not have any identity configured, then their network address</para>
		/// <para> will be the only identity in use.  Or, the network host may provide a platform-specific</para>
		/// <para> identity with or without a valid certificate to authenticate that identity.  (These</para>
		/// <para> details will be contained in the SteamNetConnectionStatusChangedCallback_t.)  It's</para>
		/// <para> up to your application to decide whether to allow the connection.</para>
		/// <para> By default, all connections will get basic encryption sufficient to prevent</para>
		/// <para> casual eavesdropping.  But note that without certificates (or a shared secret</para>
		/// <para> distributed through some other out-of-band mechanism), you don't have any</para>
		/// <para> way of knowing who is actually on the other end, and thus are vulnerable to</para>
		/// <para> man-in-the-middle attacks.</para>
		/// <para> If you need to set any initial config options, pass them here.  See</para>
		/// <para> SteamNetworkingConfigValue_t for more about why this is preferable to</para>
		/// <para> setting the options "immediately" after creation.</para>
		/// <para>建立连接并开始与指定 IPv4 或 IPv6 地址的“服务器”进行 UDP 通信。远程主机必须监听指定端口，并使用 CreateListenSocketIP 函数进行匹配调用。</para>
		/// <para>A SteamNetConnectionStatusChangedCallback_t 回调将在我们开始连接时触发，然后另一个在超时或成功连接时触发。</para>
		/// <para>如果服务器没有配置任何身份验证信息，则其网络地址将作为唯一的身份进行使用。或者，网络主机可以提供特定于平台的身份，并可能附带有效的证书以验证该身份。（这些细节将包含在 SteamNetConnectionStatusChangedCallback_t 中。） 应用程序需要自行决定是否允许连接。</para>
		/// <para>默认情况下，所有连接都会获得足够的加密，足以防止非正式的窃听。但是，如果没有证书（或通过其他非同步机制分发出的共享密钥），你无法知道实际在另一端的人是谁，因此容易受到中间人攻击。</para>
		/// <para>如果需要设置任何初始配置选项，请在此处传递它们。请参阅 SteamNetworkingConfigValue_t 以了解为什么这种方法比在创建后“立即”设置选项更可取。</para>
		/// </summary>
		public static HSteamNetConnection ConnectByIPAddress(ref SteamNetworkingIPAddr address, int nOptions, SteamNetworkingConfigValue_t[] pOptions) {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamNetConnection)NativeMethods.ISteamNetworkingSockets_ConnectByIPAddress(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), ref address, nOptions, pOptions);
		}

		/// <summary>
		/// <para> Like CreateListenSocketIP, but clients will connect using ConnectP2P.</para>
		/// <para> nLocalVirtualPort specifies how clients can connect to this socket using</para>
		/// <para> ConnectP2P.  It's very common for applications to only have one listening socket;</para>
		/// <para> in that case, use zero.  If you need to open multiple listen sockets and have clients</para>
		/// <para> be able to connect to one or the other, then nLocalVirtualPort should be a small</para>
		/// <para> integer (&lt;1000) unique to each listen socket you create.</para>
		/// <para> If you use this, you probably want to call ISteamNetworkingUtils::InitRelayNetworkAccess()</para>
		/// <para> when your app initializes.</para>
		/// <para> If you are listening on a dedicated servers in known data center,</para>
		/// <para> then you can listen using this function instead of CreateHostedDedicatedServerListenSocket,</para>
		/// <para> to allow clients to connect without a ticket.  Any user that owns</para>
		/// <para> the app and is signed into Steam will be able to attempt to connect to</para>
		/// <para> your server.  Also, a connection attempt may require the client to</para>
		/// <para> be connected to Steam, which is one more moving part that may fail.  When</para>
		/// <para> tickets are used, then once a ticket is obtained, a client can connect to</para>
		/// <para> your server even if they got disconnected from Steam or Steam is offline.</para>
		/// <para> If you need to set any initial config options, pass them here.  See</para>
		/// <para> SteamNetworkingConfigValue_t for more about why this is preferable to</para>
		/// <para> setting the options "immediately" after creation.</para>
		/// <para>类似于CreateListenSocketIP，但客户端将使用ConnectP2P连接。</para>
		/// <para>nLocalVirtualPort 指定客户端如何使用 ConnectP2P 连接到此套接字。 应用程序通常只有一个监听套接字；如果是这种情况，请使用零。 如果您需要打开多个监听套接字，并且希望客户端能够连接到其中一个，则 nLocalVirtualPort 应该是一个小整数（<1000），并且对每个创建的监听套接字都具有唯一性。</para>
		/// <para>如果你使用这个，你可能需要在你的应用初始化时调用 ISteamNetworkingUtils::InitRelayNetworkAccess()。</para>
		/// <para>如果您在已知数据中心的专用服务器上进行监听，则可以使用此函数而不是 CreateHostedDedicatedServerListenSocket，以便客户端无需凭证即可连接。任何拥有该应用的用户，并在 Steam 上登录，都可以尝试连接到您的服务器。此外，连接尝试可能需要客户端已连接到 Steam，这会增加一个可能失败的环节。</para>
		/// <para>如果需要设置任何初始配置选项，请在此处传递它们。请参阅 SteamNetworkingConfigValue_t 以了解为什么这种方法比在创建后“立即”设置选项更可取。</para>
		/// </summary>
		public static HSteamListenSocket CreateListenSocketP2P(int nLocalVirtualPort, int nOptions, SteamNetworkingConfigValue_t[] pOptions) {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamListenSocket)NativeMethods.ISteamNetworkingSockets_CreateListenSocketP2P(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), nLocalVirtualPort, nOptions, pOptions);
		}

		/// <summary>
		/// <para> Begin connecting to a peer that is identified using a platform-specific identifier.</para>
		/// <para> This uses the default rendezvous service, which depends on the platform and library</para>
		/// <para> configuration.  (E.g. on Steam, it goes through the steam backend.)</para>
		/// <para> If you need to set any initial config options, pass them here.  See</para>
		/// <para> SteamNetworkingConfigValue_t for more about why this is preferable to</para>
		/// <para> setting the options "immediately" after creation.</para>
		/// <para> To use your own signaling service, see:</para>
		/// <para> - ConnectP2PCustomSignaling</para>
		/// <para> - k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling</para>
		/// <para>开始连接到一个使用特定平台标识符识别的同伴。 这使用默认的rendezvous服务，该服务取决于平台和库配置。(例如，在Steam上，它会通过Steam后端进行。)</para>
		/// <para>如果需要设置任何初始配置选项，请在此处传递它们。请参阅 SteamNetworkingConfigValue_t 以了解为什么这种方法比在创建后“立即”设置选项更可取。</para>
		/// <para>使用您自己的信号服务，请参见：- ConnectP2PCustomSignaling - k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling</para>
		/// </summary>
		public static HSteamNetConnection ConnectP2P(ref SteamNetworkingIdentity identityRemote, int nRemoteVirtualPort, int nOptions, SteamNetworkingConfigValue_t[] pOptions) {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamNetConnection)NativeMethods.ISteamNetworkingSockets_ConnectP2P(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), ref identityRemote, nRemoteVirtualPort, nOptions, pOptions);
		}

		/// <summary>
		/// <para> Accept an incoming connection that has been received on a listen socket.</para>
		/// <para> When a connection attempt is received (perhaps after a few basic handshake</para>
		/// <para> packets have been exchanged to prevent trivial spoofing), a connection interface</para>
		/// <para> object is created in the k_ESteamNetworkingConnectionState_Connecting state</para>
		/// <para> and a SteamNetConnectionStatusChangedCallback_t is posted.  At this point, your</para>
		/// <para> application MUST either accept or close the connection.  (It may not ignore it.)</para>
		/// <para> Accepting the connection will transition it either into the connected state,</para>
		/// <para> or the finding route state, depending on the connection type.</para>
		/// <para> You should take action within a second or two, because accepting the connection is</para>
		/// <para> what actually sends the reply notifying the client that they are connected.  If you</para>
		/// <para> delay taking action, from the client's perspective it is the same as the network</para>
		/// <para> being unresponsive, and the client may timeout the connection attempt.  In other</para>
		/// <para> words, the client cannot distinguish between a delay caused by network problems</para>
		/// <para> and a delay caused by the application.</para>
		/// <para> This means that if your application goes for more than a few seconds without</para>
		/// <para> processing callbacks (for example, while loading a map), then there is a chance</para>
		/// <para> that a client may attempt to connect in that interval and fail due to timeout.</para>
		/// <para> If the application does not respond to the connection attempt in a timely manner,</para>
		/// <para> and we stop receiving communication from the client, the connection attempt will</para>
		/// <para> be timed out locally, transitioning the connection to the</para>
		/// <para> k_ESteamNetworkingConnectionState_ProblemDetectedLocally state.  The client may also</para>
		/// <para> close the connection before it is accepted, and a transition to the</para>
		/// <para> k_ESteamNetworkingConnectionState_ClosedByPeer is also possible depending the exact</para>
		/// <para> sequence of events.</para>
		/// <para> Returns k_EResultInvalidParam if the handle is invalid.</para>
		/// <para> Returns k_EResultInvalidState if the connection is not in the appropriate state.</para>
		/// <para> (Remember that the connection state could change in between the time that the</para>
		/// <para> notification being posted to the queue and when it is received by the application.)</para>
		/// <para> A note about connection configuration options.  If you need to set any configuration</para>
		/// <para> options that are common to all connections accepted through a particular listen</para>
		/// <para> socket, consider setting the options on the listen socket, since such options are</para>
		/// <para> inherited automatically.  If you really do need to set options that are connection</para>
		/// <para> specific, it is safe to set them on the connection before accepting the connection.</para>
		/// <para>接受一个通过监听套接字接收到的传入连接。</para>
		/// <para>当收到连接尝试（可能在几个基本的握手包交换后，以防止无效伪造）后，会在 `k_ESteamNetworkingConnectionState_Connecting` 状态下创建一个连接接口对象，并发布一个 `SteamNetConnectionStatusChangedCallback_t`。 在此时，你的应用程序必须要么接受，要么关闭该连接。（它不能忽略它。）接受连接会将其过渡到连接状态或查找路由状态，具体取决于连接类型。</para>
		/// <para>你应该在1到2秒内采取行动，因为接受连接实际上会发送通知客户端已连接的回复。 如果你延迟采取行动，从客户端的角度来看，与网络无响应相同，客户端可能会超时连接尝试。 换句话说，客户端无法区分因网络问题导致的延迟和因应用程序导致的延迟。</para>
		/// <para>这意味着，如果你的应用程序在处理回调超过几秒钟（例如，在加载地图时），则有可能会在那个时间间隔内尝试连接并由于超时而失败。</para>
		/// <para>如果应用程序未能及时响应连接尝试，并且我们不再接收来自客户端的通信，则本地连接尝试将超时，并过渡到 k_ESteamNetworkingConnectionState_ProblemDetectedLocally 状态。 客户端也可能在连接被接受之前关闭连接，并且具体事件序列取决于，过渡到 k_ESteamNetworkingConnectionState_ClosedByPeer 也是可能的。</para>
		/// <para>如果句柄无效，则返回 k_EResultInvalidParam。如果连接状态不正确，则返回 k_EResultInvalidState。 (请记住，在通知发布到队列和应用程序接收通知之间，连接状态可能会发生变化。)</para>
		/// <para>关于连接配置选项的一点说明。如果您需要设置通往特定监听套接字接受的所有连接的常见配置选项，请考虑在监听套接字上设置这些选项，因为这些选项会自动继承。如果您确实需要设置特定于连接的选项，则在接受连接之前在连接上设置这些选项是安全的。</para>
		/// </summary>
		public static EResult AcceptConnection(HSteamNetConnection hConn) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_AcceptConnection(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn);
		}

		/// <summary>
		/// <para> Disconnects from the remote host and invalidates the connection handle.</para>
		/// <para> Any unread data on the connection is discarded.</para>
		/// <para> nReason is an application defined code that will be received on the other</para>
		/// <para> end and recorded (when possible) in backend analytics.  The value should</para>
		/// <para> come from a restricted range.  (See ESteamNetConnectionEnd.)  If you don't need</para>
		/// <para> to communicate any information to the remote host, and do not want analytics to</para>
		/// <para> be able to distinguish "normal" connection terminations from "exceptional" ones,</para>
		/// <para> You may pass zero, in which case the generic value of</para>
		/// <para> k_ESteamNetConnectionEnd_App_Generic will be used.</para>
		/// <para> pszDebug is an optional human-readable diagnostic string that will be received</para>
		/// <para> by the remote host and recorded (when possible) in backend analytics.</para>
		/// <para> If you wish to put the socket into a "linger" state, where an attempt is made to</para>
		/// <para> flush any remaining sent data, use bEnableLinger=true.  Otherwise reliable data</para>
		/// <para> is not flushed.</para>
		/// <para> If the connection has already ended and you are just freeing up the</para>
		/// <para> connection interface, the reason code, debug string, and linger flag are</para>
		/// <para> ignored.</para>
		/// <para>从远程主机断开连接并无效化连接句柄。连接上未读数据将被丢弃。</para>
		/// <para>Reason 是一种应用代码，将在另一端接收并记录（如果可能）在后端分析中。值应来自受限范围。 (参见 ESteamNetConnectionEnd)。如果您不需要向远程主机传递任何信息，并且不想让后端分析能够区分“正常”的连接终止和“异常”的连接终止，则可以传递零，此时将使用 k_ESteamNetConnectionEnd_App_Generic 的通用值。</para>
		/// <para>pszDebug 是一个可选的、可读的诊断字符串，将发送到远程主机并记录（如果可能）在后端分析中。</para>
		/// <para>如果希望将套接字置于“linger”状态，即尝试刷新任何剩余已发送的数据，请使用 bEnableLinger=true。否则，可靠的数据不会被刷新。</para>
		/// <para>如果连接已断开，并且你只是释放连接接口，则原因代码、调试字符串和 linger 标志会被忽略。</para>
		/// </summary>
		public static bool CloseConnection(HSteamNetConnection hPeer, int nReason, string pszDebug, bool bEnableLinger) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pszDebug2 = new InteropHelp.UTF8StringHandle(pszDebug)) {
				return NativeMethods.ISteamNetworkingSockets_CloseConnection(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hPeer, nReason, pszDebug2, bEnableLinger);
			}
		}

		/// <summary>
		/// <para> Destroy a listen socket.  All the connections that were accepting on the listen</para>
		/// <para> socket are closed ungracefully.</para>
		/// <para>销毁一个监听套接字。所有在监听套接字上接受连接的连接会不优雅地关闭。</para>
		/// </summary>
		public static bool CloseListenSocket(HSteamListenSocket hSocket) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_CloseListenSocket(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hSocket);
		}

		/// <summary>
		/// <para> Set connection user data.  the data is returned in the following places</para>
		/// <para> - You can query it using GetConnectionUserData.</para>
		/// <para> - The SteamNetworkingmessage_t structure.</para>
		/// <para> - The SteamNetConnectionInfo_t structure.</para>
		/// <para>   (Which is a member of SteamNetConnectionStatusChangedCallback_t -- but see WARNINGS below!!!!)</para>
		/// <para> Do you need to set this atomically when the connection is created?</para>
		/// <para> See k_ESteamNetworkingConfig_ConnectionUserData.</para>
		/// <para> WARNING: Be *very careful* when using the value provided in callbacks structs.</para>
		/// <para> Callbacks are queued, and the value that you will receive in your</para>
		/// <para> callback is the userdata that was effective at the time the callback</para>
		/// <para> was queued.  There are subtle race conditions that can happen if you</para>
		/// <para> don't understand this!</para>
		/// <para> If any incoming messages for this connection are queued, the userdata</para>
		/// <para> field is updated, so that when when you receive messages (e.g. with</para>
		/// <para> ReceiveMessagesOnConnection), they will always have the very latest</para>
		/// <para> userdata.  So the tricky race conditions that can happen with callbacks</para>
		/// <para> do not apply to retrieving messages.</para>
		/// <para> Returns false if the handle is invalid.</para>
		/// <para>设置连接用户数据。数据在以下位置返回 - 您可以使用 GetConnectionUserData 查询它 - SteamNetworkingmessage_t 结构 - SteamNetConnectionInfo_t 结构 (它是 SteamNetConnectionStatusChangedCallback_t 的成员 -- 但请参阅下面的警告!!!!)</para>
		/// <para>当连接创建时，是否需要以原子方式设置此项？请参阅 k_ESteamNetworkingConfig_ConnectionUserData。</para>
		/// <para>警告：在使用回调结构体提供的值时，请务必小心。回调会被排队，你收到的值将是回调被排队时有效的userdata。如果不理解这一点，可能会发生微妙的竞争条件！</para>
		/// <para>如果任何连接传入的消息被排队，userdata字段会被更新，这样当你接收到消息（例如，使用ReceiveMessagesOnConnection）时，它们始终会拥有最新的userdata。因此，与回调相关的棘手竞争条件不适用于消息检索。</para>
		/// <para>如果句柄无效，则返回false。</para>
		/// </summary>
		public static bool SetConnectionUserData(HSteamNetConnection hPeer, long nUserData) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_SetConnectionUserData(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hPeer, nUserData);
		}

		/// <summary>
		/// <para> Fetch connection user data.  Returns -1 if handle is invalid</para>
		/// <para> or if you haven't set any userdata on the connection.</para>
		/// <para>获取连接用户数据。如果句柄无效或未在连接上设置任何用户数据，则返回 -1。</para>
		/// </summary>
		public static long GetConnectionUserData(HSteamNetConnection hPeer) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetConnectionUserData(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hPeer);
		}

		/// <summary>
		/// <para> Set a name for the connection, used mostly for debugging</para>
		/// <para>设置连接名称，主要用于调试。</para>
		/// </summary>
		public static void SetConnectionName(HSteamNetConnection hPeer, string pszName) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pszName2 = new InteropHelp.UTF8StringHandle(pszName)) {
				NativeMethods.ISteamNetworkingSockets_SetConnectionName(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hPeer, pszName2);
			}
		}

		/// <summary>
		/// <para> Fetch connection name.  Returns false if handle is invalid</para>
		/// <para>获取连接名称。如果句柄无效则返回false</para>
		/// </summary>
		public static bool GetConnectionName(HSteamNetConnection hPeer, out string pszName, int nMaxLen) {
			InteropHelp.TestIfAvailableGameServer();
			IntPtr pszName2 = Marshal.AllocHGlobal(nMaxLen);
			bool ret = NativeMethods.ISteamNetworkingSockets_GetConnectionName(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hPeer, pszName2, nMaxLen);
			pszName = ret ? InteropHelp.PtrToStringUTF8(pszName2) : null;
			Marshal.FreeHGlobal(pszName2);
			return ret;
		}

		/// <summary>
		/// <para> Send a message to the remote host on the specified connection.</para>
		/// <para> nSendFlags determines the delivery guarantees that will be provided,</para>
		/// <para> when data should be buffered, etc.  E.g. k_nSteamNetworkingSend_Unreliable</para>
		/// <para> Note that the semantics we use for messages are not precisely</para>
		/// <para> the same as the semantics of a standard "stream" socket.</para>
		/// <para> (SOCK_STREAM)  For an ordinary stream socket, the boundaries</para>
		/// <para> between chunks are not considered relevant, and the sizes of</para>
		/// <para> the chunks of data written will not necessarily match up to</para>
		/// <para> the sizes of the chunks that are returned by the reads on</para>
		/// <para> the other end.  The remote host might read a partial chunk,</para>
		/// <para> or chunks might be coalesced.  For the message semantics</para>
		/// <para> used here, however, the sizes WILL match.  Each send call</para>
		/// <para> will match a successful read call on the remote host</para>
		/// <para> one-for-one.  If you are porting existing stream-oriented</para>
		/// <para> code to the semantics of reliable messages, your code should</para>
		/// <para> work the same, since reliable message semantics are more</para>
		/// <para> strict than stream semantics.  The only caveat is related to</para>
		/// <para> performance: there is per-message overhead to retain the</para>
		/// <para> message sizes, and so if your code sends many small chunks</para>
		/// <para> of data, performance will suffer. Any code based on stream</para>
		/// <para> sockets that does not write excessively small chunks will</para>
		/// <para> work without any changes.</para>
		/// <para> The pOutMessageNumber is an optional pointer to receive the</para>
		/// <para> message number assigned to the message, if sending was successful.</para>
		/// <para> Returns:</para>
		/// <para> - k_EResultInvalidParam: invalid connection handle, or the individual message is too big.</para>
		/// <para>   (See k_cbMaxSteamNetworkingSocketsMessageSizeSend)</para>
		/// <para> - k_EResultInvalidState: connection is in an invalid state</para>
		/// <para> - k_EResultNoConnection: connection has ended</para>
		/// <para> - k_EResultIgnored: You used k_nSteamNetworkingSend_NoDelay, and the message was dropped because</para>
		/// <para>   we were not ready to send it.</para>
		/// <para> - k_EResultLimitExceeded: there was already too much data queued to be sent.</para>
		/// <para>   (See k_ESteamNetworkingConfig_SendBufferSize)</para>
		/// <para>向指定连接的远程主机发送消息。</para>
		/// <para>nSendFlags 确定将提供的交付保证、数据应缓冲的时间等。例如，k_nSteamNetworkingSend_Unreliable</para>
		/// <para>请注意，我们用于消息的语义与标准“流”套接字（SOCK_STREAM）的语义并不完全相同。对于普通的流套接字，数据块之间的边界不被认为是相关的，写入的数据块的大小可能与另一端读取返回的块大小不匹配。远程主机可能会读取一个部分块，或者块可能会合并。但是，对于此处使用的消息语义，大小会匹配。每个发送调用将对应于远程主机的一个成功的读取调用。如果您将现有的面向流的代码移植到可靠消息的语义，您的代码将正常工作，因为可靠消息语义比流语义更严格。唯一的注意事项是与性能相关：为了保留消息大小，存在每条消息的开销，因此，如果您的代码发送许多小数据块，则性能会受到影响。基于流套接字的任何不写入过度小数据块的代码都不会需要任何更改。</para>
		/// <para>pOutMessageNumber 是一个可选的指针，用于接收发送成功后分配的消息编号。</para>
		/// <para>返回：- k_EResultInvalidParam：连接句柄无效，或消息内容过大。（参见 k_cbMaxSteamNetworkingSocketsMessageSizeSend）- k_EResultInvalidState：连接处于无效状态- k_EResultNoConnection：连接已断开- k_EResultIgnored：您使用了 k_nSteamNetworkingSend_NoDelay，消息被丢弃是因为我们尚未准备好发送它。- k_EResultLimitExceeded：已排队的数据过多，无法发送。（参见 k_ESteamNetworkingConfig_SendBufferSize）</para>
		/// </summary>
		public static EResult SendMessageToConnection(HSteamNetConnection hConn, IntPtr pData, uint cbData, int nSendFlags, out long pOutMessageNumber) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_SendMessageToConnection(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn, pData, cbData, nSendFlags, out pOutMessageNumber);
		}

		/// <summary>
		/// <para> Send one or more messages without copying the message payload.</para>
		/// <para> This is the most efficient way to send messages. To use this</para>
		/// <para> function, you must first allocate a message object using</para>
		/// <para> ISteamNetworkingUtils::AllocateMessage.  (Do not declare one</para>
		/// <para> on the stack or allocate your own.)</para>
		/// <para> You should fill in the message payload.  You can either let</para>
		/// <para> it allocate the buffer for you and then fill in the payload,</para>
		/// <para> or if you already have a buffer allocated, you can just point</para>
		/// <para> m_pData at your buffer and set the callback to the appropriate function</para>
		/// <para> to free it.  Note that if you use your own buffer, it MUST remain valid</para>
		/// <para> until the callback is executed.  And also note that your callback can be</para>
		/// <para> invoked at any time from any thread (perhaps even before SendMessages</para>
		/// <para> returns!), so it MUST be fast and threadsafe.</para>
		/// <para> You MUST also fill in:</para>
		/// <para> - m_conn - the handle of the connection to send the message to</para>
		/// <para> - m_nFlags - bitmask of k_nSteamNetworkingSend_xxx flags.</para>
		/// <para> All other fields are currently reserved and should not be modified.</para>
		/// <para> The library will take ownership of the message structures.  They may</para>
		/// <para> be modified or become invalid at any time, so you must not read them</para>
		/// <para> after passing them to this function.</para>
		/// <para> pOutMessageNumberOrResult is an optional array that will receive,</para>
		/// <para> for each message, the message number that was assigned to the message</para>
		/// <para> if sending was successful.  If sending failed, then a negative EResult</para>
		/// <para> value is placed into the array.  For example, the array will hold</para>
		/// <para> -k_EResultInvalidState if the connection was in an invalid state.</para>
		/// <para> See ISteamNetworkingSockets::SendMessageToConnection for possible</para>
		/// <para> failure codes.</para>
		/// <para>发送一个或多个消息，但不复制消息 payload。这是最有效的方式发送消息。要使用此函数，您首先必须使用 ISteamNetworkingUtils::AllocateMessage 分配一个消息对象。（不要在堆上声明或自行分配。）</para>
		/// <para>你应该填充消息负载。你可以让它为你分配缓冲区，然后填充负载，或者如果你已经分配了缓冲区，只需将 `m_pData` 指向你的缓冲区，并将回调设置为适当的函数来释放它。请注意，如果使用你自己的缓冲区，它必须在回调执行之前保持有效。并且请注意，你的回调可以在任何时间、任何线程（甚至在 `SendMessages` 返回之前！）被调用，因此它必须快速且线程安全。</para>
		/// <para>你必须也填写以下内容： - m_conn - 连接句柄，用于发送消息 - m_nFlags - k_nSteamNetworkingSend_xxx 标志位的位掩码</para>
		/// <para>其他字段目前已被保留，请勿修改。</para>
		/// <para>图书馆将拥有消息结构的控制权。它们可能随时被修改或变得无效，因此您在将它们传递给此函数后，不得再次读取它们。</para>
		/// <para>pOutMessageNumberOrResult 是一个可选的数组，用于接收，对于每个消息，如果发送成功，则会接收消息编号；如果发送失败，则会将一个负的 EResult 值放入数组中。例如，数组将包含 -k_EResultInvalidState 如果连接处于无效状态。请参见 ISteamNetworkingSockets::SendMessageToConnection 以获取可能的失败代码。</para>
		/// </summary>
		public static void SendMessages(int nMessages, IntPtr[] pMessages, long[] pOutMessageNumberOrResult) {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamNetworkingSockets_SendMessages(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), nMessages, pMessages, pOutMessageNumberOrResult);
		}

		/// <summary>
		/// <para> Flush any messages waiting on the Nagle timer and send them</para>
		/// <para> at the next transmission opportunity (often that means right now).</para>
		/// <para> If Nagle is enabled (it's on by default) then when calling</para>
		/// <para> SendMessageToConnection the message will be buffered, up to the Nagle time</para>
		/// <para> before being sent, to merge small messages into the same packet.</para>
		/// <para> (See k_ESteamNetworkingConfig_NagleTime)</para>
		/// <para> Returns:</para>
		/// <para> k_EResultInvalidParam: invalid connection handle</para>
		/// <para> k_EResultInvalidState: connection is in an invalid state</para>
		/// <para> k_EResultNoConnection: connection has ended</para>
		/// <para> k_EResultIgnored: We weren't (yet) connected, so this operation has no effect.</para>
		/// <para>清除Nagle计时器上的所有等待消息，并在下一次传输机会时发送它们（通常意味着现在）。</para>
		/// <para>如果Nagle已启用（默认启用），则调用SendMessageToConnection时，消息将被缓冲，直到Nagle时间之前，将其合并到同一个数据包中。（参见k_ESteamNetworkingConfig_NagleTime）</para>
		/// <para>返回：k_EResultInvalidParam：无效连接句柄 k_EResultInvalidState：连接处于无效状态 k_EResultNoConnection：连接已断开 k_EResultIgnored：我们尚未连接，因此此操作没有效果。</para>
		/// </summary>
		public static EResult FlushMessagesOnConnection(HSteamNetConnection hConn) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_FlushMessagesOnConnection(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn);
		}

		/// <summary>
		/// <para> Fetch the next available message(s) from the connection, if any.</para>
		/// <para> Returns the number of messages returned into your array, up to nMaxMessages.</para>
		/// <para> If the connection handle is invalid, -1 is returned.</para>
		/// <para> The order of the messages returned in the array is relevant.</para>
		/// <para> Reliable messages will be received in the order they were sent (and with the</para>
		/// <para> same sizes --- see SendMessageToConnection for on this subtle difference from a stream socket).</para>
		/// <para> Unreliable messages may be dropped, or delivered out of order with respect to</para>
		/// <para> each other or with respect to reliable messages.  The same unreliable message</para>
		/// <para> may be received multiple times.</para>
		/// <para> If any messages are returned, you MUST call SteamNetworkingMessage_t::Release() on each</para>
		/// <para> of them free up resources after you are done.  It is safe to keep the object alive for</para>
		/// <para> a little while (put it into some queue, etc), and you may call Release() from any thread.</para>
		/// <para>从连接中获取下一个可用的消息（们），如果存在的话。返回已返回的消息数，最多 nMaxMessages 条。如果连接句柄无效，则返回 -1。</para>
		/// <para>数组中返回的消息顺序相关。可靠的消息将按照它们发送的顺序接收（并且具有相同的尺寸---参见 SendMessageToConnection 关于这种与流套接字细微差异）。</para>
		/// <para>不可靠的消息可能会丢失，或者与其它可靠消息或与其它不可靠消息顺序错乱地被传递。相同的不可靠消息可能会被接收多次。</para>
		/// <para>如果返回任何消息，你必须在完成使用后，对每个消息调用 SteamNetworkingMessage_t::Release() 以释放资源。可以安全地将对象保留一段时间（放入队列等），并且你可以从任何线程调用 Release()。</para>
		/// </summary>
		public static int ReceiveMessagesOnConnection(HSteamNetConnection hConn, IntPtr[] ppOutMessages, int nMaxMessages) {
			InteropHelp.TestIfAvailableGameServer();
			if (ppOutMessages != null && ppOutMessages.Length != nMaxMessages) {
				throw new System.ArgumentException("ppOutMessages must be the same size as nMaxMessages!");
			}
			return NativeMethods.ISteamNetworkingSockets_ReceiveMessagesOnConnection(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn, ppOutMessages, nMaxMessages);
		}

		/// <summary>
		/// <para> Returns basic information about the high-level state of the connection.</para>
		/// <para>返回关于连接的高级状态基本信息。</para>
		/// </summary>
		public static bool GetConnectionInfo(HSteamNetConnection hConn, out SteamNetConnectionInfo_t pInfo) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetConnectionInfo(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn, out pInfo);
		}

		/// <summary>
		/// <para> Returns a small set of information about the real-time state of the connection</para>
		/// <para> and the queue status of each lane.</para>
		/// <para> - pStatus may be NULL if the information is not desired.  (E.g. you are only interested</para>
		/// <para>   in the lane information.)</para>
		/// <para> - On entry, nLanes specifies the length of the pLanes array.  This may be 0</para>
		/// <para>   if you do not wish to receive any lane data.  It's OK for this to be smaller than</para>
		/// <para>   the total number of configured lanes.</para>
		/// <para> - pLanes points to an array that will receive lane-specific info.  It can be NULL</para>
		/// <para>   if this is not needed.</para>
		/// <para> Return value:</para>
		/// <para> - k_EResultNoConnection - connection handle is invalid or connection has been closed.</para>
		/// <para> - k_EResultInvalidParam - nLanes is bad</para>
		/// <para>返回关于实时连接状态和每个车道队列状态的少量信息。</para>
		/// <para>状态可能为NULL，如果不需要该信息。 (例如，你只对车道信息感兴趣。) - 在进入时，nLanes 指定 pLanes 数组的长度。如果不需要接收任何车道数据，则可以将其设置为0。允许此值小于配置的总车道数。 - pLanes 指向一个数组，该数组将接收车道特定信息。如果不需要，它也可以为NULL。</para>
		/// <para>返回值：- k_EResultNoConnection - 连接句柄无效或连接已关闭。- k_EResultInvalidParam - nLanes 无效。</para>
		/// </summary>
		public static EResult GetConnectionRealTimeStatus(HSteamNetConnection hConn, ref SteamNetConnectionRealTimeStatus_t pStatus, int nLanes, ref SteamNetConnectionRealTimeLaneStatus_t pLanes) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetConnectionRealTimeStatus(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn, ref pStatus, nLanes, ref pLanes);
		}

		/// <summary>
		/// <para> Returns detailed connection stats in text format.  Useful</para>
		/// <para> for dumping to a log, etc.</para>
		/// <para> Returns:</para>
		/// <para> -1 failure (bad connection handle)</para>
		/// <para> 0 OK, your buffer was filled in and '\0'-terminated</para>
		/// <para> &gt;0 Your buffer was either nullptr, or it was too small and the text got truncated.</para>
		/// <para>    Try again with a buffer of at least N bytes.</para>
		/// <para>提供详细的连接统计信息，以文本格式输出。 方便用于导出到日志等。</para>
		/// <para>返回：-1 失败 (坏连接句柄) 0 OK，你的缓冲区已填充并以'\0'结尾 >0 你的缓冲区要么是 nullptr，要么太小，文本被截断。请尝试使用至少 N 字节的缓冲区。</para>
		/// </summary>
		public static int GetDetailedConnectionStatus(HSteamNetConnection hConn, out string pszBuf, int cbBuf) {
			InteropHelp.TestIfAvailableGameServer();
			IntPtr pszBuf2 = Marshal.AllocHGlobal(cbBuf);
			int ret = NativeMethods.ISteamNetworkingSockets_GetDetailedConnectionStatus(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn, pszBuf2, cbBuf);
			pszBuf = ret != -1 ? InteropHelp.PtrToStringUTF8(pszBuf2) : null;
			Marshal.FreeHGlobal(pszBuf2);
			return ret;
		}

		/// <summary>
		/// <para> Returns local IP and port that a listen socket created using CreateListenSocketIP is bound to.</para>
		/// <para> An IPv6 address of ::0 means "any IPv4 or IPv6"</para>
		/// <para> An IPv6 address of ::ffff:0000:0000 means "any IPv4"</para>
		/// <para>返回使用 CreateListenSocketIP 创建的监听套接字所绑定的本地 IP 和端口。</para>
		/// <para>一个 IPv6 地址为 ::0 表示“任何 IPv4 或 IPv6”。一个 IPv6 地址为 ::ffff:0000:0000 表示“任何 IPv4”。</para>
		/// </summary>
		public static bool GetListenSocketAddress(HSteamListenSocket hSocket, out SteamNetworkingIPAddr address) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetListenSocketAddress(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hSocket, out address);
		}

		/// <summary>
		/// <para> Create a pair of connections that are talking to each other, e.g. a loopback connection.</para>
		/// <para> This is very useful for testing, or so that your client/server code can work the same</para>
		/// <para> even when you are running a local "server".</para>
		/// <para> The two connections will immediately be placed into the connected state, and no callbacks</para>
		/// <para> will be posted immediately.  After this, if you close either connection, the other connection</para>
		/// <para> will receive a callback, exactly as if they were communicating over the network.  You must</para>
		/// <para> close *both* sides in order to fully clean up the resources!</para>
		/// <para> By default, internal buffers are used, completely bypassing the network, the chopping up of</para>
		/// <para> messages into packets, encryption, copying the payload, etc.  This means that loopback</para>
		/// <para> packets, by default, will not simulate lag or loss.  Passing true for bUseNetworkLoopback will</para>
		/// <para> cause the socket pair to send packets through the local network loopback device (127.0.0.1)</para>
		/// <para> on ephemeral ports.  Fake lag and loss are supported in this case, and CPU time is expended</para>
		/// <para> to encrypt and decrypt.</para>
		/// <para> If you wish to assign a specific identity to either connection, you may pass a particular</para>
		/// <para> identity.  Otherwise, if you pass nullptr, the respective connection will assume a generic</para>
		/// <para> "localhost" identity.  If you use real network loopback, this might be translated to the</para>
		/// <para> actual bound loopback port.  Otherwise, the port will be zero.</para>
		/// <para>创建一个连接对，例如回环连接。这对于测试非常有用，或者使你的客户端/服务器代码即使在运行本地“服务器”时也能正常工作。</para>
		/// <para>这两个连接会立即进入已连接状态，不会立即发布任何回调。之后，如果关闭其中一个连接，另一个连接会收到回调，就像它们在网络上进行通信一样。为了完全清理资源，您必须关闭双方！</para>
		/// <para>默认情况下，使用内部缓冲区，完全绕过网络，消息被切分成数据包，进行加密，复制有效负载等操作。这意味着，默认情况下，回环包不会模拟延迟或丢失。将 true 设置为 bUseNetworkLoopback 将导致套接字对通过本地网络回环设备 (127.0.0.1) 在非永生端口上发送数据包。在这种情况下，支持模拟延迟和丢失，并且会消耗 CPU 时间进行加密和解密。</para>
		/// <para>如果您希望为连接分配特定的身份，您可以传递特定的身份。否则，如果传递 `nullptr`，相应的连接将假设一个通用的“localhost”身份。如果使用真实的网络回环，这可能会被翻译为实际绑定的回环端口。否则，端口将为零。</para>
		/// </summary>
		public static bool CreateSocketPair(out HSteamNetConnection pOutConnection1, out HSteamNetConnection pOutConnection2, bool bUseNetworkLoopback, ref SteamNetworkingIdentity pIdentity1, ref SteamNetworkingIdentity pIdentity2) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_CreateSocketPair(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), out pOutConnection1, out pOutConnection2, bUseNetworkLoopback, ref pIdentity1, ref pIdentity2);
		}

		/// <summary>
		/// <para> Configure multiple outbound messages streams ("lanes") on a connection, and</para>
		/// <para> control head-of-line blocking between them.  Messages within a given lane</para>
		/// <para> are always sent in the order they are queued, but messages from different</para>
		/// <para> lanes may be sent out of order.  Each lane has its own message number</para>
		/// <para> sequence.  The first message sent on each lane will be assigned the number 1.</para>
		/// <para> Each lane has a "priority".  Lanes with higher numeric values will only be processed</para>
		/// <para> when all lanes with lower number values are empty.  The magnitudes of the priority</para>
		/// <para> values are not relevant, only their sort order.</para>
		/// <para> Each lane also is assigned a weight, which controls the approximate proportion</para>
		/// <para> of the bandwidth that will be consumed by the lane, relative to other lanes</para>
		/// <para> of the same priority.  (This is assuming the lane stays busy.  An idle lane</para>
		/// <para> does not build up "credits" to be be spent once a message is queued.)</para>
		/// <para> This value is only meaningful as a proportion, relative to other lanes with</para>
		/// <para> the same priority.  For lanes with different priorities, the strict priority</para>
		/// <para> order will prevail, and their weights relative to each other are not relevant.</para>
		/// <para> Thus, if a lane has a unique priority value, the weight value for that lane is</para>
		/// <para> not relevant.</para>
		/// <para> Example: 3 lanes, with priorities [ 0, 10, 10 ] and weights [ (NA), 20, 5 ].</para>
		/// <para> Messages sent on the first will always be sent first, before messages in the</para>
		/// <para> other two lanes.  Its weight value is irrelevant, since there are no other</para>
		/// <para> lanes with priority=0.  The other two lanes will share bandwidth, with the second</para>
		/// <para> and third lanes sharing bandwidth using a ratio of approximately 4:1.</para>
		/// <para> (The weights [ NA, 4, 1 ] would be equivalent.)</para>
		/// <para> Notes:</para>
		/// <para> - At the time of this writing, some code has performance cost that is linear</para>
		/// <para>   in the number of lanes, so keep the number of lanes to an absolute minimum.</para>
		/// <para>   3 or so is fine; &gt;8 is a lot.  The max number of lanes on Steam is 255,</para>
		/// <para>   which is a very large number and not recommended!  If you are compiling this</para>
		/// <para>   library from source, see STEAMNETWORKINGSOCKETS_MAX_LANES.)</para>
		/// <para> - Lane priority values may be any int.  Their absolute value is not relevant,</para>
		/// <para>   only the order matters.</para>
		/// <para> - Weights must be positive, and due to implementation details, they are restricted</para>
		/// <para>   to 16-bit values.  The absolute magnitudes don't matter, just the proportions.</para>
		/// <para> - Messages sent on a lane index other than 0 have a small overhead on the wire,</para>
		/// <para>   so for maximum wire efficiency, lane 0 should be the "most common" lane, regardless</para>
		/// <para>   of priorities or weights.</para>
		/// <para> - A connection has a single lane by default.  Calling this function with</para>
		/// <para>   nNumLanes=1 is legal, but pointless, since the priority and weight values are</para>
		/// <para>   irrelevant in that case.</para>
		/// <para> - You may reconfigure connection lanes at any time, however reducing the number of</para>
		/// <para>   lanes is not allowed.</para>
		/// <para> - Reconfiguring lanes might restart any bandwidth sharing balancing.  Usually you</para>
		/// <para>   will call this function once, near the start of the connection, perhaps after</para>
		/// <para>   exchanging a few messages.</para>
		/// <para> - To assign all lanes the same priority, you may use pLanePriorities=NULL.</para>
		/// <para> - If you wish all lanes with the same priority to share bandwidth equally (or</para>
		/// <para>   if no two lanes have the same priority value, and thus priority values are</para>
		/// <para>   irrelevant), you may use pLaneWeights=NULL</para>
		/// <para> - Priorities and weights determine the order that messages are SENT on the wire.</para>
		/// <para>   There are NO GUARANTEES on the order that messages are RECEIVED!  Due to packet</para>
		/// <para>   loss, out-of-order delivery, and subtle details of packet serialization, messages</para>
		/// <para>   might still be received slightly out-of-order!  The *only* strong guarantee is that</para>
		/// <para>   *reliable* messages on the *same lane* will be delivered in the order they are sent.</para>
		/// <para> - Each host configures the lanes for the packets they send; the lanes for the flow</para>
		/// <para>   in one direction are completely unrelated to the lanes in the opposite direction.</para>
		/// <para> Return value:</para>
		/// <para> - k_EResultNoConnection - bad hConn</para>
		/// <para> - k_EResultInvalidParam - Invalid number of lanes, bad weights, or you tried to reduce the number of lanes</para>
		/// <para> - k_EResultInvalidState - Connection is already dead, etc</para>
		/// <para> See also:</para>
		/// <para> SteamNetworkingMessage_t::m_idxLane</para>
		/// <para>配置多个出站消息流（“lanes”）在连接上，并控制它们之间的头文件阻塞。在给定的lanes内，消息始终按照它们排队的顺序发送，但来自不同lanes的消息可能按顺序发送。每个lanes都有自己的消息编号序列。每个lanes中首先发送的消息将被分配数字 1。</para>
		/// <para>每个通道都有一个“优先级”。具有较高数字值的通道只有在所有具有较低数字值的通道都为空时才会进行处理。优先级值的 magnitudes 不重要，只重要的是它们的排序顺序。</para>
		/// <para>每个通道也被分配了一个权重，它控制了该通道将消耗的带宽比例，相对于相同优先级的其他通道。 （前提是该通道保持繁忙。空闲的通道不会积累“信用”用于在消息排队后花费。） 这种值仅在与其他具有相同优先级的通道进行比较时才有意义。对于具有不同优先级的通道，严格的优先级顺序将生效，并且它们之间的相对权重不相关。因此，如果一个通道具有唯一的优先级值，则该通道的权重值不相关。</para>
		/// <para>示例：3条线路，优先级为[0, 10, 10]和权重为[(NA), 20, 5]。在第一条线路发送的消息将始终优先发送，在其他两条线路的消息之前。其权重值不重要，因为没有其他优先级为0的线路。另外两条线路将共享带宽，第二条和第三条线路将使用大约4:1的比例共享带宽。（权重[NA, 4, 1]等效。）</para>
		/// <para>备注：- 在编写时，某些代码具有与行数成线性关系的性能成本，因此请将行数保持在绝对最小值。3个左右是可以的；>8个很多。Steam的最大行数为255，这是一个非常大的数字，不建议使用！如果您从源代码编译此库，请参阅STEAMNETWORKINGSOCKETS_MAX_LANES。- 行优先级值可以是任何整数。其绝对值不重要，仅顺序重要。- 权重必须为正数，并且由于实现细节，它们受到16位值的限制。绝对大小不重要，仅比例重要。- 在非0行索引上发送的消息会产生少量线路开销，因此为了最大程度地提高线路效率，无论优先级或权重如何，行0应是“最常见”的行。- 连接默认具有单行。使用nNumLanes=1调用此函数是合法的，但毫无意义，因为在这种情况下，优先级和权重值不重要。- 您可以随时重新配置连接行，但不允许减少行数。- 重新配置行可能会重新启动任何带宽共享平衡。通常您会调用此函数一次，在连接的开始附近，例如在交换了几条消息后。- 要为所有行分配相同的优先级，可以使用pLanePriorities=NULL。- 如果您希望具有相同优先级的所有行以相同的带宽共享（或如果没有任何两个行具有相同的优先级值，因此优先级值不重要），则可以使用pLaneWeights=NULL。- 优先级和权重确定消息在“线路”上发送的顺序。没有任何关于消息接收顺序的保证！由于包丢失、乱序交付和细微的包序列化细节，消息仍然可能略微乱序接收！*唯一*的强保证是*可靠*消息在*同一行*上按发送顺序交付。- 每个主机都配置发送的行；一个方向的行与相反方向的行完全无关。</para>
		/// <para>返回值：- k_EResultNoConnection - bad hConn - k_EResultInvalidParam - 无效的通道数量、无效的权重，或者您尝试减少通道数量 - k_EResultInvalidState - 连接已断开，等。</para>
		/// <para>参见：SteamNetworkingMessage_t::m_idxLane</para>
		/// </summary>
		public static EResult ConfigureConnectionLanes(HSteamNetConnection hConn, int nNumLanes, int[] pLanePriorities, ushort[] pLaneWeights) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_ConfigureConnectionLanes(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn, nNumLanes, pLanePriorities, pLaneWeights);
		}

		/// <summary>
		/// <para> Identity and authentication</para>
		/// <para> Get the identity assigned to this interface.</para>
		/// <para> E.g. on Steam, this is the user's SteamID, or for the gameserver interface, the SteamID assigned</para>
		/// <para> to the gameserver.  Returns false and sets the result to an invalid identity if we don't know</para>
		/// <para> our identity yet.  (E.g. GameServer has not logged in.  On Steam, the user will know their SteamID</para>
		/// <para> even if they are not signed into Steam.)</para>
		/// <para>身份验证和认证</para>
		/// <para>获取该接口的身份标识。例如，在Steam上，这是用户的SteamID，或者对于游戏服务器接口，是分配给游戏服务器的SteamID。如果此时我们还不清楚自己的身份，则返回false并设置结果为无效身份。 (例如，GameServer尚未登录。在Steam上，即使用户未登录Steam，他们仍然知道自己的SteamID。)</para>
		/// </summary>
		public static bool GetIdentity(out SteamNetworkingIdentity pIdentity) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetIdentity(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), out pIdentity);
		}

		/// <summary>
		/// <para> Indicate our desire to be ready participate in authenticated communications.</para>
		/// <para> If we are currently not ready, then steps will be taken to obtain the necessary</para>
		/// <para> certificates.   (This includes a certificate for us, as well as any CA certificates</para>
		/// <para> needed to authenticate peers.)</para>
		/// <para> You can call this at program init time if you know that you are going to</para>
		/// <para> be making authenticated connections, so that we will be ready immediately when</para>
		/// <para> those connections are attempted.  (Note that essentially all connections require</para>
		/// <para> authentication, with the exception of ordinary UDP connections with authentication</para>
		/// <para> disabled using k_ESteamNetworkingConfig_IP_AllowWithoutAuth.)  If you don't call</para>
		/// <para> this function, we will wait until a feature is utilized that that necessitates</para>
		/// <para> these resources.</para>
		/// <para> You can also call this function to force a retry, if failure has occurred.</para>
		/// <para> Once we make an attempt and fail, we will not automatically retry.</para>
		/// <para> In this respect, the behavior of the system after trying and failing is the same</para>
		/// <para> as before the first attempt: attempting authenticated communication or calling</para>
		/// <para> this function will call the system to attempt to acquire the necessary resources.</para>
		/// <para> You can use GetAuthenticationStatus or listen for SteamNetAuthenticationStatus_t</para>
		/// <para> to monitor the status.</para>
		/// <para> Returns the current value that would be returned from GetAuthenticationStatus.</para>
		/// <para>表明我们希望能够参与认证通信。如果目前还未准备好，将采取措施获取所需的证书。（包括为我们颁发的证书，以及用于认证同伴所需的任何CA证书。）</para>
		/// <para>你可以在此程序初始化时调用它，如果你知道你将要建立认证连接，以便我们能够在这些连接尝试时立即准备就绪。 (注意，基本上所有连接都需要认证，除非使用 k_ESteamNetworkingConfig_IP_AllowWithoutAuth 禁用认证的普通 UDP 连接。) 如果你没有调用此函数，我们将等待某个功能被使用时才需要这些资源。</para>
		/// <para>你也可以调用这个函数来强制重试，如果发生失败情况。一旦我们尝试并失败，系统就不会自动重试。在这一点，尝试并失败后系统的行为与第一次尝试之前完全相同：尝试进行身份验证的通信或调用这个函数都会使系统尝试获取所需的资源。</para>
		/// <para>你可以使用 GetAuthenticationStatus 或监听 SteamNetAuthenticationStatus_t 来监控状态。</para>
		/// <para>返回当前由 GetAuthenticationStatus 函数将返回的值。</para>
		/// </summary>
		public static ESteamNetworkingAvailability InitAuthentication() {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_InitAuthentication(CSteamGameServerAPIContext.GetSteamNetworkingSockets());
		}

		/// <summary>
		/// <para> Query our readiness to participate in authenticated communications.  A</para>
		/// <para> SteamNetAuthenticationStatus_t callback is posted any time this status changes,</para>
		/// <para> but you can use this function to query it at any time.</para>
		/// <para> The value of SteamNetAuthenticationStatus_t::m_eAvail is returned.  If you only</para>
		/// <para> want this high level status, you can pass NULL for pDetails.  If you want further</para>
		/// <para> details, pass non-NULL to receive them.</para>
		/// <para>查询我们参与身份验证通信的准备情况。当此状态发生变化时，会发布一个 SteamNetAuthenticationStatus_t 回调，但您可以使用此函数随时查询它。</para>
		/// <para>返回 SteamNetAuthenticationStatus_t::m_eAvail 的值。 如果您只想获取此高级状态，则可以将 pDetails 设置为 NULL。 如果您需要更多详细信息，请将 pDetails 设置为非 NULL 以接收它们。</para>
		/// </summary>
		public static ESteamNetworkingAvailability GetAuthenticationStatus(out SteamNetAuthenticationStatus_t pDetails) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetAuthenticationStatus(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), out pDetails);
		}

		/// <summary>
		/// <para> Poll groups.  A poll group is a set of connections that can be polled efficiently.</para>
		/// <para> (In our API, to "poll" a connection means to retrieve all pending messages.  We</para>
		/// <para> actually don't have an API to "poll" the connection *state*, like BSD sockets.)</para>
		/// <para> Create a new poll group.</para>
		/// <para> You should destroy the poll group when you are done using DestroyPollGroup</para>
		/// <para>调查组。调查组是一个可以高效调查的连接集合。 (在我们的API中，“调查”一个连接意味着检索所有待处理的消息。我们实际上没有“调查”连接*状态*的API，例如BSD套接字。)</para>
		/// <para>创建新的投票组。</para>
		/// <para>你应该在完成使用时销毁投票组。</para>
		/// </summary>
		public static HSteamNetPollGroup CreatePollGroup() {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamNetPollGroup)NativeMethods.ISteamNetworkingSockets_CreatePollGroup(CSteamGameServerAPIContext.GetSteamNetworkingSockets());
		}

		/// <summary>
		/// <para> Destroy a poll group created with CreatePollGroup().</para>
		/// <para> If there are any connections in the poll group, they are removed from the group,</para>
		/// <para> and left in a state where they are not part of any poll group.</para>
		/// <para> Returns false if passed an invalid poll group handle.</para>
		/// <para>销毁使用 CreatePollGroup() 创建的投票组。</para>
		/// <para>如果投票组中存在任何连接，则从组中移除它们，并将它们置于不再属于任何投票组的状态。如果传入无效的投票组句柄，则返回false。</para>
		/// </summary>
		public static bool DestroyPollGroup(HSteamNetPollGroup hPollGroup) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_DestroyPollGroup(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hPollGroup);
		}

		/// <summary>
		/// <para> Assign a connection to a poll group.  Note that a connection may only belong to a</para>
		/// <para> single poll group.  Adding a connection to a poll group implicitly removes it from</para>
		/// <para> any other poll group it is in.</para>
		/// <para> You can pass k_HSteamNetPollGroup_Invalid to remove a connection from its current</para>
		/// <para> poll group without adding it to a new poll group.</para>
		/// <para> If there are received messages currently pending on the connection, an attempt</para>
		/// <para> is made to add them to the queue of messages for the poll group in approximately</para>
		/// <para> the order that would have applied if the connection was already part of the poll</para>
		/// <para> group at the time that the messages were received.</para>
		/// <para> Returns false if the connection handle is invalid, or if the poll group handle</para>
		/// <para> is invalid (and not k_HSteamNetPollGroup_Invalid).</para>
		/// <para>将连接分配到投票组。请注意，一个连接只能属于一个投票组。将连接添加到投票组会使其从任何它所属的投票组中移除。</para>
		/// <para>你可以通过 k_HSteamNetPollGroup_Invalid 移除连接从其当前的 polled 组中，而无需将其添加到新的 polled 组中。</para>
		/// <para>如果当前连接上存在待处理的消息，则会尝试将它们添加到 poll 组的消息队列中，大致按照消息接收时连接如果已是 poll 组的一员所应该应用的顺序添加。</para>
		/// <para>如果连接句柄无效，或者如果 poll 组句柄无效（且不为 k_HSteamNetPollGroup_Invalid），则返回 false。</para>
		/// </summary>
		public static bool SetConnectionPollGroup(HSteamNetConnection hConn, HSteamNetPollGroup hPollGroup) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_SetConnectionPollGroup(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn, hPollGroup);
		}

		/// <summary>
		/// <para> Same as ReceiveMessagesOnConnection, but will return the next messages available</para>
		/// <para> on any connection in the poll group.  Examine SteamNetworkingMessage_t::m_conn</para>
		/// <para> to know which connection.  (SteamNetworkingMessage_t::m_nConnUserData might also</para>
		/// <para> be useful.)</para>
		/// <para> Delivery order of messages among different connections will usually match the</para>
		/// <para> order that the last packet was received which completed the message.  But this</para>
		/// <para> is not a strong guarantee, especially for packets received right as a connection</para>
		/// <para> is being assigned to poll group.</para>
		/// <para> Delivery order of messages on the same connection is well defined and the</para>
		/// <para> same guarantees are present as mentioned in ReceiveMessagesOnConnection.</para>
		/// <para> (But the messages are not grouped by connection, so they will not necessarily</para>
		/// <para> appear consecutively in the list; they may be interleaved with messages for</para>
		/// <para> other connections.)</para>
		/// <para>与ReceiveMessagesOnConnection相同，但会返回任何连接池中可用的下一个消息。可以通过Examine SteamNetworkingMessage_t::m_conn来确定哪个连接。(SteamNetworkingMessage_t::m_nConnUserData也可能很有用。)</para>
		/// <para>不同连接之间的消息传递顺序通常会与最后一个包接收完成消息的顺序相匹配。但这并非强有力的保证，尤其是在连接被分配到轮询组时。</para>
		/// <para>同一连接的消息传递顺序已明确定义，并且与 ReceiveMessagesOnConnection 中提到的保证相同。 (但消息不会按连接分组，因此它们不会一定在列表中连续出现；它们可能会与其他连接的消息交错。)</para>
		/// </summary>
		public static int ReceiveMessagesOnPollGroup(HSteamNetPollGroup hPollGroup, IntPtr[] ppOutMessages, int nMaxMessages) {
			InteropHelp.TestIfAvailableGameServer();
			if (ppOutMessages != null && ppOutMessages.Length != nMaxMessages) {
				throw new System.ArgumentException("ppOutMessages must be the same size as nMaxMessages!");
			}
			return NativeMethods.ISteamNetworkingSockets_ReceiveMessagesOnPollGroup(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hPollGroup, ppOutMessages, nMaxMessages);
		}

		/// <summary>
		/// <para> Clients connecting to dedicated servers hosted in a data center,</para>
		/// <para> using tickets issued by your game coordinator.  If you are not</para>
		/// <para> issuing your own tickets to restrict who can attempt to connect</para>
		/// <para> to your server, then you won't use these functions.</para>
		/// <para> Call this when you receive a ticket from your backend / matchmaking system.  Puts the</para>
		/// <para> ticket into a persistent cache, and optionally returns the parsed ticket.</para>
		/// <para> See stamdatagram_ticketgen.h for more details.</para>
		/// <para>连接到数据中心托管的专用服务器的客户端，使用由您的游戏协调员签发的票务。如果您没有自行签发票务以限制哪些人可以尝试连接到您的服务器，则不会使用这些功能。</para>
		/// <para>当您从后端/匹配系统接收到票据时，请调用此方法。将票据放入持久缓存，并可选地返回解析后的票据。</para>
		/// <para>请参阅 stamdatagram_ticketgen.h 以获取更多详细信息。</para>
		/// </summary>
		public static bool ReceivedRelayAuthTicket(IntPtr pvTicket, int cbTicket, out SteamDatagramRelayAuthTicket pOutParsedTicket) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_ReceivedRelayAuthTicket(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), pvTicket, cbTicket, out pOutParsedTicket);
		}

		/// <summary>
		/// <para> Search cache for a ticket to talk to the server on the specified virtual port.</para>
		/// <para> If found, returns the number of seconds until the ticket expires, and optionally</para>
		/// <para> the complete cracked ticket.  Returns 0 if we don't have a ticket.</para>
		/// <para> Typically this is useful just to confirm that you have a ticket, before you</para>
		/// <para> call ConnectToHostedDedicatedServer to connect to the server.</para>
		/// <para>搜索缓存以获取指定虚拟端口的服务器对话票。如果找到，则返回票的到期秒数，以及可选的完整破解票。如果没有票，则返回 0。</para>
		/// <para>通常这只是为了确认您是否有票，在调用ConnectToHostedDedicatedServer连接到服务器之前使用。</para>
		/// </summary>
		public static int FindRelayAuthTicketForServer(ref SteamNetworkingIdentity identityGameServer, int nRemoteVirtualPort, out SteamDatagramRelayAuthTicket pOutParsedTicket) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_FindRelayAuthTicketForServer(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), ref identityGameServer, nRemoteVirtualPort, out pOutParsedTicket);
		}

		/// <summary>
		/// <para> Client call to connect to a server hosted in a Valve data center, on the specified virtual</para>
		/// <para> port.  You must have placed a ticket for this server into the cache, or else this connect</para>
		/// <para> attempt will fail!  If you are not issuing your own tickets, then to connect to a dedicated</para>
		/// <para> server via SDR in auto-ticket mode, use ConnectP2P.  (The server must be configured to allow</para>
		/// <para> this type of connection by listening using CreateListenSocketP2P.)</para>
		/// <para> You may wonder why tickets are stored in a cache, instead of simply being passed as an argument</para>
		/// <para> here.  The reason is to make reconnection to a gameserver robust, even if the client computer loses</para>
		/// <para> connection to Steam or the central backend, or the app is restarted or crashes, etc.</para>
		/// <para> If you use this, you probably want to call ISteamNetworkingUtils::InitRelayNetworkAccess()</para>
		/// <para> when your app initializes</para>
		/// <para> If you need to set any initial config options, pass them here.  See</para>
		/// <para> SteamNetworkingConfigValue_t for more about why this is preferable to</para>
		/// <para> setting the options "immediately" after creation.</para>
		/// <para>向托管在Valve数据中心，指定虚拟端口的服务器发起客户端调用。您必须已将此服务器放入缓存中，否则此连接尝试将会失败！如果您没有自行创建票据，则通过SDR在自动票据模式下连接到专用服务器，请使用ConnectP2P。（服务器必须配置为允许这种类型的连接，通过使用CreateListenSocketP2P监听。）</para>
		/// <para>你可能会想知道为什么门票会被存储在缓存中，而不是直接作为参数传递在这里。原因是为了即使客户端计算机丢失与Steam或中央后端之间的连接，或者应用程序重新启动或崩溃等情况，也能实现对游戏服务器的健壮重新连接。</para>
		/// <para>如果你使用这个，你可能需要调用 ISteamNetworkingUtils::InitRelayNetworkAccess() 当你的应用初始化时。</para>
		/// <para>如果需要设置任何初始配置选项，请在此处传递它们。请参阅 SteamNetworkingConfigValue_t 以了解为什么这种方法比在创建后“立即”设置选项更可取。</para>
		/// </summary>
		public static HSteamNetConnection ConnectToHostedDedicatedServer(ref SteamNetworkingIdentity identityTarget, int nRemoteVirtualPort, int nOptions, SteamNetworkingConfigValue_t[] pOptions) {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamNetConnection)NativeMethods.ISteamNetworkingSockets_ConnectToHostedDedicatedServer(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), ref identityTarget, nRemoteVirtualPort, nOptions, pOptions);
		}

		/// <summary>
		/// <para> Servers hosted in data centers known to the Valve relay network</para>
		/// <para> Returns the value of the SDR_LISTEN_PORT environment variable.  This</para>
		/// <para> is the UDP server your server will be listening on.  This will</para>
		/// <para> configured automatically for you in production environments.</para>
		/// <para> In development, you'll need to set it yourself.  See</para>
		/// <para> https://partner.steamgames.com/doc/api/ISteamNetworkingSockets</para>
		/// <para> for more information on how to configure dev environments.</para>
		/// <para>在Valve已知的数据中心托管的服务器</para>
		/// <para>返回 SDR_LISTEN_PORT 环境变量的值。这是你的服务器将监听的 UDP 服务器。在生产环境中，Valve 会自动为你配置此项。</para>
		/// <para>在开发中，您需要自己设置。有关如何配置开发环境的更多信息，请参阅 https://partner.steamgames.com/doc/api/ISteamNetworkingSockets。</para>
		/// </summary>
		public static ushort GetHostedDedicatedServerPort() {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetHostedDedicatedServerPort(CSteamGameServerAPIContext.GetSteamNetworkingSockets());
		}

		/// <summary>
		/// <para> Returns 0 if SDR_LISTEN_PORT is not set.  Otherwise, returns the data center the server</para>
		/// <para> is running in.  This will be k_SteamDatagramPOPID_dev in non-production environment.</para>
		/// <para>如果未设置 SDR_LISTEN_PORT，则返回 0。否则，返回服务器运行的的数据中心。在非生产环境中，将返回 k_SteamDatagramPOPID_dev。</para>
		/// </summary>
		public static SteamNetworkingPOPID GetHostedDedicatedServerPOPID() {
			InteropHelp.TestIfAvailableGameServer();
			return (SteamNetworkingPOPID)NativeMethods.ISteamNetworkingSockets_GetHostedDedicatedServerPOPID(CSteamGameServerAPIContext.GetSteamNetworkingSockets());
		}

		/// <summary>
		/// <para> Return info about the hosted server.  This contains the PoPID of the server,</para>
		/// <para> and opaque routing information that can be used by the relays to send traffic</para>
		/// <para> to your server.</para>
		/// <para> You will need to send this information to your backend, and put it in tickets,</para>
		/// <para> so that the relays will know how to forward traffic from</para>
		/// <para> clients to your server.  See SteamDatagramRelayAuthTicket for more info.</para>
		/// <para> Also, note that the routing information is contained in SteamDatagramGameCoordinatorServerLogin,</para>
		/// <para> so if possible, it's preferred to use GetGameCoordinatorServerLogin to send this info</para>
		/// <para> to your game coordinator service, and also login securely at the same time.</para>
		/// <para> On a successful exit, k_EResultOK is returned</para>
		/// <para> Unsuccessful exit:</para>
		/// <para> - Something other than k_EResultOK is returned.</para>
		/// <para> - k_EResultInvalidState: We are not configured to listen for SDR (SDR_LISTEN_SOCKET</para>
		/// <para>   is not set.)</para>
		/// <para> - k_EResultPending: we do not (yet) have the authentication information needed.</para>
		/// <para>   (See GetAuthenticationStatus.)  If you use environment variables to pre-fetch</para>
		/// <para>   the network config, this data should always be available immediately.</para>
		/// <para> - A non-localized diagnostic debug message will be placed in m_data that describes</para>
		/// <para>   the cause of the failure.</para>
		/// <para> NOTE: The returned blob is not encrypted.  Send it to your backend, but don't</para>
		/// <para>       directly share it with clients.</para>
		/// <para>返回托管服务器的信息。这包含服务器的PoPID以及可以由中继用于将流量发送到您服务器的非透明路由信息。</para>
		/// <para>你需要将这些信息发送到你的后端，并将其放入工单中，以便中继知道如何将客户端的流量转发到你的服务器。 参见 SteamDatagramRelayAuthTicket 了解更多信息。</para>
		/// <para>此外，请注意，路由信息包含在 SteamDatagramGameCoordinatorServerLogin 中，因此，如果可能，最好使用 GetGameCoordinatorServerLogin 将此信息发送到您的游戏协调器服务，并且同时进行安全登录。</para>
		/// <para>在成功退出时，将返回 k_EResultOK。</para>
		/// <para>失败退出：- 返回值不是 k_EResultOK。- k_EResultInvalidState：我们没有配置为监听 SDR（SDR_LISTEN_SOCKET 未设置）。- k_EResultPending：我们（目前）还没有所需的身份验证信息。（参见 GetAuthenticationStatus。）如果您使用环境变量预先获取网络配置，此数据应始终立即可用。- 将在 m_data 中放置一个非本地化诊断调试消息，描述失败的原因。</para>
		/// <para>注意：返回的 blob 未加密。请将其发送到你的后端，但不要直接与客户端共享。</para>
		/// </summary>
		public static EResult GetHostedDedicatedServerAddress(out SteamDatagramHostedAddress pRouting) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetHostedDedicatedServerAddress(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), out pRouting);
		}

		/// <summary>
		/// <para> Create a listen socket on the specified virtual port.  The physical UDP port to use</para>
		/// <para> will be determined by the SDR_LISTEN_PORT environment variable.  If a UDP port is not</para>
		/// <para> configured, this call will fail.</para>
		/// <para> This call MUST be made through the SteamGameServerNetworkingSockets() interface.</para>
		/// <para> This function should be used when you are using the ticket generator library</para>
		/// <para> to issue your own tickets.  Clients connecting to the server on this virtual</para>
		/// <para> port will need a ticket, and they must connect using ConnectToHostedDedicatedServer.</para>
		/// <para> If you need to set any initial config options, pass them here.  See</para>
		/// <para> SteamNetworkingConfigValue_t for more about why this is preferable to</para>
		/// <para> setting the options "immediately" after creation.</para>
		/// <para>创建一个监听套接字，指定虚拟端口。物理UDP端口将由SDR_LISTEN_PORT环境变量确定。如果未配置UDP端口，此调用将失败。</para>
		/// <para>这个调用必须通过 SteamGameServerNetworkingSockets() 接口进行。</para>
		/// <para>此函数应在您使用票务生成器库自行创建票务时使用。连接到该虚拟端口的客户端需要一张票务，并且必须使用 ConnectToHostedDedicatedServer 进行连接。</para>
		/// <para>如果需要设置任何初始配置选项，请在此处传递它们。请参阅 SteamNetworkingConfigValue_t 以了解为什么这种方法比在创建后“立即”设置选项更可取。</para>
		/// </summary>
		public static HSteamListenSocket CreateHostedDedicatedServerListenSocket(int nLocalVirtualPort, int nOptions, SteamNetworkingConfigValue_t[] pOptions) {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamListenSocket)NativeMethods.ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), nLocalVirtualPort, nOptions, pOptions);
		}

		/// <summary>
		/// <para> Generate an authentication blob that can be used to securely login with</para>
		/// <para> your backend, using SteamDatagram_ParseHostedServerLogin.  (See</para>
		/// <para> steamdatagram_gamecoordinator.h)</para>
		/// <para> Before calling the function:</para>
		/// <para> - Populate the app data in pLoginInfo (m_cbAppData and m_appData).  You can leave</para>
		/// <para>   all other fields uninitialized.</para>
		/// <para> - *pcbSignedBlob contains the size of the buffer at pBlob.  (It should be</para>
		/// <para>   at least k_cbMaxSteamDatagramGameCoordinatorServerLoginSerialized.)</para>
		/// <para> On a successful exit:</para>
		/// <para> - k_EResultOK is returned</para>
		/// <para> - All of the remaining fields of pLoginInfo will be filled out.</para>
		/// <para> - *pcbSignedBlob contains the size of the serialized blob that has been</para>
		/// <para>   placed into pBlob.</para>
		/// <para> Unsuccessful exit:</para>
		/// <para> - Something other than k_EResultOK is returned.</para>
		/// <para> - k_EResultNotLoggedOn: you are not logged in (yet)</para>
		/// <para> - See GetHostedDedicatedServerAddress for more potential failure return values.</para>
		/// <para> - A non-localized diagnostic debug message will be placed in pBlob that describes</para>
		/// <para>   the cause of the failure.</para>
		/// <para> This works by signing the contents of the SteamDatagramGameCoordinatorServerLogin</para>
		/// <para> with the cert that is issued to this server.  In dev environments, it's OK if you do</para>
		/// <para> not have a cert.  (You will need to enable insecure dev login in SteamDatagram_ParseHostedServerLogin.)</para>
		/// <para> Otherwise, you will need a signed cert.</para>
		/// <para> NOTE: The routing blob returned here is not encrypted.  Send it to your backend</para>
		/// <para>       and don't share it directly with clients.</para>
		/// <para>生成一个用于与你的后端安全登录时使用的认证块，使用 SteamDatagram_ParseHostedServerLogin。 (参见 steamdatagram_gamecoordinator.h)</para>
		/// <para>在调用函数之前：- 将应用数据填充到 pLoginInfo (m_cbAppData 和 m_appData) 中。你可以让其他所有字段未初始化。- *pcbSignedBlob 包含 pBlob 缓冲区的尺寸。（它应至少为 k_cbMaxSteamDatagramGameCoordinatorServerLoginSerialized。）</para>
		/// <para>在成功退出时：- 返回 k_EResultOK - pLoginInfo 剩余的所有字段将被填充 - *pcbSignedBlob 包含已放入 pBlob 中的序列化 blob 的大小。</para>
		/// <para>失败退出：- 返回值不是 k_EResultOK - k_EResultNotLoggedOn：您尚未登录（正在登录） - 参见 GetHostedDedicatedServerAddress 了解更多潜在的失败返回值。 - 故障原因的非本地化诊断调试消息将被放置在 pBlob 中。</para>
		/// <para>这通过对 SteamDatagramGameCoordinatorServerLogin 的内容进行签名，使用该服务器颁发的证书。在开发环境中，如果未提供证书也可以。 (您需要在 SteamDatagram_ParseHostedServerLogin 中启用不安全开发登录。) 否则，您需要一个签名证书。</para>
		/// <para>注意：此处返回的路由块未加密。请将其发送到您的后端，不要直接与客户端共享。</para>
		/// </summary>
		public static EResult GetGameCoordinatorServerLogin(IntPtr pLoginInfo, out int pcbSignedBlob, IntPtr pBlob) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetGameCoordinatorServerLogin(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), pLoginInfo, out pcbSignedBlob, pBlob);
		}

		/// <summary>
		/// <para> Relayed connections using custom signaling protocol</para>
		/// <para> This is used if you have your own method of sending out-of-band</para>
		/// <para> signaling / rendezvous messages through a mutually trusted channel.</para>
		/// <para> Create a P2P "client" connection that does signaling over a custom</para>
		/// <para> rendezvous/signaling channel.</para>
		/// <para> pSignaling points to a new object that you create just for this connection.</para>
		/// <para> It must stay valid until Release() is called.  Once you pass the</para>
		/// <para> object to this function, it assumes ownership.  Release() will be called</para>
		/// <para> from within the function call if the call fails.  Furthermore, until Release()</para>
		/// <para> is called, you should be prepared for methods to be invoked on your</para>
		/// <para> object from any thread!  You need to make sure your object is threadsafe!</para>
		/// <para> Furthermore, you should make sure that dispatching the methods is done</para>
		/// <para> as quickly as possible.</para>
		/// <para> This function will immediately construct a connection in the "connecting"</para>
		/// <para> state.  Soon after (perhaps before this function returns, perhaps in another thread),</para>
		/// <para> the connection will begin sending signaling messages by calling</para>
		/// <para> ISteamNetworkingConnectionSignaling::SendSignal.</para>
		/// <para> When the remote peer accepts the connection (See</para>
		/// <para> ISteamNetworkingSignalingRecvContext::OnConnectRequest),</para>
		/// <para> it will begin sending signaling messages.  When these messages are received,</para>
		/// <para> you can pass them to the connection using ReceivedP2PCustomSignal.</para>
		/// <para> If you know the identity of the peer that you expect to be on the other end,</para>
		/// <para> you can pass their identity to improve debug output or just detect bugs.</para>
		/// <para> If you don't know their identity yet, you can pass NULL, and their</para>
		/// <para> identity will be established in the connection handshake.</para>
		/// <para> If you use this, you probably want to call ISteamNetworkingUtils::InitRelayNetworkAccess()</para>
		/// <para> when your app initializes</para>
		/// <para> If you need to set any initial config options, pass them here.  See</para>
		/// <para> SteamNetworkingConfigValue_t for more about why this is preferable to</para>
		/// <para> setting the options "immediately" after creation.</para>
		/// <para>使用自定义信号协议建立连接</para>
		/// <para>如果使用你自己的方法通过一个双方都信任的渠道发送异时信号/会话消息。</para>
		/// <para>创建一个 P2P “客户端”连接，通过自定义的会话/信号通道进行会话。</para>
		/// <para>pSignaling 指向您为此连接创建的新对象。它必须在 Release() 被调用时保持有效。一旦您将该对象传递给此函数，它将承担所有权。如果调用失败，Release() 将在函数调用内部被调用。此外，在 Release() 被调用之前，您应该准备好从任何线程上调用该对象的方法！您需要确保您的对象是线程安全的！ 此外，您应该确保方法的调度尽可能快。</para>
		/// <para>这个函数会立即建立一个处于“connecting”状态的连接。 很快（可能在此函数返回之前，也可能在另一个线程中），连接将开始通过调用 ISteamNetworkingConnectionSignaling::SendSignal 发送信号消息。</para>
		/// <para>当远程对端接受连接（参见 ISteamNetworkingSignalingRecvContext::OnConnectRequest），它将开始发送信号消息。当这些消息被接收时，你可以使用 ReceivedP2PCustomSignal 将它们传递给连接。</para>
		/// <para>如果你知道你期望在另一端看到的同伴的身份，你可以将他们的身份传递过去，以改进调试输出或仅仅检测错误。如果你还不清楚他们的身份，你可以传递NULL，他们的身份会在连接握手中建立。</para>
		/// <para>如果你使用这个，你可能需要调用 ISteamNetworkingUtils::InitRelayNetworkAccess() 当你的应用初始化时。</para>
		/// <para>如果需要设置任何初始配置选项，请在此处传递它们。请参阅 SteamNetworkingConfigValue_t 以了解为什么这种方法比在创建后“立即”设置选项更可取。</para>
		/// </summary>
		public static HSteamNetConnection ConnectP2PCustomSignaling(out ISteamNetworkingConnectionSignaling pSignaling, ref SteamNetworkingIdentity pPeerIdentity, int nRemoteVirtualPort, int nOptions, SteamNetworkingConfigValue_t[] pOptions) {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamNetConnection)NativeMethods.ISteamNetworkingSockets_ConnectP2PCustomSignaling(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), out pSignaling, ref pPeerIdentity, nRemoteVirtualPort, nOptions, pOptions);
		}

		/// <summary>
		/// <para> Called when custom signaling has received a message.  When your</para>
		/// <para> signaling channel receives a message, it should save off whatever</para>
		/// <para> routing information was in the envelope into the context object,</para>
		/// <para> and then pass the payload to this function.</para>
		/// <para> A few different things can happen next, depending on the message:</para>
		/// <para> - If the signal is associated with existing connection, it is dealt</para>
		/// <para>   with immediately.  If any replies need to be sent, they will be</para>
		/// <para>   dispatched using the ISteamNetworkingConnectionSignaling</para>
		/// <para>   associated with the connection.</para>
		/// <para> - If the message represents a connection request (and the request</para>
		/// <para>   is not redundant for an existing connection), a new connection</para>
		/// <para>   will be created, and ReceivedConnectRequest will be called on your</para>
		/// <para>   context object to determine how to proceed.</para>
		/// <para> - Otherwise, the message is for a connection that does not</para>
		/// <para>   exist (anymore).  In this case, we *may* call SendRejectionReply</para>
		/// <para>   on your context object.</para>
		/// <para> In any case, we will not save off pContext or access it after this</para>
		/// <para> function returns.</para>
		/// <para> Returns true if the message was parsed and dispatched without anything</para>
		/// <para> unusual or suspicious happening.  Returns false if there was some problem</para>
		/// <para> with the message that prevented ordinary handling.  (Debug output will</para>
		/// <para> usually have more information.)</para>
		/// <para> If you expect to be using relayed connections, then you probably want</para>
		/// <para> to call ISteamNetworkingUtils::InitRelayNetworkAccess() when your app initializes</para>
		/// <para>当自定义信号已接收到消息时调用。当你的信号通道接收到消息时，应将信封中包含的任何路由信息保存到上下文对象中，然后将有效负载传递给此函数。</para>
		/// <para>接下来可能会发生一些不同的事情，取决于信息内容：</para>
		/// <para>如果信号与现有连接相关联，则会立即处理。如果需要发送任何回复，它们将使用与该连接相关的ISteamNetworkingConnectionSignaling进行发送。  如果消息代表连接请求（并且该请求对于现有连接不是冗余的），则将创建一个新的连接，并调用你的上下文对象上的ReceivedConnectRequest来确定如何继续操作。  否则，消息是针对不存在（或已不再存在）的连接。在这种情况下，我们*可能*会调用你的上下文对象上的SendRejectionReply。</para>
		/// <para>总之，在该函数返回后，我们不会保存或访问 pContext。</para>
		/// <para>如果消息已解析并已成功分发，且没有发生任何异常或可疑情况，则返回true。如果消息存在问题，导致无法进行普通处理，则返回false。（调试输出通常会提供更多信息。）</para>
		/// <para>如果你预计将使用中继连接，那么你可能需要在你的应用程序初始化时调用ISteamNetworkingUtils::InitRelayNetworkAccess()</para>
		/// </summary>
		public static bool ReceivedP2PCustomSignal(IntPtr pMsg, int cbMsg, out ISteamNetworkingSignalingRecvContext pContext) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_ReceivedP2PCustomSignal(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), pMsg, cbMsg, out pContext);
		}

		/// <summary>
		/// <para> Certificate provision by the application.  On Steam, we normally handle all this automatically</para>
		/// <para> and you will not need to use these advanced functions.</para>
		/// <para> Get blob that describes a certificate request.  You can send this to your game coordinator.</para>
		/// <para> Upon entry, *pcbBlob should contain the size of the buffer.  On successful exit, it will</para>
		/// <para> return the number of bytes that were populated.  You can pass pBlob=NULL to query for the required</para>
		/// <para> size.  (512 bytes is a conservative estimate.)</para>
		/// <para> Pass this blob to your game coordinator and call SteamDatagram_CreateCert.</para>
		/// <para>应用程序提供证书。在Steam上，我们通常会处理所有这些，您不需要使用这些高级功能。</para>
		/// <para>获取描述证书请求的 Blob。你可以将此 Blob 发送到你的游戏协调器。进入时，*pcbBlob 应该包含缓冲区的尺寸。在成功退出时，它将返回填充的字节数。你可以通过将 pBlob=NULL 传递来查询所需的尺寸。（512 字节是一个保守的估计。）</para>
		/// <para>将这个 blob 传递给你的游戏协调器，并调用 SteamDatagram_CreateCert。</para>
		/// </summary>
		public static bool GetCertificateRequest(out int pcbBlob, IntPtr pBlob, out SteamNetworkingErrMsg errMsg) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetCertificateRequest(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), out pcbBlob, pBlob, out errMsg);
		}

		/// <summary>
		/// <para> Set the certificate.  The certificate blob should be the output of</para>
		/// <para> SteamDatagram_CreateCert.</para>
		/// <para>设置证书。证书 blob 应为 SteamDatagram_CreateCert 的输出。</para>
		/// </summary>
		public static bool SetCertificate(IntPtr pCertificate, int cbCertificate, out SteamNetworkingErrMsg errMsg) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_SetCertificate(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), pCertificate, cbCertificate, out errMsg);
		}

		/// <summary>
		/// <para> Reset the identity associated with this instance.</para>
		/// <para> Any open connections are closed.  Any previous certificates, etc are discarded.</para>
		/// <para> You can pass a specific identity that you want to use, or you can pass NULL,</para>
		/// <para> in which case the identity will be invalid until you set it using SetCertificate</para>
		/// <para> NOTE: This function is not actually supported on Steam!  It is included</para>
		/// <para>       for use on other platforms where the active user can sign out and</para>
		/// <para>       a new user can sign in.</para>
		/// <para>重置与此实例关联的身份。所有已打开的连接都会关闭。 任何先前证书等都会被丢弃。 您可以传递一个您想要使用的特定身份，或者传递 NULL，此时身份将无效，直到您使用 SetCertificate 方法设置它。</para>
		/// <para>注意：此函数在Steam上实际上不受支持！它包含在其他平台上使用，其中活跃用户可以登出并新用户可以登录。</para>
		/// </summary>
		public static void ResetIdentity(ref SteamNetworkingIdentity pIdentity) {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamNetworkingSockets_ResetIdentity(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), ref pIdentity);
		}

		/// <summary>
		/// <para> Misc</para>
		/// <para> Invoke all callback functions queued for this interface.</para>
		/// <para> See k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged, etc</para>
		/// <para> You don't need to call this if you are using Steam's callback dispatch</para>
		/// <para> mechanism (SteamAPI_RunCallbacks and SteamGameserver_RunCallbacks).</para>
		/// <para>杂项</para>
		/// <para>调用所有为该接口排队的回调函数。 参见 k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged 等。</para>
		/// <para>如果你正在使用Steam的回调派发机制（SteamAPI_RunCallbacks和SteamGameserver_RunCallbacks），则无需调用它。</para>
		/// </summary>
		public static void RunCallbacks() {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamNetworkingSockets_RunCallbacks(CSteamGameServerAPIContext.GetSteamNetworkingSockets());
		}

		/// <summary>
		/// <para> "FakeIP" system.</para>
		/// <para> A FakeIP is essentially a temporary, arbitrary identifier that</para>
		/// <para> happens to be a valid IPv4 address.  The purpose of this system is to make it</para>
		/// <para> easy to integrate with existing code that identifies hosts using IPv4 addresses.</para>
		/// <para> The FakeIP address will never actually be used to send or receive any packets</para>
		/// <para> on the Internet, it is strictly an identifier.</para>
		/// <para> FakeIP addresses are designed to (hopefully) pass through existing code as</para>
		/// <para> transparently as possible, while conflicting with "real" addresses that might</para>
		/// <para> be in use on networks (both the Internet and LANs) in the same code as little</para>
		/// <para> as possible.  At the time this comment is being written, they come from the</para>
		/// <para> 169.254.0.0/16 range, and the port number will always be &gt;1024.  HOWEVER,</para>
		/// <para> this is subject to change!  Do not make assumptions about these addresses,</para>
		/// <para> or your code might break in the future.  In particular, you should use</para>
		/// <para> functions such as  ISteamNetworkingUtils::IsFakeIP to determine if an IP</para>
		/// <para> address is a "fake" one used by this system.</para>
		/// <para> Begin asynchronous process of allocating a fake IPv4 address that other</para>
		/// <para> peers can use to contact us via P2P.  IP addresses returned by this</para>
		/// <para> function are globally unique for a given appid.</para>
		/// <para> nNumPorts is the numbers of ports you wish to reserve.  This is useful</para>
		/// <para> for the same reason that listening on multiple UDP ports is useful for</para>
		/// <para> different types of traffic.  Because these allocations come from a global</para>
		/// <para> namespace, there is a relatively strict limit on the maximum number of</para>
		/// <para> ports you may request.  (At the time of this writing, the limit is 4.)</para>
		/// <para> The port assignments are *not* guaranteed to have any particular order</para>
		/// <para> or relationship!  Do *not* assume they are contiguous, even though that</para>
		/// <para> may often occur in practice.</para>
		/// <para> Returns false if a request was already in progress, true if a new request</para>
		/// <para> was started.  A SteamNetworkingFakeIPResult_t will be posted when the request</para>
		/// <para> completes.</para>
		/// <para> For gameservers, you *must* call this after initializing the SDK but before</para>
		/// <para> beginning login.  Steam needs to know in advance that FakeIP will be used.</para>
		/// <para> Everywhere your public IP would normally appear (such as the server browser) will be</para>
		/// <para> replaced by the FakeIP, and the fake port at index 0.  The request is actually queued</para>
		/// <para> until the logon completes, so you must not wait until the allocation completes</para>
		/// <para> before logging in.  Except for trivial failures that can be detected locally</para>
		/// <para> (e.g. invalid parameter), a SteamNetworkingFakeIPResult_t callback (whether success or</para>
		/// <para> failure) will not be posted until after we have logged in.  Furthermore, it is assumed</para>
		/// <para> that FakeIP allocation is essential for your application to function, and so failure</para>
		/// <para> will not be reported until *several* retries have been attempted.  This process may</para>
		/// <para> last several minutes.  It is *highly* recommended to treat failure as fatal.</para>
		/// <para> To communicate using a connection-oriented (TCP-style) API:</para>
		/// <para> - Server creates a listen socket using CreateListenSocketP2PFakeIP</para>
		/// <para> - Client connects using ConnectByIPAddress, passing in the FakeIP address.</para>
		/// <para> - The connection will behave mostly like a P2P connection.  The identities</para>
		/// <para>   that appear in SteamNetConnectionInfo_t will be the FakeIP identity until</para>
		/// <para>   we know the real identity.  Then it will be the real identity.  If the</para>
		/// <para>   SteamNetConnectionInfo_t::m_addrRemote is valid, it will be a real IPv4</para>
		/// <para>   address of a NAT-punched connection.  Otherwise, it will not be valid.</para>
		/// <para> To communicate using an ad-hoc sendto/recv from (UDP-style) API,</para>
		/// <para> use CreateFakeUDPPort.</para>
		/// <para>假IP系统。</para>
		/// <para>一个假IP本质上是一个临时、任意的标识符，恰好是一个有效的 IPv4 地址。该系统的目的是方便与使用 IPv4 地址识别主机现有代码的集成。假IP 地址永远不会实际用于在 Internet 上发送或接收任何数据包，它严格来说只是一个标识符。</para>
		/// <para>假IP地址的设计目的是（希望）尽可能透明地通过现有代码，同时与网络中（包括互联网和局域网）可能使用的“真实”地址冲突，并且在代码中尽量减少冲突。 在编写此评论时，它们来自 169.254.0.0/16 范围，端口号始终大于 1024。 但是，这可能会发生变化！ 不要对这些地址做出任何假设，否则您的代码可能会在未来中断。 尤其，您应该使用诸如 ISteamNetworkingUtils::IsFakeIP 之类的函数来确定 IP 地址是否为该系统使用的“假”地址。</para>
		/// <para>开始异步进程，为其他同伴分配一个虚假的 IPv4 地址，以便他们可以通过 P2P 联系我们。此函数返回的 IP 地址在给定 appid 范围内全局唯一。</para>
		/// <para>NumPorts 是你希望预留的端口数量。这与监听多个 UDP 端口同样有道理，因为它们适用于不同类型的流量。由于这些分配来自全局命名空间，因此你可能请求的最大端口数量受到相对严格的限制（在当时写这篇文档时，限制为 4）。端口分配*不*保证具有任何特定的顺序或关系！即使在实践中这通常会发生，也不要假设它们是连续的。</para>
		/// <para>如果请求正在进行中，则返回false，如果启动了新的请求，则返回true。当请求完成时，会发布一个SteamNetworkingFakeIPResult_t。</para>
		/// <para>对于游戏服务器，您*必须*在初始化 SDK 之后，但在开始登录之前调用此方法。Steam 需要提前知道 FakeIP 将被使用。 您的公共 IP 通常出现的任何地方（例如服务器浏览器）都将被 FakeIP 替换，以及索引为 0 的虚假端口。 请求实际上会排队直到登录完成，因此您不能在分配完成之前登录。 仅限可以本地检测的轻微失败（例如无效参数），SteamNetworkingFakeIPResult_t 回调（无论成功与否）都不会在登录完成后发布。 此外，假定 FakeIP 分配对您的应用程序的功能至关重要，因此失败将不会在*多次*重试尝试后报告。 此过程可能持续数分钟。 强烈建议将失败视为致命。</para>
		/// <para>使用连接式（TCP 风格）API进行通信： - 服务器使用 CreateListenSocketP2PFakeIP 创建监听套接字。 - 客户端使用 ConnectByIPAddress 连接，传递 FakeIP 地址。 - 连接将表现出类似于 P2P 连接的行为。 SteamNetConnectionInfo_t 中显示的身份将在我们知道真实身份之前是 FakeIP 身份。然后它将是真实身份。如果 SteamNetConnectionInfo_t::m_addrRemote 有效，它将是 NAT 穿透连接的真实 IPv4 地址。否则，它将无效。</para>
		/// <para>使用 ad-hoc sendto/recv (UDP 风格) API 进行通信，请使用 CreateFakeUDPPort。</para>
		/// </summary>
		public static bool BeginAsyncRequestFakeIP(int nNumPorts) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_BeginAsyncRequestFakeIP(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), nNumPorts);
		}

		/// <summary>
		/// <para> Return info about the FakeIP and port(s) that we have been assigned,</para>
		/// <para> if any.  idxFirstPort is currently reserved and must be zero.</para>
		/// <para> Make sure and check SteamNetworkingFakeIPResult_t::m_eResult</para>
		/// <para>提供有关我们分配的假IP地址和端口（如有）的信息。idxFirstPort 目前已被保留，必须为零。请务必检查 SteamNetworkingFakeIPResult_t::m_eResult</para>
		/// </summary>
		public static void GetFakeIP(int idxFirstPort, out SteamNetworkingFakeIPResult_t pInfo) {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamNetworkingSockets_GetFakeIP(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), idxFirstPort, out pInfo);
		}

		/// <summary>
		/// <para> Create a listen socket that will listen for P2P connections sent</para>
		/// <para> to our FakeIP.  A peer can initiate connections to this listen</para>
		/// <para> socket by calling ConnectByIPAddress.</para>
		/// <para> idxFakePort refers to the *index* of the fake port requested,</para>
		/// <para> not the actual port number.  For example, pass 0 to refer to the</para>
		/// <para> first port in the reservation.  You must call this only after calling</para>
		/// <para> BeginAsyncRequestFakeIP.  However, you do not need to wait for the</para>
		/// <para> request to complete before creating the listen socket.</para>
		/// <para>创建一个监听套接字，用于监听指向我们 FakeIP 的 P2P 连接。一个同伴可以通过调用 ConnectByIPAddress 方法来启动连接到此监听套接字。</para>
		/// <para>idxFakePort 指的是 *index* (索引) 值，而不是实际的端口号。例如，传递 0 表示引用保留中的第一个端口。您必须在调用 BeginAsyncRequestFakeIP 之后才调用此方法。但是，您无需在请求完成之前再创建监听套接字。</para>
		/// </summary>
		public static HSteamListenSocket CreateListenSocketP2PFakeIP(int idxFakePort, int nOptions, SteamNetworkingConfigValue_t[] pOptions) {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamListenSocket)NativeMethods.ISteamNetworkingSockets_CreateListenSocketP2PFakeIP(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), idxFakePort, nOptions, pOptions);
		}

		/// <summary>
		/// <para> If the connection was initiated using the "FakeIP" system, then we</para>
		/// <para> we can get an IP address for the remote host.  If the remote host had</para>
		/// <para> a global FakeIP at the time the connection was established, this</para>
		/// <para> function will return that global IP.  Otherwise, a FakeIP that is</para>
		/// <para> unique locally will be allocated from the local FakeIP address space,</para>
		/// <para> and that will be returned.</para>
		/// <para> The allocation of local FakeIPs attempts to assign addresses in</para>
		/// <para> a consistent manner.  If multiple connections are made to the</para>
		/// <para> same remote host, they *probably* will return the same FakeIP.</para>
		/// <para> However, since the namespace is limited, this cannot be guaranteed.</para>
		/// <para> On failure, returns:</para>
		/// <para> - k_EResultInvalidParam: invalid connection handle</para>
		/// <para> - k_EResultIPNotFound: This connection wasn't made using FakeIP system</para>
		/// <para>如果连接是通过“FakeIP”系统启动的，那么我们可以获取远程主机的IP地址。如果远程主机在连接建立时拥有全局的FakeIP，则此函数将返回该全局IP。否则，将从本地FakeIP地址空间分配一个独特的本地FakeIP，并返回该FakeIP。</para>
		/// <para>本地假IP的分配试图以一致的方式分配地址。如果对同一个远程主机建立了多个连接，它们*可能*会返回相同的假IP。但是，由于命名空间有限，这无法保证。</para>
		/// <para>在失败时，返回：- k_EResultInvalidParam：无效连接句柄 - k_EResultIPNotFound：此连接未使用 FakeIP 系统建立</para>
		/// </summary>
		public static EResult GetRemoteFakeIPForConnection(HSteamNetConnection hConn, out SteamNetworkingIPAddr pOutAddr) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetRemoteFakeIPForConnection(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn, out pOutAddr);
		}

		/// <summary>
		/// <para> Get an interface that can be used like a UDP port to send/receive</para>
		/// <para> datagrams to a FakeIP address.  This is intended to make it easy</para>
		/// <para> to port existing UDP-based code to take advantage of SDR.</para>
		/// <para> idxFakeServerPort refers to the *index* of the port allocated using</para>
		/// <para> BeginAsyncRequestFakeIP and is used to create "server" ports.  You may</para>
		/// <para> call this before the allocation has completed.  However, any attempts</para>
		/// <para> to send packets will fail until the allocation has succeeded.  When</para>
		/// <para> the peer receives packets sent from this interface, the from address</para>
		/// <para> of the packet will be the globally-unique FakeIP.  If you call this</para>
		/// <para> function multiple times and pass the same (nonnegative) fake port index,</para>
		/// <para> the same object will be returned, and this object is not reference counted.</para>
		/// <para> To create a "client" port (e.g. the equivalent of an ephemeral UDP port)</para>
		/// <para> pass -1.  In this case, a distinct object will be returned for each call.</para>
		/// <para> When the peer receives packets sent from this interface, the peer will</para>
		/// <para> assign a FakeIP from its own locally-controlled namespace.</para>
		/// <para>获取一个可以像 UDP 端口一样使用，用于向 FakeIP 地址发送/接收数据报的接口。 这样做是为了方便将现有的基于 UDP 的代码移植过来，以利用 SDR 技术。</para>
		/// <para>idxFakeServerPort 指的是使用 BeginAsyncRequestFakeIP 分配的 *index*，用于创建“server”端口。您可以在分配完成之前调用此函数。但是，直到分配成功后，任何尝试发送数据包的尝试都将失败。当同伴接收通过此接口发送的包时，包的 from 地址将是全局唯一的 FakeIP。如果多次调用此函数并传入相同的 (非负) 虚假端口索引，则将返回相同对象，并且此对象不进行引用计数。</para>
		/// <para>为了创建一个“客户端”端口（例如，一个临时的UDP端口），请使用-1。在这种情况下，每次调用都会返回一个不同的对象。当对端收到通过此接口发送的包时，对端会从其自身控制的本地命名空间中分配一个FakeIP。</para>
		/// </summary>
		public static IntPtr CreateFakeUDPPort(int idxFakeServerPort) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_CreateFakeUDPPort(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), idxFakeServerPort);
		}
	}
}

#endif // !DISABLESTEAMWORKS
