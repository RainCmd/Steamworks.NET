// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
	#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	public static class SteamGameServerNetworkingSockets {
		/// <summary>
		/// <para> Creates a "server" socket that listens for clients to connect to by</para>
		/// <para> calling ConnectByIPAddress, over ordinary UDP (IPv4 or IPv6)</para>
		/// <para> You must select a specific local port to listen on and set it</para>
		/// <para> the port field of the local address.</para>
		/// <para> Usually you will set the IP portion of the address to zero (SteamNetworkingIPAddr::Clear()).</para>
		/// <para> This means that you will not bind to any particular local interface (i.e. the same</para>
		/// <para> as INADDR_ANY in plain socket code).  Furthermore, if possible the socket will be bound</para>
		/// <para> in "dual stack" mode, which means that it can accept both IPv4 and IPv6 client connections.</para>
		/// <para> If you really do wish to bind a particular interface, then set the local address to the</para>
		/// <para> appropriate IPv4 or IPv6 IP.</para>
		/// <para> If you need to set any initial config options, pass them here.  See</para>
		/// <para> SteamNetworkingConfigValue_t for more about why this is preferable to</para>
		/// <para> setting the options "immediately" after creation.</para>
		/// <para> When a client attempts to connect, a SteamNetConnectionStatusChangedCallback_t</para>
		/// <para> will be posted.  The connection will be in the connecting state.</para>
		/// <para>创建一个“服务器”套接字，用于监听客户端连接，通过调用 ConnectByIPAddress，使用普通 UDP（IPv4 或 IPv6）。</para>
		/// <para>您必须选择一个特定的本地端口进行监听，并设置“本地地址”中的端口字段。</para>
		/// <para>通常，您会设置地址的 IP 部分为零 (SteamNetworkingIPAddr::Clear())。这意味着您不会绑定到任何特定的本地接口（即与 plain socket 代码中的 INADDR_ANY 相同）。 此外，如果可能，套接字将以“双栈”模式进行绑定，这意味着它能够接受 IPv4 和 IPv6 客户端连接。 如果您确实希望绑定特定的接口，则将本地地址设置为适当的 IPv4 或 IPv6 IP。</para>
		/// <para>如果您需要设置任何初始配置选项，请在此处提供。有关为何更喜欢“立即”设置选项而不是在创建后设置选项的更多信息，请参见 SteamNetworkingConfigValue_t。</para>
		/// <para>当客户端尝试连接时，会发布一个 SteamNetConnectionStatusChangedCallback_t。连接状态将处于连接中状态。</para>
		/// </summary>
		public static HSteamListenSocket CreateListenSocketIP(ref SteamNetworkingIPAddr localAddress, int nOptions, SteamNetworkingConfigValue_t[] pOptions) {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamListenSocket)NativeMethods.ISteamNetworkingSockets_CreateListenSocketIP(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), ref localAddress, nOptions, pOptions);
		}

		/// <summary>
		/// <para> Creates a connection and begins talking to a "server" over UDP at the</para>
		/// <para> given IPv4 or IPv6 address.  The remote host must be listening with a</para>
		/// <para> matching call to CreateListenSocketIP on the specified port.</para>
		/// <para> A SteamNetConnectionStatusChangedCallback_t callback will be triggered when we start</para>
		/// <para> connecting, and then another one on either timeout or successful connection.</para>
		/// <para> If the server does not have any identity configured, then their network address</para>
		/// <para> will be the only identity in use.  Or, the network host may provide a platform-specific</para>
		/// <para> identity with or without a valid certificate to authenticate that identity.  (These</para>
		/// <para> details will be contained in the SteamNetConnectionStatusChangedCallback_t.)  It's</para>
		/// <para> up to your application to decide whether to allow the connection.</para>
		/// <para> By default, all connections will get basic encryption sufficient to prevent</para>
		/// <para> casual eavesdropping.  But note that without certificates (or a shared secret</para>
		/// <para> distributed through some other out-of-band mechanism), you don't have any</para>
		/// <para> way of knowing who is actually on the other end, and thus are vulnerable to</para>
		/// <para> man-in-the-middle attacks.</para>
		/// <para> If you need to set any initial config options, pass them here.  See</para>
		/// <para> SteamNetworkingConfigValue_t for more about why this is preferable to</para>
		/// <para> setting the options "immediately" after creation.</para>
		/// <para>建立连接并开始与指定 IPv4 或 IPv6 地址的“服务器”进行 UDP 上的通信。远程主机必须监听，并使用 CreateListenSocketIP 函数在指定端口上进行调用。</para>
		/// <para>当开始连接时，会触发一个 SteamNetConnectionStatusChangedCallback_t 回调，然后会在超时或成功连接时触发另一个回调。</para>
		/// <para>如果服务器没有配置任何身份验证，那么他们的网络地址将成为唯一的身份验证方式。或者，网络主机可以提供平台特定的身份验证，并可能附带有效的证书来验证该身份。 (这些细节将包含在 SteamNetConnectionStatusChangedCallback_t 中)。 应用程序需要自行决定是否允许连接。</para>
		/// <para>默认情况下，所有连接都会获得足够的加密，足以防止非专业窃听。但是，如果没有证书（或通过其他异业机制分发共享密钥），你无法知道谁实际上在另一端，因此容易受到中间人攻击。</para>
		/// <para>如果您需要设置任何初始配置选项，请在此处提供。有关为何更喜欢“立即”设置选项而不是在创建后设置选项的更多信息，请参见 SteamNetworkingConfigValue_t。</para>
		/// </summary>
		public static HSteamNetConnection ConnectByIPAddress(ref SteamNetworkingIPAddr address, int nOptions, SteamNetworkingConfigValue_t[] pOptions) {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamNetConnection)NativeMethods.ISteamNetworkingSockets_ConnectByIPAddress(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), ref address, nOptions, pOptions);
		}

		/// <summary>
		/// <para> Like CreateListenSocketIP, but clients will connect using ConnectP2P.</para>
		/// <para> nLocalVirtualPort specifies how clients can connect to this socket using</para>
		/// <para> ConnectP2P.  It's very common for applications to only have one listening socket;</para>
		/// <para> in that case, use zero.  If you need to open multiple listen sockets and have clients</para>
		/// <para> be able to connect to one or the other, then nLocalVirtualPort should be a small</para>
		/// <para> integer (&lt;1000) unique to each listen socket you create.</para>
		/// <para> If you use this, you probably want to call ISteamNetworkingUtils::InitRelayNetworkAccess()</para>
		/// <para> when your app initializes.</para>
		/// <para> If you are listening on a dedicated servers in known data center,</para>
		/// <para> then you can listen using this function instead of CreateHostedDedicatedServerListenSocket,</para>
		/// <para> to allow clients to connect without a ticket.  Any user that owns</para>
		/// <para> the app and is signed into Steam will be able to attempt to connect to</para>
		/// <para> your server.  Also, a connection attempt may require the client to</para>
		/// <para> be connected to Steam, which is one more moving part that may fail.  When</para>
		/// <para> tickets are used, then once a ticket is obtained, a client can connect to</para>
		/// <para> your server even if they got disconnected from Steam or Steam is offline.</para>
		/// <para> If you need to set any initial config options, pass them here.  See</para>
		/// <para> SteamNetworkingConfigValue_t for more about why this is preferable to</para>
		/// <para> setting the options "immediately" after creation.</para>
		/// <para>类似于 CreateListenSocketIP，但客户端将使用 ConnectP2P 连接。</para>
		/// <para>nLocalVirtualPort 指定客户端如何使用 ConnectP2P 连接到此套接字。 应用程序通常只有一个监听套接字；在这种情况下，使用零。 如果您需要打开多个监听套接字，并且希望客户端能够连接到任何一个，则 nLocalVirtualPort 应为一个小整数（<1000），并且该值应在每个创建的监听套接字中保持唯一。</para>
		/// <para>如果你使用这个，你可能需要调用 ISteamNetworkingUtils::InitRelayNetworkAccess() 在你的应用初始化时。</para>
		/// <para>如果您在已知数据中心的专用服务器上监听，则可以使用此函数，而不是 CreateHostedDedicatedServerListenSocket，以便客户端无需凭证即可连接。任何拥有该应用并已登录 Steam 的用户都可以尝试连接到您的服务器。此外，连接尝试可能需要客户端已连接到 Steam，这又是一个可能失败的额外环节。</para>
		/// <para>如果您需要设置任何初始配置选项，请在此处提供。有关为何更喜欢“立即”设置选项而不是在创建后设置选项的更多信息，请参见 SteamNetworkingConfigValue_t。</para>
		/// </summary>
		public static HSteamListenSocket CreateListenSocketP2P(int nLocalVirtualPort, int nOptions, SteamNetworkingConfigValue_t[] pOptions) {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamListenSocket)NativeMethods.ISteamNetworkingSockets_CreateListenSocketP2P(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), nLocalVirtualPort, nOptions, pOptions);
		}

		/// <summary>
		/// <para> Begin connecting to a peer that is identified using a platform-specific identifier.</para>
		/// <para> This uses the default rendezvous service, which depends on the platform and library</para>
		/// <para> configuration.  (E.g. on Steam, it goes through the steam backend.)</para>
		/// <para> If you need to set any initial config options, pass them here.  See</para>
		/// <para> SteamNetworkingConfigValue_t for more about why this is preferable to</para>
		/// <para> setting the options "immediately" after creation.</para>
		/// <para> To use your own signaling service, see:</para>
		/// <para> - ConnectP2PCustomSignaling</para>
		/// <para> - k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling</para>
		/// <para>正在连接一个使用特定平台标识符识别的同伴。它使用默认的rendezvous服务，该服务取决于平台和库配置。(例如，在Steam上，它将通过Steam后端进行。)</para>
		/// <para>如果您需要设置任何初始配置选项，请在此处提供。有关为何更喜欢“立即”设置选项而不是在创建后设置选项的更多信息，请参见 SteamNetworkingConfigValue_t。</para>
		/// <para>为了使用您自己的信号服务，请查看：- ConnectP2PCustomSignaling - k_ESteamNetworkingConfig_Callback_CreateConnectionSignaling</para>
		/// </summary>
		public static HSteamNetConnection ConnectP2P(ref SteamNetworkingIdentity identityRemote, int nRemoteVirtualPort, int nOptions, SteamNetworkingConfigValue_t[] pOptions) {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamNetConnection)NativeMethods.ISteamNetworkingSockets_ConnectP2P(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), ref identityRemote, nRemoteVirtualPort, nOptions, pOptions);
		}

		/// <summary>
		/// <para> Accept an incoming connection that has been received on a listen socket.</para>
		/// <para> When a connection attempt is received (perhaps after a few basic handshake</para>
		/// <para> packets have been exchanged to prevent trivial spoofing), a connection interface</para>
		/// <para> object is created in the k_ESteamNetworkingConnectionState_Connecting state</para>
		/// <para> and a SteamNetConnectionStatusChangedCallback_t is posted.  At this point, your</para>
		/// <para> application MUST either accept or close the connection.  (It may not ignore it.)</para>
		/// <para> Accepting the connection will transition it either into the connected state,</para>
		/// <para> or the finding route state, depending on the connection type.</para>
		/// <para> You should take action within a second or two, because accepting the connection is</para>
		/// <para> what actually sends the reply notifying the client that they are connected.  If you</para>
		/// <para> delay taking action, from the client's perspective it is the same as the network</para>
		/// <para> being unresponsive, and the client may timeout the connection attempt.  In other</para>
		/// <para> words, the client cannot distinguish between a delay caused by network problems</para>
		/// <para> and a delay caused by the application.</para>
		/// <para> This means that if your application goes for more than a few seconds without</para>
		/// <para> processing callbacks (for example, while loading a map), then there is a chance</para>
		/// <para> that a client may attempt to connect in that interval and fail due to timeout.</para>
		/// <para> If the application does not respond to the connection attempt in a timely manner,</para>
		/// <para> and we stop receiving communication from the client, the connection attempt will</para>
		/// <para> be timed out locally, transitioning the connection to the</para>
		/// <para> k_ESteamNetworkingConnectionState_ProblemDetectedLocally state.  The client may also</para>
		/// <para> close the connection before it is accepted, and a transition to the</para>
		/// <para> k_ESteamNetworkingConnectionState_ClosedByPeer is also possible depending the exact</para>
		/// <para> sequence of events.</para>
		/// <para> Returns k_EResultInvalidParam if the handle is invalid.</para>
		/// <para> Returns k_EResultInvalidState if the connection is not in the appropriate state.</para>
		/// <para> (Remember that the connection state could change in between the time that the</para>
		/// <para> notification being posted to the queue and when it is received by the application.)</para>
		/// <para> A note about connection configuration options.  If you need to set any configuration</para>
		/// <para> options that are common to all connections accepted through a particular listen</para>
		/// <para> socket, consider setting the options on the listen socket, since such options are</para>
		/// <para> inherited automatically.  If you really do need to set options that are connection</para>
		/// <para> specific, it is safe to set them on the connection before accepting the connection.</para>
		/// <para>接受一个已在监听套接字上接收到的传入连接。</para>
		/// <para>当收到连接尝试（可能在经过一些基本的握手数据包交换后，以防止无效伪造）时，会创建一个 `k_ESteamNetworkingConnectionState_Connecting` 状态的 `k_ESteamNetworkingConnectionState` 对象，并发布一个 `SteamNetConnectionStatusChangedCallback_t`。 在此时，你的应用程序必须要么接受，要么关闭该连接。（它不能忽略它。） 接受连接会将其过渡到已连接状态或查找路由状态，具体取决于连接类型。</para>
		/// <para>你应该在1到2秒内采取行动，因为接受连接实际上会发送通知客户端已连接的回复。 如果延迟采取行动，从客户端的角度来看，与网络无响应相同，客户端可能会超时连接尝试。 换句话说，客户端无法区分由网络问题引起的延迟和由应用程序引起的延迟。</para>
		/// <para>这意味着如果你的应用程序在处理回调超过几秒钟（例如，在加载地图时），则可能会有客户端在那个时间间隔内尝试连接并由于超时而失败。</para>
		/// <para>如果应用程序未能及时响应连接尝试，并且我们不再接收来自客户端的通信，则本地连接尝试将超时，并过渡到 k_ESteamNetworkingConnectionState_ProblemDetectedLocally 状态。 客户端也可能在连接未被接受之前关闭连接，并且根据确切的事件序列，过渡到 k_ESteamNetworkingConnectionState_ClosedByPeer 也是可能的。</para>
		/// <para>如果句柄无效，则返回 k_EResultInvalidParam。如果连接状态不正确，则返回 k_EResultInvalidState。 (请记住，在通知被发布到队列和应用程序接收通知之间，连接状态可能会发生变化。)</para>
		/// <para>关于连接配置选项的一条说明。如果您需要设置适用于通过特定监听套接字接受的所有连接的常见配置选项，请考虑在监听套接字上设置这些选项，因为这些选项会自动继承。如果您确实需要设置特定于连接的选项，则在接受连接之前在连接上设置这些选项是安全的。</para>
		/// </summary>
		public static EResult AcceptConnection(HSteamNetConnection hConn) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_AcceptConnection(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn);
		}

		/// <summary>
		/// <para> Disconnects from the remote host and invalidates the connection handle.</para>
		/// <para> Any unread data on the connection is discarded.</para>
		/// <para> nReason is an application defined code that will be received on the other</para>
		/// <para> end and recorded (when possible) in backend analytics.  The value should</para>
		/// <para> come from a restricted range.  (See ESteamNetConnectionEnd.)  If you don't need</para>
		/// <para> to communicate any information to the remote host, and do not want analytics to</para>
		/// <para> be able to distinguish "normal" connection terminations from "exceptional" ones,</para>
		/// <para> You may pass zero, in which case the generic value of</para>
		/// <para> k_ESteamNetConnectionEnd_App_Generic will be used.</para>
		/// <para> pszDebug is an optional human-readable diagnostic string that will be received</para>
		/// <para> by the remote host and recorded (when possible) in backend analytics.</para>
		/// <para> If you wish to put the socket into a "linger" state, where an attempt is made to</para>
		/// <para> flush any remaining sent data, use bEnableLinger=true.  Otherwise reliable data</para>
		/// <para> is not flushed.</para>
		/// <para> If the connection has already ended and you are just freeing up the</para>
		/// <para> connection interface, the reason code, debug string, and linger flag are</para>
		/// <para> ignored.</para>
		/// <para>与远程主机断开连接并无效化连接句柄。连接上的任何未读数据将被丢弃。</para>
		/// <para>nReason 是一个定义代码的应用，将在另一端接收并记录（如果可能）在后端分析中。该值应来自一个受限范围。 (参见 ESteamNetConnectionEnd)。 如果您不需要向远程主机传递任何信息，并且不想让后端能够区分“正常”连接终止和“异常”连接终止，则可以传递零，此时将使用 k_ESteamNetConnectionEnd_App_Generic 的通用值。</para>
		/// <para>pszDebug 是一个可选的、可读的调试字符串，将由远程主机接收并记录（如果可能）在后端分析中。</para>
		/// <para>如果您希望将套接字置于“linger”状态，即尝试刷新任何剩余已发送的数据，请使用 bEnableLinger=true。否则，可靠的数据将不会被刷新。</para>
		/// <para>如果连接已断开，并且你只是释放连接接口，则原因代码、调试字符串和 linger 标志将被忽略。</para>
		/// </summary>
		public static bool CloseConnection(HSteamNetConnection hPeer, int nReason, string pszDebug, bool bEnableLinger) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pszDebug2 = new InteropHelp.UTF8StringHandle(pszDebug)) {
				return NativeMethods.ISteamNetworkingSockets_CloseConnection(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hPeer, nReason, pszDebug2, bEnableLinger);
			}
		}

		/// <summary>
		/// <para> Destroy a listen socket.  All the connections that were accepting on the listen</para>
		/// <para> socket are closed ungracefully.</para>
		/// <para>销毁一个监听套接字。所有在监听套接字上接受连接的连接会不优雅地关闭。</para>
		/// </summary>
		public static bool CloseListenSocket(HSteamListenSocket hSocket) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_CloseListenSocket(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hSocket);
		}

		/// <summary>
		/// <para> Set connection user data.  the data is returned in the following places</para>
		/// <para> - You can query it using GetConnectionUserData.</para>
		/// <para> - The SteamNetworkingmessage_t structure.</para>
		/// <para> - The SteamNetConnectionInfo_t structure.</para>
		/// <para>   (Which is a member of SteamNetConnectionStatusChangedCallback_t -- but see WARNINGS below!!!!)</para>
		/// <para> Do you need to set this atomically when the connection is created?</para>
		/// <para> See k_ESteamNetworkingConfig_ConnectionUserData.</para>
		/// <para> WARNING: Be *very careful* when using the value provided in callbacks structs.</para>
		/// <para> Callbacks are queued, and the value that you will receive in your</para>
		/// <para> callback is the userdata that was effective at the time the callback</para>
		/// <para> was queued.  There are subtle race conditions that can happen if you</para>
		/// <para> don't understand this!</para>
		/// <para> If any incoming messages for this connection are queued, the userdata</para>
		/// <para> field is updated, so that when when you receive messages (e.g. with</para>
		/// <para> ReceiveMessagesOnConnection), they will always have the very latest</para>
		/// <para> userdata.  So the tricky race conditions that can happen with callbacks</para>
		/// <para> do not apply to retrieving messages.</para>
		/// <para> Returns false if the handle is invalid.</para>
		/// <para>设置连接用户数据。数据在以下位置返回 - 可以使用 GetConnectionUserData 查询它 - SteamNetworkingmessage_t 结构 - SteamNetConnectionInfo_t 结构 (它是 SteamNetConnectionStatusChangedCallback_t 的成员 -- 但请参阅下面的警告!!!!)</para>
		/// <para>您需要当连接创建时，是否需要进行原子设置？请参见 k_ESteamNetworkingConfig_ConnectionUserData。</para>
		/// <para>警告：在使用回调结构体提供的值时，请务必小心。回调会被排队，你将接收到的值将是回调被排队时有效的userdata。如果不能理解这一点，可能会发生微妙的竞争条件！</para>
		/// <para>如果任何传入的消息被排队，userdata 字段会被更新，以便当接收到消息（例如使用 ReceiveMessagesOnConnection）时，它们始终拥有最新的 userdata。因此，回调相关的棘手竞争条件不适用于消息检索。</para>
		/// <para>如果句柄无效，则返回false。</para>
		/// </summary>
		public static bool SetConnectionUserData(HSteamNetConnection hPeer, long nUserData) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_SetConnectionUserData(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hPeer, nUserData);
		}

		/// <summary>
		/// <para> Fetch connection user data.  Returns -1 if handle is invalid</para>
		/// <para> or if you haven't set any userdata on the connection.</para>
		/// <para>获取连接用户数据。如果句柄无效或您未在连接上设置任何用户数据，则返回 -1。</para>
		/// </summary>
		public static long GetConnectionUserData(HSteamNetConnection hPeer) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetConnectionUserData(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hPeer);
		}

		/// <summary>
		/// <para> Set a name for the connection, used mostly for debugging</para>
		/// <para>设置连接名称，主要用于调试。</para>
		/// </summary>
		public static void SetConnectionName(HSteamNetConnection hPeer, string pszName) {
			InteropHelp.TestIfAvailableGameServer();
			using (var pszName2 = new InteropHelp.UTF8StringHandle(pszName)) {
				NativeMethods.ISteamNetworkingSockets_SetConnectionName(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hPeer, pszName2);
			}
		}

		/// <summary>
		/// <para> Fetch connection name.  Returns false if handle is invalid</para>
		/// <para>获取连接名称。如果句柄无效则返回false</para>
		/// </summary>
		public static bool GetConnectionName(HSteamNetConnection hPeer, out string pszName, int nMaxLen) {
			InteropHelp.TestIfAvailableGameServer();
			IntPtr pszName2 = Marshal.AllocHGlobal(nMaxLen);
			bool ret = NativeMethods.ISteamNetworkingSockets_GetConnectionName(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hPeer, pszName2, nMaxLen);
			pszName = ret ? InteropHelp.PtrToStringUTF8(pszName2) : null;
			Marshal.FreeHGlobal(pszName2);
			return ret;
		}

		/// <summary>
		/// <para> Send a message to the remote host on the specified connection.</para>
		/// <para> nSendFlags determines the delivery guarantees that will be provided,</para>
		/// <para> when data should be buffered, etc.  E.g. k_nSteamNetworkingSend_Unreliable</para>
		/// <para> Note that the semantics we use for messages are not precisely</para>
		/// <para> the same as the semantics of a standard "stream" socket.</para>
		/// <para> (SOCK_STREAM)  For an ordinary stream socket, the boundaries</para>
		/// <para> between chunks are not considered relevant, and the sizes of</para>
		/// <para> the chunks of data written will not necessarily match up to</para>
		/// <para> the sizes of the chunks that are returned by the reads on</para>
		/// <para> the other end.  The remote host might read a partial chunk,</para>
		/// <para> or chunks might be coalesced.  For the message semantics</para>
		/// <para> used here, however, the sizes WILL match.  Each send call</para>
		/// <para> will match a successful read call on the remote host</para>
		/// <para> one-for-one.  If you are porting existing stream-oriented</para>
		/// <para> code to the semantics of reliable messages, your code should</para>
		/// <para> work the same, since reliable message semantics are more</para>
		/// <para> strict than stream semantics.  The only caveat is related to</para>
		/// <para> performance: there is per-message overhead to retain the</para>
		/// <para> message sizes, and so if your code sends many small chunks</para>
		/// <para> of data, performance will suffer. Any code based on stream</para>
		/// <para> sockets that does not write excessively small chunks will</para>
		/// <para> work without any changes.</para>
		/// <para> The pOutMessageNumber is an optional pointer to receive the</para>
		/// <para> message number assigned to the message, if sending was successful.</para>
		/// <para> Returns:</para>
		/// <para> - k_EResultInvalidParam: invalid connection handle, or the individual message is too big.</para>
		/// <para>   (See k_cbMaxSteamNetworkingSocketsMessageSizeSend)</para>
		/// <para> - k_EResultInvalidState: connection is in an invalid state</para>
		/// <para> - k_EResultNoConnection: connection has ended</para>
		/// <para> - k_EResultIgnored: You used k_nSteamNetworkingSend_NoDelay, and the message was dropped because</para>
		/// <para>   we were not ready to send it.</para>
		/// <para> - k_EResultLimitExceeded: there was already too much data queued to be sent.</para>
		/// <para>   (See k_ESteamNetworkingConfig_SendBufferSize)</para>
		/// <para>向指定连接的远程主机发送消息。</para>
		/// <para>nSendFlags 确定将提供的交付保证、数据应缓冲的时间等。例如，k_nSteamNetworkingSend_Unreliable</para>
		/// <para>请注意，我们用于消息的语义与标准“流”套接字（SOCK_STREAM）的语义并不完全相同。对于普通的流套接字，数据块之间的边界不被认为是相关的，写入的数据块的大小与接收端返回的块的大小可能不匹配。远程主机可能会读取部分块，或者块可能会合并。但是，这里使用的消息语义中，大小会一一匹配。每个发送调用会对应于远程主机上的成功读取调用。如果您正在将面向流的代码移植到可靠消息的语义中，您的代码应该会正常工作，因为可靠消息语义比流语义更严格。唯一的注意事项是与性能相关：由于需要保留消息大小，因此如果您的代码发送许多小数据块，性能会受到影响。任何基于流套接字且不写入过度小数据块的代码都不会需要任何更改。</para>
		/// <para>pOutMessageNumber 是一个可选的指针，用于接收消息编号，如果发送成功。</para>
		/// <para>Returns: - k_EResultInvalidParam: 无效连接句柄，或消息太大。（参见 k_cbMaxSteamNetworkingSocketsMessageSizeSend）- k_EResultInvalidState: 连接处于无效状态 - k_EResultNoConnection: 连接已断开 - k_EResultIgnored: 您使用了 k_nSteamNetworkingSend_NoDelay，消息被丢弃是因为我们无法发送它。- k_EResultLimitExceeded: 已有太多的数据排队发送。（参见 k_ESteamNetworkingConfig_SendBufferSize）</para>
		/// </summary>
		public static EResult SendMessageToConnection(HSteamNetConnection hConn, IntPtr pData, uint cbData, int nSendFlags, out long pOutMessageNumber) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_SendMessageToConnection(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn, pData, cbData, nSendFlags, out pOutMessageNumber);
		}

		/// <summary>
		/// <para> Send one or more messages without copying the message payload.</para>
		/// <para> This is the most efficient way to send messages. To use this</para>
		/// <para> function, you must first allocate a message object using</para>
		/// <para> ISteamNetworkingUtils::AllocateMessage.  (Do not declare one</para>
		/// <para> on the stack or allocate your own.)</para>
		/// <para> You should fill in the message payload.  You can either let</para>
		/// <para> it allocate the buffer for you and then fill in the payload,</para>
		/// <para> or if you already have a buffer allocated, you can just point</para>
		/// <para> m_pData at your buffer and set the callback to the appropriate function</para>
		/// <para> to free it.  Note that if you use your own buffer, it MUST remain valid</para>
		/// <para> until the callback is executed.  And also note that your callback can be</para>
		/// <para> invoked at any time from any thread (perhaps even before SendMessages</para>
		/// <para> returns!), so it MUST be fast and threadsafe.</para>
		/// <para> You MUST also fill in:</para>
		/// <para> - m_conn - the handle of the connection to send the message to</para>
		/// <para> - m_nFlags - bitmask of k_nSteamNetworkingSend_xxx flags.</para>
		/// <para> All other fields are currently reserved and should not be modified.</para>
		/// <para> The library will take ownership of the message structures.  They may</para>
		/// <para> be modified or become invalid at any time, so you must not read them</para>
		/// <para> after passing them to this function.</para>
		/// <para> pOutMessageNumberOrResult is an optional array that will receive,</para>
		/// <para> for each message, the message number that was assigned to the message</para>
		/// <para> if sending was successful.  If sending failed, then a negative EResult</para>
		/// <para> value is placed into the array.  For example, the array will hold</para>
		/// <para> -k_EResultInvalidState if the connection was in an invalid state.</para>
		/// <para> See ISteamNetworkingSockets::SendMessageToConnection for possible</para>
		/// <para> failure codes.</para>
		/// <para>发送一条或多条消息，不要复制消息负载。这是最有效的方法来发送消息。要使用此函数，您首先必须使用 ISteamNetworkingUtils::AllocateMessage 分配消息对象。（不要在堆上声明或分配您自己的对象。）</para>
		/// <para>你应该填充消息负载。你可以让它为你分配缓冲区，然后填充负载，或者如果你已经分配了缓冲区，你可以直接将 m_pData 指向你的缓冲区，并设置回调函数到适当的函数中以释放它。请注意，如果使用你自己的缓冲区，它必须在回调执行之前保持有效。并且请注意，你的回调可以在任何时间由任何线程调用（也许甚至在 SendMessages 返回之前！），因此它必须快速且线程安全。</para>
		/// <para>Okay, I understand. Please provide the content you want me to translate and fill in the specified fields.</para>
		/// <para>所有其他字段目前已被保留，请勿修改。</para>
		/// <para>图书馆将拥有消息结构的控制权。这些结构可能会被修改或变得无效，因此您在将它们传递给此函数后，不得再次读取它们。</para>
		/// <para>pOutMessageNumberOrResult 是一个可选的数组，它将为每个消息接收消息编号，如果发送成功。如果发送失败，则将负 EResult 值放入数组中。例如，数组将包含 -k_EResultInvalidState，如果连接处于无效状态。请参见 ISteamNetworkingSockets::SendMessageToConnection 以获取可能的失败代码。</para>
		/// </summary>
		public static void SendMessages(int nMessages, IntPtr[] pMessages, long[] pOutMessageNumberOrResult) {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamNetworkingSockets_SendMessages(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), nMessages, pMessages, pOutMessageNumberOrResult);
		}

		/// <summary>
		/// <para> Flush any messages waiting on the Nagle timer and send them</para>
		/// <para> at the next transmission opportunity (often that means right now).</para>
		/// <para> If Nagle is enabled (it's on by default) then when calling</para>
		/// <para> SendMessageToConnection the message will be buffered, up to the Nagle time</para>
		/// <para> before being sent, to merge small messages into the same packet.</para>
		/// <para> (See k_ESteamNetworkingConfig_NagleTime)</para>
		/// <para> Returns:</para>
		/// <para> k_EResultInvalidParam: invalid connection handle</para>
		/// <para> k_EResultInvalidState: connection is in an invalid state</para>
		/// <para> k_EResultNoConnection: connection has ended</para>
		/// <para> k_EResultIgnored: We weren't (yet) connected, so this operation has no effect.</para>
		/// <para>清除 Nagle 计时器上的任何等待消息，并在下一次传输机会时发送它们（通常意味着现在）。</para>
		/// <para>如果Nagle已启用（默认启用），则调用SendMessageToConnection时，消息将被缓冲，直到Nagle时间之前，将小消息合并到同一包中。（参见k_ESteamNetworkingConfig_NagleTime）</para>
		/// <para>Returns: k_EResultInvalidParam: 无效连接句柄 k_EResultInvalidState: 连接处于无效状态 k_EResultNoConnection: 连接已断开 k_EResultIgnored: 我们尚未连接，因此此操作没有效果。</para>
		/// </summary>
		public static EResult FlushMessagesOnConnection(HSteamNetConnection hConn) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_FlushMessagesOnConnection(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn);
		}

		/// <summary>
		/// <para> Fetch the next available message(s) from the connection, if any.</para>
		/// <para> Returns the number of messages returned into your array, up to nMaxMessages.</para>
		/// <para> If the connection handle is invalid, -1 is returned.</para>
		/// <para> The order of the messages returned in the array is relevant.</para>
		/// <para> Reliable messages will be received in the order they were sent (and with the</para>
		/// <para> same sizes --- see SendMessageToConnection for on this subtle difference from a stream socket).</para>
		/// <para> Unreliable messages may be dropped, or delivered out of order with respect to</para>
		/// <para> each other or with respect to reliable messages.  The same unreliable message</para>
		/// <para> may be received multiple times.</para>
		/// <para> If any messages are returned, you MUST call SteamNetworkingMessage_t::Release() on each</para>
		/// <para> of them free up resources after you are done.  It is safe to keep the object alive for</para>
		/// <para> a little while (put it into some queue, etc), and you may call Release() from any thread.</para>
		/// <para>获取连接中可用的下一个消息（消息），如果存在。返回返回的消息数量，最多 nMaxMessages 条。如果连接句柄无效，则返回 -1。</para>
		/// <para>消息返回的顺序相关。可靠的消息会按照它们发送的顺序收到（并且具有相同的尺寸---参见 SendMessageToConnection 关于这一点与流套接字之间的微妙差异）。</para>
		/// <para>不可靠的消息可能丢失，或者与可靠消息之间顺序错乱，或者彼此之间顺序错乱。相同的不可靠消息可能被接收多次。</para>
		/// <para>如果收到任何消息，必须在完成使用后调用 SteamNetworkingMessage_t::Release() 释放它们，以释放资源。可以安全地将对象存活一段时间（放入队列等），并且可以在任何线程中调用 Release()。</para>
		/// </summary>
		public static int ReceiveMessagesOnConnection(HSteamNetConnection hConn, IntPtr[] ppOutMessages, int nMaxMessages) {
			InteropHelp.TestIfAvailableGameServer();
			if (ppOutMessages != null && ppOutMessages.Length != nMaxMessages) {
				throw new System.ArgumentException("ppOutMessages must be the same size as nMaxMessages!");
			}
			return NativeMethods.ISteamNetworkingSockets_ReceiveMessagesOnConnection(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn, ppOutMessages, nMaxMessages);
		}

		/// <summary>
		/// <para> Returns basic information about the high-level state of the connection.</para>
		/// <para>返回连接的高层状态基本信息。</para>
		/// </summary>
		public static bool GetConnectionInfo(HSteamNetConnection hConn, out SteamNetConnectionInfo_t pInfo) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetConnectionInfo(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn, out pInfo);
		}

		/// <summary>
		/// <para> Returns a small set of information about the real-time state of the connection</para>
		/// <para> and the queue status of each lane.</para>
		/// <para> - pStatus may be NULL if the information is not desired.  (E.g. you are only interested</para>
		/// <para>   in the lane information.)</para>
		/// <para> - On entry, nLanes specifies the length of the pLanes array.  This may be 0</para>
		/// <para>   if you do not wish to receive any lane data.  It's OK for this to be smaller than</para>
		/// <para>   the total number of configured lanes.</para>
		/// <para> - pLanes points to an array that will receive lane-specific info.  It can be NULL</para>
		/// <para>   if this is not needed.</para>
		/// <para> Return value:</para>
		/// <para> - k_EResultNoConnection - connection handle is invalid or connection has been closed.</para>
		/// <para> - k_EResultInvalidParam - nLanes is bad</para>
		/// <para>返回关于实时连接状态和每个车道队列状态的一小部分信息。</para>
		/// <para>- pStatus 可能会是 NULL，如果不需要该信息。 (例如，你只对赛道信息感兴趣。) - 在进入时，nLanes 指定 pLanes 数组的长度。如果不需要接收任何赛道数据，可以将其设置为 0。允许该值小于配置的总赛道数。 - pLanes 指向一个数组，该数组将接收赛道特定信息。如果不需要，它也可以是 NULL。</para>
		/// <para>返回值：- k_EResultNoConnection - 连接句柄无效或连接已关闭。- k_EResultInvalidParam - nLanes 无效</para>
		/// </summary>
		public static EResult GetConnectionRealTimeStatus(HSteamNetConnection hConn, ref SteamNetConnectionRealTimeStatus_t pStatus, int nLanes, ref SteamNetConnectionRealTimeLaneStatus_t pLanes) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetConnectionRealTimeStatus(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn, ref pStatus, nLanes, ref pLanes);
		}

		/// <summary>
		/// <para> Returns detailed connection stats in text format.  Useful</para>
		/// <para> for dumping to a log, etc.</para>
		/// <para> Returns:</para>
		/// <para> -1 failure (bad connection handle)</para>
		/// <para> 0 OK, your buffer was filled in and '\0'-terminated</para>
		/// <para> &gt;0 Your buffer was either nullptr, or it was too small and the text got truncated.</para>
		/// <para>    Try again with a buffer of at least N bytes.</para>
		/// <para>返回详细的连接统计信息，以文本格式。 方便导出到日志等。</para>
		/// <para>Returns: -1 failure (bad connection handle) 0 OK, your buffer was filled in and '\0'-terminated >0 Your buffer was either nullptr, or it was too small and the text got truncated. Try again with a buffer of at least N bytes.</para>
		/// </summary>
		public static int GetDetailedConnectionStatus(HSteamNetConnection hConn, out string pszBuf, int cbBuf) {
			InteropHelp.TestIfAvailableGameServer();
			IntPtr pszBuf2 = Marshal.AllocHGlobal(cbBuf);
			int ret = NativeMethods.ISteamNetworkingSockets_GetDetailedConnectionStatus(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn, pszBuf2, cbBuf);
			pszBuf = ret != -1 ? InteropHelp.PtrToStringUTF8(pszBuf2) : null;
			Marshal.FreeHGlobal(pszBuf2);
			return ret;
		}

		/// <summary>
		/// <para> Returns local IP and port that a listen socket created using CreateListenSocketIP is bound to.</para>
		/// <para> An IPv6 address of ::0 means "any IPv4 or IPv6"</para>
		/// <para> An IPv6 address of ::ffff:0000:0000 means "any IPv4"</para>
		/// <para>返回使用 CreateListenSocketIP 创建的监听套接字绑定到的本地 IP 和端口。</para>
		/// <para>一个 IPv6 地址为 ::0 表示“任何 IPv4 或 IPv6”。一个 IPv6 地址为 ::ffff:0000:0000 表示“任何 IPv4”。</para>
		/// </summary>
		public static bool GetListenSocketAddress(HSteamListenSocket hSocket, out SteamNetworkingIPAddr address) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetListenSocketAddress(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hSocket, out address);
		}

		/// <summary>
		/// <para> Create a pair of connections that are talking to each other, e.g. a loopback connection.</para>
		/// <para> This is very useful for testing, or so that your client/server code can work the same</para>
		/// <para> even when you are running a local "server".</para>
		/// <para> The two connections will immediately be placed into the connected state, and no callbacks</para>
		/// <para> will be posted immediately.  After this, if you close either connection, the other connection</para>
		/// <para> will receive a callback, exactly as if they were communicating over the network.  You must</para>
		/// <para> close *both* sides in order to fully clean up the resources!</para>
		/// <para> By default, internal buffers are used, completely bypassing the network, the chopping up of</para>
		/// <para> messages into packets, encryption, copying the payload, etc.  This means that loopback</para>
		/// <para> packets, by default, will not simulate lag or loss.  Passing true for bUseNetworkLoopback will</para>
		/// <para> cause the socket pair to send packets through the local network loopback device (127.0.0.1)</para>
		/// <para> on ephemeral ports.  Fake lag and loss are supported in this case, and CPU time is expended</para>
		/// <para> to encrypt and decrypt.</para>
		/// <para> If you wish to assign a specific identity to either connection, you may pass a particular</para>
		/// <para> identity.  Otherwise, if you pass nullptr, the respective connection will assume a generic</para>
		/// <para> "localhost" identity.  If you use real network loopback, this might be translated to the</para>
		/// <para> actual bound loopback port.  Otherwise, the port will be zero.</para>
		/// <para>创建一对连接，它们相互通信，例如回环连接。这对于测试非常有用，或者使您的客户端/服务器代码在本地“服务器”运行时也能正常工作。</para>
		/// <para>两个连接会立即进入已连接状态，不会立即发布任何回调。之后，如果关闭其中任何一个连接，另一个连接会收到回调，就像它们在网络上进行通信一样。必须关闭双方才能完全清理资源！</para>
		/// <para>默认情况下，内部缓冲区将被使用，完全绕过网络，消息被切分成数据包，加密、复制有效负载等操作。这意味着，默认情况下，回环包不会模拟延迟或丢包。如果将 `bUseNetworkLoopback` 设置为 `true`，则套件对将在非永生端口上通过本地网络回环设备 (127.0.0.1) 发送数据包。在这种情况下，支持模拟延迟和丢包，并且会消耗 CPU 时间进行加密和解密。</para>
		/// <para>如果您希望为连接指定特定的身份，您可以传递特定的身份。否则，如果传递 nullptr，相应的连接将假设一个通用的“localhost”身份。如果使用真实网络回环，这可能会翻译为实际绑定的回环端口。否则，端口将为零。</para>
		/// </summary>
		public static bool CreateSocketPair(out HSteamNetConnection pOutConnection1, out HSteamNetConnection pOutConnection2, bool bUseNetworkLoopback, ref SteamNetworkingIdentity pIdentity1, ref SteamNetworkingIdentity pIdentity2) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_CreateSocketPair(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), out pOutConnection1, out pOutConnection2, bUseNetworkLoopback, ref pIdentity1, ref pIdentity2);
		}

		/// <summary>
		/// <para> Configure multiple outbound messages streams ("lanes") on a connection, and</para>
		/// <para> control head-of-line blocking between them.  Messages within a given lane</para>
		/// <para> are always sent in the order they are queued, but messages from different</para>
		/// <para> lanes may be sent out of order.  Each lane has its own message number</para>
		/// <para> sequence.  The first message sent on each lane will be assigned the number 1.</para>
		/// <para> Each lane has a "priority".  Lanes with higher numeric values will only be processed</para>
		/// <para> when all lanes with lower number values are empty.  The magnitudes of the priority</para>
		/// <para> values are not relevant, only their sort order.</para>
		/// <para> Each lane also is assigned a weight, which controls the approximate proportion</para>
		/// <para> of the bandwidth that will be consumed by the lane, relative to other lanes</para>
		/// <para> of the same priority.  (This is assuming the lane stays busy.  An idle lane</para>
		/// <para> does not build up "credits" to be be spent once a message is queued.)</para>
		/// <para> This value is only meaningful as a proportion, relative to other lanes with</para>
		/// <para> the same priority.  For lanes with different priorities, the strict priority</para>
		/// <para> order will prevail, and their weights relative to each other are not relevant.</para>
		/// <para> Thus, if a lane has a unique priority value, the weight value for that lane is</para>
		/// <para> not relevant.</para>
		/// <para> Example: 3 lanes, with priorities [ 0, 10, 10 ] and weights [ (NA), 20, 5 ].</para>
		/// <para> Messages sent on the first will always be sent first, before messages in the</para>
		/// <para> other two lanes.  Its weight value is irrelevant, since there are no other</para>
		/// <para> lanes with priority=0.  The other two lanes will share bandwidth, with the second</para>
		/// <para> and third lanes sharing bandwidth using a ratio of approximately 4:1.</para>
		/// <para> (The weights [ NA, 4, 1 ] would be equivalent.)</para>
		/// <para> Notes:</para>
		/// <para> - At the time of this writing, some code has performance cost that is linear</para>
		/// <para>   in the number of lanes, so keep the number of lanes to an absolute minimum.</para>
		/// <para>   3 or so is fine; &gt;8 is a lot.  The max number of lanes on Steam is 255,</para>
		/// <para>   which is a very large number and not recommended!  If you are compiling this</para>
		/// <para>   library from source, see STEAMNETWORKINGSOCKETS_MAX_LANES.)</para>
		/// <para> - Lane priority values may be any int.  Their absolute value is not relevant,</para>
		/// <para>   only the order matters.</para>
		/// <para> - Weights must be positive, and due to implementation details, they are restricted</para>
		/// <para>   to 16-bit values.  The absolute magnitudes don't matter, just the proportions.</para>
		/// <para> - Messages sent on a lane index other than 0 have a small overhead on the wire,</para>
		/// <para>   so for maximum wire efficiency, lane 0 should be the "most common" lane, regardless</para>
		/// <para>   of priorities or weights.</para>
		/// <para> - A connection has a single lane by default.  Calling this function with</para>
		/// <para>   nNumLanes=1 is legal, but pointless, since the priority and weight values are</para>
		/// <para>   irrelevant in that case.</para>
		/// <para> - You may reconfigure connection lanes at any time, however reducing the number of</para>
		/// <para>   lanes is not allowed.</para>
		/// <para> - Reconfiguring lanes might restart any bandwidth sharing balancing.  Usually you</para>
		/// <para>   will call this function once, near the start of the connection, perhaps after</para>
		/// <para>   exchanging a few messages.</para>
		/// <para> - To assign all lanes the same priority, you may use pLanePriorities=NULL.</para>
		/// <para> - If you wish all lanes with the same priority to share bandwidth equally (or</para>
		/// <para>   if no two lanes have the same priority value, and thus priority values are</para>
		/// <para>   irrelevant), you may use pLaneWeights=NULL</para>
		/// <para> - Priorities and weights determine the order that messages are SENT on the wire.</para>
		/// <para>   There are NO GUARANTEES on the order that messages are RECEIVED!  Due to packet</para>
		/// <para>   loss, out-of-order delivery, and subtle details of packet serialization, messages</para>
		/// <para>   might still be received slightly out-of-order!  The *only* strong guarantee is that</para>
		/// <para>   *reliable* messages on the *same lane* will be delivered in the order they are sent.</para>
		/// <para> - Each host configures the lanes for the packets they send; the lanes for the flow</para>
		/// <para>   in one direction are completely unrelated to the lanes in the opposite direction.</para>
		/// <para> Return value:</para>
		/// <para> - k_EResultNoConnection - bad hConn</para>
		/// <para> - k_EResultInvalidParam - Invalid number of lanes, bad weights, or you tried to reduce the number of lanes</para>
		/// <para> - k_EResultInvalidState - Connection is already dead, etc</para>
		/// <para> See also:</para>
		/// <para> SteamNetworkingMessage_t::m_idxLane</para>
		/// <para>配置多个出站消息流 (“lanes”) 在一个连接上，并控制它们之间的头部分隔。 消息在一个给定的 lane 中始终按它们排队的顺序发送，但来自不同 lane 的消息可能会乱序发送。 每个 lane 都有自己的消息编号序列。 每个 lane 的第一条消息将被分配数字 1。</para>
		/// <para>每个车道都有一个“优先级”。 具有较高数值的车道只会当所有数值较低的车道都为空时才会被处理。 数值的大小不重要，仅数值的排序顺序重要。</para>
		/// <para>每个通道也分配了一个权重，它控制了该通道将消耗的带宽的近似比例，相对于相同优先级的其他通道。 (这假设通道保持繁忙。空闲的通道不会积累“信用”用于在消息排队后花费。) 这种值仅在相对于具有相同优先级的其他通道中才有意义。对于具有不同优先级的通道，严格的优先级顺序将生效，并且它们相对于彼此的权重不相关。因此，如果一个通道具有唯一的优先级值，则该通道的权重值不相关。</para>
		/// <para>三个车道，优先级为 [ 0, 10, 10 ]，权重为 [ (NA), 20, 5 ]。发送在第一个车道上的消息将始终优先发送，在其他两个车道上的消息之前。其权重值不重要，因为没有其他车道优先级为 0。其他两个车道将共享带宽，第二个和第三个车道使用大约 4:1 的比例共享带宽。 (权重 [ NA, 4, 1 ] 将等效于此。)</para>
		/// <para>笔记：- 在编写时，某些代码具有线性与行数相关的性能成本，因此请将行数保持在绝对最小值，3个左右是可以的；>8 太多了。Steam 的最大行数为 255，这是一个非常大的数字，不建议使用！如果您从源代码编译此库，请参阅 STEAMNETWORKINGSOCKETS_MAX_LANES。- 行优先级值可以是任何 int。它们的绝对值不相关，仅顺序很重要。- 权重必须为正数，并且由于实现细节，它们受到 16 位值的限制。绝对的幅度无关紧要，只是比例。- 在非 0 行索引上发送的消息会产生少量线路开销，因此为了最大限度地提高线路效率，应将行 0 作为“最常见”的行，无论优先级或权重如何。- 连接默认具有单行。使用 nNumLanes=1 调用此函数在法律上是有效的，但毫无意义，因为在那种情况下，优先级和权重值不相关。- 您可以随时重新配置连接的行数，但减少行数是不允许的。- 重新配置行数可能会重新启动任何带宽共享平衡。通常您会调用此函数一次，在连接的开始附近，例如在交换了几条消息后。- 要为所有行分配相同的优先级，可以使用 pLanePriorities=NULL。- 如果您希望具有相同优先级的所有行以相同的带宽共享（或如果没有任何两个行索引具有相同的优先级值，因此优先级值不相关），则可以使用 pLaneWeights=NULL - 优先级和权重确定消息发送的顺序。但没有任何关于接收消息的顺序的保证！由于包丢失、乱序交付和细微的包序列化细节，消息仍然可能略微乱序接收！*唯一*的保证是*可靠*消息在*同一行*上的传递顺序与发送顺序相同。</para>
		/// <para>返回值：- k_EResultNoConnection - bad hConn - k_EResultInvalidParam - 无效的 lane 数、无效的权重，或者你尝试减少 lane 数 - k_EResultInvalidState - 连接已断开，等。</para>
		/// <para>参见：SteamNetworkingMessage_t::m_idxLane</para>
		/// </summary>
		public static EResult ConfigureConnectionLanes(HSteamNetConnection hConn, int nNumLanes, int[] pLanePriorities, ushort[] pLaneWeights) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_ConfigureConnectionLanes(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn, nNumLanes, pLanePriorities, pLaneWeights);
		}

		/// <summary>
		/// <para> Identity and authentication</para>
		/// <para> Get the identity assigned to this interface.</para>
		/// <para> E.g. on Steam, this is the user's SteamID, or for the gameserver interface, the SteamID assigned</para>
		/// <para> to the gameserver.  Returns false and sets the result to an invalid identity if we don't know</para>
		/// <para> our identity yet.  (E.g. GameServer has not logged in.  On Steam, the user will know their SteamID</para>
		/// <para> even if they are not signed into Steam.)</para>
		/// <para>身份验证和认证</para>
		/// <para>获取该接口的身份标识。例如，在Steam上，这是用户的SteamID，或者对于游戏服务器接口，是分配给游戏服务器的SteamID。如果尚未知道我们的身份，则返回false并将结果设置为无效身份。 (例如，GameServer尚未登录。在Steam上，用户即使未登录Steam，也知道他们的SteamID。)</para>
		/// </summary>
		public static bool GetIdentity(out SteamNetworkingIdentity pIdentity) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetIdentity(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), out pIdentity);
		}

		/// <summary>
		/// <para> Indicate our desire to be ready participate in authenticated communications.</para>
		/// <para> If we are currently not ready, then steps will be taken to obtain the necessary</para>
		/// <para> certificates.   (This includes a certificate for us, as well as any CA certificates</para>
		/// <para> needed to authenticate peers.)</para>
		/// <para> You can call this at program init time if you know that you are going to</para>
		/// <para> be making authenticated connections, so that we will be ready immediately when</para>
		/// <para> those connections are attempted.  (Note that essentially all connections require</para>
		/// <para> authentication, with the exception of ordinary UDP connections with authentication</para>
		/// <para> disabled using k_ESteamNetworkingConfig_IP_AllowWithoutAuth.)  If you don't call</para>
		/// <para> this function, we will wait until a feature is utilized that that necessitates</para>
		/// <para> these resources.</para>
		/// <para> You can also call this function to force a retry, if failure has occurred.</para>
		/// <para> Once we make an attempt and fail, we will not automatically retry.</para>
		/// <para> In this respect, the behavior of the system after trying and failing is the same</para>
		/// <para> as before the first attempt: attempting authenticated communication or calling</para>
		/// <para> this function will call the system to attempt to acquire the necessary resources.</para>
		/// <para> You can use GetAuthenticationStatus or listen for SteamNetAuthenticationStatus_t</para>
		/// <para> to monitor the status.</para>
		/// <para> Returns the current value that would be returned from GetAuthenticationStatus.</para>
		/// <para>表明我们希望准备好参与认证通信。如果目前尚未准备好，则将采取措施获取所需的证书。 （包括一个用于我们的证书，以及用于认证同伴所需的任何CA证书。）</para>
		/// <para>如果在程序初始化时如果知道你将要进行认证连接，你可以调用它，这样我们就能立即准备好，当这些连接尝试时。 (请注意，基本上所有连接都需要认证，除了使用 k_ESteamNetworkingConfig_IP_AllowWithoutAuth 禁用认证的普通 UDP 连接。) 如果你没有调用此函数，我们会在某个功能被使用时才准备这些资源。</para>
		/// <para>你也可以调用这个函数来强制重试，如果发生失败情况。一旦我们尝试并失败，就不会自动重试。 在这种情况下，系统在尝试并失败后，行为与第一次尝试之前完全相同：尝试进行身份验证通信或调用此函数都会将系统引导至尝试获取所需资源。</para>
		/// <para>你可以使用 GetAuthenticationStatus 或监听 SteamNetAuthenticationStatus_t 来监控状态。</para>
		/// <para>Returns the current value that would be returned from GetAuthenticationStatus.</para>
		/// </summary>
		public static ESteamNetworkingAvailability InitAuthentication() {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_InitAuthentication(CSteamGameServerAPIContext.GetSteamNetworkingSockets());
		}

		/// <summary>
		/// <para> Query our readiness to participate in authenticated communications.  A</para>
		/// <para> SteamNetAuthenticationStatus_t callback is posted any time this status changes,</para>
		/// <para> but you can use this function to query it at any time.</para>
		/// <para> The value of SteamNetAuthenticationStatus_t::m_eAvail is returned.  If you only</para>
		/// <para> want this high level status, you can pass NULL for pDetails.  If you want further</para>
		/// <para> details, pass non-NULL to receive them.</para>
		/// <para>查询我们参与身份验证通信的准备情况。当此状态发生变化时，会发布一个 SteamNetAuthenticationStatus_t 回调，但您可以使用此函数随时查询它。</para>
		/// <para>返回 SteamNetAuthenticationStatus_t::m_eAvail 的值。 如果您只想获取此高级状态，则将 pDetails 设置为 NULL。 如果您需要更多详细信息，则将 pDetails 设置为非 NULL 以接收它们。</para>
		/// </summary>
		public static ESteamNetworkingAvailability GetAuthenticationStatus(out SteamNetAuthenticationStatus_t pDetails) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetAuthenticationStatus(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), out pDetails);
		}

		/// <summary>
		/// <para> Poll groups.  A poll group is a set of connections that can be polled efficiently.</para>
		/// <para> (In our API, to "poll" a connection means to retrieve all pending messages.  We</para>
		/// <para> actually don't have an API to "poll" the connection *state*, like BSD sockets.)</para>
		/// <para> Create a new poll group.</para>
		/// <para> You should destroy the poll group when you are done using DestroyPollGroup</para>
		/// <para>民意调查组。民意调查组是一组可以高效进行调查的连接。 (在我们的API中，“调查”一个连接意味着检索所有待处理的消息。我们实际上没有“调查”连接*状态*的API，例如BSD套接字。)</para>
		/// <para>Create a new poll group.</para>
		/// <para>你应该在完成使用时销毁该投票组。</para>
		/// </summary>
		public static HSteamNetPollGroup CreatePollGroup() {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamNetPollGroup)NativeMethods.ISteamNetworkingSockets_CreatePollGroup(CSteamGameServerAPIContext.GetSteamNetworkingSockets());
		}

		/// <summary>
		/// <para> Destroy a poll group created with CreatePollGroup().</para>
		/// <para> If there are any connections in the poll group, they are removed from the group,</para>
		/// <para> and left in a state where they are not part of any poll group.</para>
		/// <para> Returns false if passed an invalid poll group handle.</para>
		/// <para>Destroy a poll group created with CreatePollGroup().</para>
		/// <para>如果投票组中存在任何连接，则从组中移除它们，并将它们置于不再属于任何投票组的状态。如果传入无效的投票组句柄，则返回 false。</para>
		/// </summary>
		public static bool DestroyPollGroup(HSteamNetPollGroup hPollGroup) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_DestroyPollGroup(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hPollGroup);
		}

		/// <summary>
		/// <para> Assign a connection to a poll group.  Note that a connection may only belong to a</para>
		/// <para> single poll group.  Adding a connection to a poll group implicitly removes it from</para>
		/// <para> any other poll group it is in.</para>
		/// <para> You can pass k_HSteamNetPollGroup_Invalid to remove a connection from its current</para>
		/// <para> poll group without adding it to a new poll group.</para>
		/// <para> If there are received messages currently pending on the connection, an attempt</para>
		/// <para> is made to add them to the queue of messages for the poll group in approximately</para>
		/// <para> the order that would have applied if the connection was already part of the poll</para>
		/// <para> group at the time that the messages were received.</para>
		/// <para> Returns false if the connection handle is invalid, or if the poll group handle</para>
		/// <para> is invalid (and not k_HSteamNetPollGroup_Invalid).</para>
		/// <para>分配一个连接到投票组。请注意，一个连接只能属于一个投票组。将一个连接分配给一个投票组会使其从它所属于的任何其他投票组中移除。</para>
		/// <para>你可以通过传递 k_HSteamNetPollGroup_Invalid 来移除连接从其当前的 poll group 中，而无需将其添加到新的 poll group。</para>
		/// <para>如果当前连接上存在待处理的消息，则会尝试将它们添加到 poll 组的消息队列中，大致按照如果该连接在消息接收时就已经属于 poll 组时所应用的顺序添加。</para>
		/// <para>如果连接句柄无效，或者如果 poll 组句柄无效（且不为 k_HSteamNetPollGroup_Invalid），则返回 false。</para>
		/// </summary>
		public static bool SetConnectionPollGroup(HSteamNetConnection hConn, HSteamNetPollGroup hPollGroup) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_SetConnectionPollGroup(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn, hPollGroup);
		}

		/// <summary>
		/// <para> Same as ReceiveMessagesOnConnection, but will return the next messages available</para>
		/// <para> on any connection in the poll group.  Examine SteamNetworkingMessage_t::m_conn</para>
		/// <para> to know which connection.  (SteamNetworkingMessage_t::m_nConnUserData might also</para>
		/// <para> be useful.)</para>
		/// <para> Delivery order of messages among different connections will usually match the</para>
		/// <para> order that the last packet was received which completed the message.  But this</para>
		/// <para> is not a strong guarantee, especially for packets received right as a connection</para>
		/// <para> is being assigned to poll group.</para>
		/// <para> Delivery order of messages on the same connection is well defined and the</para>
		/// <para> same guarantees are present as mentioned in ReceiveMessagesOnConnection.</para>
		/// <para> (But the messages are not grouped by connection, so they will not necessarily</para>
		/// <para> appear consecutively in the list; they may be interleaved with messages for</para>
		/// <para> other connections.)</para>
		/// <para>与 ReceiveMessagesOnConnection 相同，但会返回任何连接池中的可用消息。可以通过 Examine SteamNetworkingMessage_t::m_conn 来确定哪个连接。 (SteamNetworkingMessage_t::m_nConnUserData 也可能很有用。)</para>
		/// <para>消息在不同连接之间交付的顺序通常会与最后一个已接收到的数据包完成消息的顺序相匹配。但是，这并不是一个强有力的保证，尤其是在连接被分配到轮询组时接收到的数据包时。</para>
		/// <para>同一连接的消息传递顺序已明确定义，并且具有 ReceiveMessagesOnConnection 中所述相同的保证。 (但消息未按连接分组，因此它们不会一定出现在列表中连续出现，可能会与其他连接的消息交错。)</para>
		/// </summary>
		public static int ReceiveMessagesOnPollGroup(HSteamNetPollGroup hPollGroup, IntPtr[] ppOutMessages, int nMaxMessages) {
			InteropHelp.TestIfAvailableGameServer();
			if (ppOutMessages != null && ppOutMessages.Length != nMaxMessages) {
				throw new System.ArgumentException("ppOutMessages must be the same size as nMaxMessages!");
			}
			return NativeMethods.ISteamNetworkingSockets_ReceiveMessagesOnPollGroup(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hPollGroup, ppOutMessages, nMaxMessages);
		}

		/// <summary>
		/// <para> Clients connecting to dedicated servers hosted in a data center,</para>
		/// <para> using tickets issued by your game coordinator.  If you are not</para>
		/// <para> issuing your own tickets to restrict who can attempt to connect</para>
		/// <para> to your server, then you won't use these functions.</para>
		/// <para> Call this when you receive a ticket from your backend / matchmaking system.  Puts the</para>
		/// <para> ticket into a persistent cache, and optionally returns the parsed ticket.</para>
		/// <para> See stamdatagram_ticketgen.h for more details.</para>
		/// <para>客户端连接到数据中心托管的专用服务器，使用由你的游戏协调器签发的门票。如果你没有签发自己的门票来限制尝试连接服务器的人员，则不会使用这些功能。</para>
		/// <para>请在收到来自后端/匹配系统中的票据时调用此方法。将票据放入持久性缓存中，并可选地返回解析后的票据。</para>
		/// <para>查看 stamdatagram_ticketgen.h 了解更多详情。</para>
		/// </summary>
		public static bool ReceivedRelayAuthTicket(IntPtr pvTicket, int cbTicket, out SteamDatagramRelayAuthTicket pOutParsedTicket) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_ReceivedRelayAuthTicket(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), pvTicket, cbTicket, out pOutParsedTicket);
		}

		/// <summary>
		/// <para> Search cache for a ticket to talk to the server on the specified virtual port.</para>
		/// <para> If found, returns the number of seconds until the ticket expires, and optionally</para>
		/// <para> the complete cracked ticket.  Returns 0 if we don't have a ticket.</para>
		/// <para> Typically this is useful just to confirm that you have a ticket, before you</para>
		/// <para> call ConnectToHostedDedicatedServer to connect to the server.</para>
		/// <para>搜索缓存中是否有指定虚拟端口的服务器票据。如果找到，则返回票据到期前的秒数，并可选地返回完整的已破解票据。如果没有票据，则返回 0。</para>
		/// <para>通常这只是为了确认您是否有票，在调用ConnectToHostedDedicatedServer连接到服务器之前。</para>
		/// </summary>
		public static int FindRelayAuthTicketForServer(ref SteamNetworkingIdentity identityGameServer, int nRemoteVirtualPort, out SteamDatagramRelayAuthTicket pOutParsedTicket) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_FindRelayAuthTicketForServer(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), ref identityGameServer, nRemoteVirtualPort, out pOutParsedTicket);
		}

		/// <summary>
		/// <para> Client call to connect to a server hosted in a Valve data center, on the specified virtual</para>
		/// <para> port.  You must have placed a ticket for this server into the cache, or else this connect</para>
		/// <para> attempt will fail!  If you are not issuing your own tickets, then to connect to a dedicated</para>
		/// <para> server via SDR in auto-ticket mode, use ConnectP2P.  (The server must be configured to allow</para>
		/// <para> this type of connection by listening using CreateListenSocketP2P.)</para>
		/// <para> You may wonder why tickets are stored in a cache, instead of simply being passed as an argument</para>
		/// <para> here.  The reason is to make reconnection to a gameserver robust, even if the client computer loses</para>
		/// <para> connection to Steam or the central backend, or the app is restarted or crashes, etc.</para>
		/// <para> If you use this, you probably want to call ISteamNetworkingUtils::InitRelayNetworkAccess()</para>
		/// <para> when your app initializes</para>
		/// <para> If you need to set any initial config options, pass them here.  See</para>
		/// <para> SteamNetworkingConfigValue_t for more about why this is preferable to</para>
		/// <para> setting the options "immediately" after creation.</para>
		/// <para>与在 Valve 数据中心托管的服务器建立客户端连接，在指定虚拟端口上。您必须已将此服务器的票务放入缓存中，否则此连接尝试将失败！如果您没有自行创建票务，则通过 SDR 以自动票务模式连接到专用服务器，请使用 ConnectP2P。 (服务器必须配置为允许通过使用 CreateListenSocketP2P 监听此类型连接。)</para>
		/// <para>您可能会想知道为什么门票存储在缓存中，而不是直接作为参数传递在这里。原因是即使客户端计算机丢失与Steam或中央后端之间的连接，或者应用程序重新启动或崩溃等情况发生，也能实现对游戏服务器的健壮重新连接。</para>
		/// <para>如果你使用这个，你可能需要调用 ISteamNetworkingUtils::InitRelayNetworkAccess() 当你的应用初始化时。</para>
		/// <para>如果您需要设置任何初始配置选项，请在此处提供。有关为何更喜欢“立即”设置选项而不是在创建后设置选项的更多信息，请参见 SteamNetworkingConfigValue_t。</para>
		/// </summary>
		public static HSteamNetConnection ConnectToHostedDedicatedServer(ref SteamNetworkingIdentity identityTarget, int nRemoteVirtualPort, int nOptions, SteamNetworkingConfigValue_t[] pOptions) {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamNetConnection)NativeMethods.ISteamNetworkingSockets_ConnectToHostedDedicatedServer(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), ref identityTarget, nRemoteVirtualPort, nOptions, pOptions);
		}

		/// <summary>
		/// <para> Servers hosted in data centers known to the Valve relay network</para>
		/// <para> Returns the value of the SDR_LISTEN_PORT environment variable.  This</para>
		/// <para> is the UDP server your server will be listening on.  This will</para>
		/// <para> configured automatically for you in production environments.</para>
		/// <para> In development, you'll need to set it yourself.  See</para>
		/// <para> https://partner.steamgames.com/doc/api/ISteamNetworkingSockets</para>
		/// <para> for more information on how to configure dev environments.</para>
		/// <para>在Valve已知的数据中心托管的服务器</para>
		/// <para>返回 SDR_LISTEN_PORT 环境变量的值。这是您的服务器监听的 UDP 服务器。在生产环境中，这将被自动配置好。</para>
		/// <para>在开发中，您需要自己设置。有关如何配置开发环境的更多信息，请参阅 https://partner.steamgames.com/doc/api/ISteamNetworkingSockets。</para>
		/// </summary>
		public static ushort GetHostedDedicatedServerPort() {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetHostedDedicatedServerPort(CSteamGameServerAPIContext.GetSteamNetworkingSockets());
		}

		/// <summary>
		/// <para> Returns 0 if SDR_LISTEN_PORT is not set.  Otherwise, returns the data center the server</para>
		/// <para> is running in.  This will be k_SteamDatagramPOPID_dev in non-production environment.</para>
		/// <para>如果未设置 SDR_LISTEN_PORT，则返回 0。否则，返回服务器运行的数据中心。在非生产环境中，将返回 k_SteamDatagramPOPID_dev。</para>
		/// </summary>
		public static SteamNetworkingPOPID GetHostedDedicatedServerPOPID() {
			InteropHelp.TestIfAvailableGameServer();
			return (SteamNetworkingPOPID)NativeMethods.ISteamNetworkingSockets_GetHostedDedicatedServerPOPID(CSteamGameServerAPIContext.GetSteamNetworkingSockets());
		}

		/// <summary>
		/// <para> Return info about the hosted server.  This contains the PoPID of the server,</para>
		/// <para> and opaque routing information that can be used by the relays to send traffic</para>
		/// <para> to your server.</para>
		/// <para> You will need to send this information to your backend, and put it in tickets,</para>
		/// <para> so that the relays will know how to forward traffic from</para>
		/// <para> clients to your server.  See SteamDatagramRelayAuthTicket for more info.</para>
		/// <para> Also, note that the routing information is contained in SteamDatagramGameCoordinatorServerLogin,</para>
		/// <para> so if possible, it's preferred to use GetGameCoordinatorServerLogin to send this info</para>
		/// <para> to your game coordinator service, and also login securely at the same time.</para>
		/// <para> On a successful exit, k_EResultOK is returned</para>
		/// <para> Unsuccessful exit:</para>
		/// <para> - Something other than k_EResultOK is returned.</para>
		/// <para> - k_EResultInvalidState: We are not configured to listen for SDR (SDR_LISTEN_SOCKET</para>
		/// <para>   is not set.)</para>
		/// <para> - k_EResultPending: we do not (yet) have the authentication information needed.</para>
		/// <para>   (See GetAuthenticationStatus.)  If you use environment variables to pre-fetch</para>
		/// <para>   the network config, this data should always be available immediately.</para>
		/// <para> - A non-localized diagnostic debug message will be placed in m_data that describes</para>
		/// <para>   the cause of the failure.</para>
		/// <para> NOTE: The returned blob is not encrypted.  Send it to your backend, but don't</para>
		/// <para>       directly share it with clients.</para>
		/// <para>返回托管服务器的信息。此信息包含服务器的PoPID以及用于 relays 将流量发送到您服务器的非透明路由信息。</para>
		/// <para>您需要将此信息发送到后端，并将其放入工单中，以便中继知道如何从客户端转发流量到您的服务器。 参见 SteamDatagramRelayAuthTicket 以获取更多信息。</para>
		/// <para>同时，路由信息包含在 SteamDatagramGameCoordinatorServerLogin 中，因此最好使用 GetGameCoordinatorServerLogin 将此信息发送到您的游戏协调器服务，并同时进行安全登录。</para>
		/// <para>在成功退出时，k_EResultOK 会被返回。</para>
		/// <para>失败退出：- 返回值不是 k_EResultOK。- k_EResultInvalidState：我们未配置为监听 SDR（SDR_LISTEN_SOCKET 未设置）。- k_EResultPending：我们（目前）还没有所需的身份验证信息。（参见 GetAuthenticationStatus。）  如果您使用环境变量预先获取网络配置，这些数据应始终立即可用。- 一个非本地化诊断调试消息将被放置在 m_data 中，描述失败的原因。</para>
		/// <para>注意：返回的 blob 未加密。将其发送到你的后端，但不要直接与客户端共享。</para>
		/// </summary>
		public static EResult GetHostedDedicatedServerAddress(out SteamDatagramHostedAddress pRouting) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetHostedDedicatedServerAddress(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), out pRouting);
		}

		/// <summary>
		/// <para> Create a listen socket on the specified virtual port.  The physical UDP port to use</para>
		/// <para> will be determined by the SDR_LISTEN_PORT environment variable.  If a UDP port is not</para>
		/// <para> configured, this call will fail.</para>
		/// <para> This call MUST be made through the SteamGameServerNetworkingSockets() interface.</para>
		/// <para> This function should be used when you are using the ticket generator library</para>
		/// <para> to issue your own tickets.  Clients connecting to the server on this virtual</para>
		/// <para> port will need a ticket, and they must connect using ConnectToHostedDedicatedServer.</para>
		/// <para> If you need to set any initial config options, pass them here.  See</para>
		/// <para> SteamNetworkingConfigValue_t for more about why this is preferable to</para>
		/// <para> setting the options "immediately" after creation.</para>
		/// <para>创建一个监听套接字，使用指定的虚拟端口。物理 UDP 端口将由 SDR_LISTEN_PORT 环境变量确定。如果未配置 UDP 端口，则此调用将失败。</para>
		/// <para>这个调用必须通过 SteamGameServerNetworkingSockets() 接口进行。</para>
		/// <para>这个函数应该在您使用票务生成器库时，自行创建票务时使用。连接到该虚拟端口的客户端需要一张票务，并且必须使用 ConnectToHostedDedicatedServer 进行连接。</para>
		/// <para>如果您需要设置任何初始配置选项，请在此处提供。有关为何更喜欢“立即”设置选项而不是在创建后设置选项的更多信息，请参见 SteamNetworkingConfigValue_t。</para>
		/// </summary>
		public static HSteamListenSocket CreateHostedDedicatedServerListenSocket(int nLocalVirtualPort, int nOptions, SteamNetworkingConfigValue_t[] pOptions) {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamListenSocket)NativeMethods.ISteamNetworkingSockets_CreateHostedDedicatedServerListenSocket(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), nLocalVirtualPort, nOptions, pOptions);
		}

		/// <summary>
		/// <para> Generate an authentication blob that can be used to securely login with</para>
		/// <para> your backend, using SteamDatagram_ParseHostedServerLogin.  (See</para>
		/// <para> steamdatagram_gamecoordinator.h)</para>
		/// <para> Before calling the function:</para>
		/// <para> - Populate the app data in pLoginInfo (m_cbAppData and m_appData).  You can leave</para>
		/// <para>   all other fields uninitialized.</para>
		/// <para> - *pcbSignedBlob contains the size of the buffer at pBlob.  (It should be</para>
		/// <para>   at least k_cbMaxSteamDatagramGameCoordinatorServerLoginSerialized.)</para>
		/// <para> On a successful exit:</para>
		/// <para> - k_EResultOK is returned</para>
		/// <para> - All of the remaining fields of pLoginInfo will be filled out.</para>
		/// <para> - *pcbSignedBlob contains the size of the serialized blob that has been</para>
		/// <para>   placed into pBlob.</para>
		/// <para> Unsuccessful exit:</para>
		/// <para> - Something other than k_EResultOK is returned.</para>
		/// <para> - k_EResultNotLoggedOn: you are not logged in (yet)</para>
		/// <para> - See GetHostedDedicatedServerAddress for more potential failure return values.</para>
		/// <para> - A non-localized diagnostic debug message will be placed in pBlob that describes</para>
		/// <para>   the cause of the failure.</para>
		/// <para> This works by signing the contents of the SteamDatagramGameCoordinatorServerLogin</para>
		/// <para> with the cert that is issued to this server.  In dev environments, it's OK if you do</para>
		/// <para> not have a cert.  (You will need to enable insecure dev login in SteamDatagram_ParseHostedServerLogin.)</para>
		/// <para> Otherwise, you will need a signed cert.</para>
		/// <para> NOTE: The routing blob returned here is not encrypted.  Send it to your backend</para>
		/// <para>       and don't share it directly with clients.</para>
		/// <para>Please provide the code snippet or instructions for generating the authentication blob using `SteamDatagram_ParseHostedServerLogin` from `steamdatagram_gamecoordinator.h`. I need the specific details to translate and output the relevant content.</para>
		/// <para>在调用函数之前：- 填充应用数据到 pLoginInfo (m_cbAppData 和 m_appData)。 可以将所有其他字段初始化为空。 - *pcbSignedBlob 包含 pBlob 缓冲区的尺寸 (它应该至少为 k_cbMaxSteamDatagramGameCoordinatorServerLoginSerialized)。</para>
		/// <para>在成功退出时：- k_EResultOK 被返回 - 所有剩余的字段都将被 pLoginInfo 填充 - *pcbSignedBlob 包含已放入 pBlob 中的序列化 blob 的大小。</para>
		/// <para>未成功退出：- 返回值不是 k_EResultOK - k_EResultNotLoggedOn：您尚未登录（还未） - 参见 GetHostedDedicatedServerAddress 了解更多潜在的失败返回值。 - 将描述失败原因的非本地化诊断调试消息放置在 pBlob 中。</para>
		/// <para>这通过对 SteamDatagramGameCoordinatorServerLogin 的内容进行签名，使用该服务器颁发的证书。在开发环境中，如果不需要证书也可以。 (您需要在 SteamDatagram_ParseHostedServerLogin 中启用不安全开发登录。) 否则，您需要一个签名证书。</para>
		/// <para>注意：此处返回的路由块未加密。将其发送到您的后端，不要直接与客户端共享。</para>
		/// </summary>
		public static EResult GetGameCoordinatorServerLogin(IntPtr pLoginInfo, out int pcbSignedBlob, IntPtr pBlob) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetGameCoordinatorServerLogin(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), pLoginInfo, out pcbSignedBlob, pBlob);
		}

		/// <summary>
		/// <para> Relayed connections using custom signaling protocol</para>
		/// <para> This is used if you have your own method of sending out-of-band</para>
		/// <para> signaling / rendezvous messages through a mutually trusted channel.</para>
		/// <para> Create a P2P "client" connection that does signaling over a custom</para>
		/// <para> rendezvous/signaling channel.</para>
		/// <para> pSignaling points to a new object that you create just for this connection.</para>
		/// <para> It must stay valid until Release() is called.  Once you pass the</para>
		/// <para> object to this function, it assumes ownership.  Release() will be called</para>
		/// <para> from within the function call if the call fails.  Furthermore, until Release()</para>
		/// <para> is called, you should be prepared for methods to be invoked on your</para>
		/// <para> object from any thread!  You need to make sure your object is threadsafe!</para>
		/// <para> Furthermore, you should make sure that dispatching the methods is done</para>
		/// <para> as quickly as possible.</para>
		/// <para> This function will immediately construct a connection in the "connecting"</para>
		/// <para> state.  Soon after (perhaps before this function returns, perhaps in another thread),</para>
		/// <para> the connection will begin sending signaling messages by calling</para>
		/// <para> ISteamNetworkingConnectionSignaling::SendSignal.</para>
		/// <para> When the remote peer accepts the connection (See</para>
		/// <para> ISteamNetworkingSignalingRecvContext::OnConnectRequest),</para>
		/// <para> it will begin sending signaling messages.  When these messages are received,</para>
		/// <para> you can pass them to the connection using ReceivedP2PCustomSignal.</para>
		/// <para> If you know the identity of the peer that you expect to be on the other end,</para>
		/// <para> you can pass their identity to improve debug output or just detect bugs.</para>
		/// <para> If you don't know their identity yet, you can pass NULL, and their</para>
		/// <para> identity will be established in the connection handshake.</para>
		/// <para> If you use this, you probably want to call ISteamNetworkingUtils::InitRelayNetworkAccess()</para>
		/// <para> when your app initializes</para>
		/// <para> If you need to set any initial config options, pass them here.  See</para>
		/// <para> SteamNetworkingConfigValue_t for more about why this is preferable to</para>
		/// <para> setting the options "immediately" after creation.</para>
		/// <para>自定义信号协议的连接传输</para>
		/// <para>这用于在通过一个双方都信任的渠道发送异构信号/会话消息。</para>
		/// <para>Okay, please provide the content you want me to translate into simplified Chinese. I will translate it directly and output only the translated text.</para>
		/// <para>pSignaling 指向你为这个连接创建的新对象。它必须在 Release() 被调用时保持有效。一旦你将该对象传递给该函数，它就承担了所有权。Release() 将在函数调用失败时从内部被调用。此外，在 Release() 被调用之前，你必须准备好从任何线程上调用该对象的任何方法！ 你需要确保你的对象是线程安全的！ 此外，你应该确保方法的调度尽可能快。</para>
		/// <para>这个函数会立即建立一个处于“connecting”状态的连接。 很快（可能在函数返回之前，也可能在另一个线程中），连接将开始发送信号消息，通过调用 ISteamNetworkingConnectionSignaling::SendSignal。</para>
		/// <para>当远程对端接受连接（参见 ISteamNetworkingSignalingRecvContext::OnConnectRequest），它将开始发送信号消息。当这些消息被接收时，你可以使用 ReceivedP2PCustomSignal 将它们传递给连接。</para>
		/// <para>如果您知道您期望在另一端看到的同伴身份，可以通过传递他们的身份来改善调试输出或仅检测错误。如果您还不清楚他们的身份，可以传递 NULL，他们的身份将在连接握手过程中建立。</para>
		/// <para>如果你使用这个，你可能需要调用 ISteamNetworkingUtils::InitRelayNetworkAccess() 当你的应用初始化时。</para>
		/// <para>如果您需要设置任何初始配置选项，请在此处提供。有关为何更喜欢“立即”设置选项而不是在创建后设置选项的更多信息，请参见 SteamNetworkingConfigValue_t。</para>
		/// </summary>
		public static HSteamNetConnection ConnectP2PCustomSignaling(out ISteamNetworkingConnectionSignaling pSignaling, ref SteamNetworkingIdentity pPeerIdentity, int nRemoteVirtualPort, int nOptions, SteamNetworkingConfigValue_t[] pOptions) {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamNetConnection)NativeMethods.ISteamNetworkingSockets_ConnectP2PCustomSignaling(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), out pSignaling, ref pPeerIdentity, nRemoteVirtualPort, nOptions, pOptions);
		}

		/// <summary>
		/// <para> Called when custom signaling has received a message.  When your</para>
		/// <para> signaling channel receives a message, it should save off whatever</para>
		/// <para> routing information was in the envelope into the context object,</para>
		/// <para> and then pass the payload to this function.</para>
		/// <para> A few different things can happen next, depending on the message:</para>
		/// <para> - If the signal is associated with existing connection, it is dealt</para>
		/// <para>   with immediately.  If any replies need to be sent, they will be</para>
		/// <para>   dispatched using the ISteamNetworkingConnectionSignaling</para>
		/// <para>   associated with the connection.</para>
		/// <para> - If the message represents a connection request (and the request</para>
		/// <para>   is not redundant for an existing connection), a new connection</para>
		/// <para>   will be created, and ReceivedConnectRequest will be called on your</para>
		/// <para>   context object to determine how to proceed.</para>
		/// <para> - Otherwise, the message is for a connection that does not</para>
		/// <para>   exist (anymore).  In this case, we *may* call SendRejectionReply</para>
		/// <para>   on your context object.</para>
		/// <para> In any case, we will not save off pContext or access it after this</para>
		/// <para> function returns.</para>
		/// <para> Returns true if the message was parsed and dispatched without anything</para>
		/// <para> unusual or suspicious happening.  Returns false if there was some problem</para>
		/// <para> with the message that prevented ordinary handling.  (Debug output will</para>
		/// <para> usually have more information.)</para>
		/// <para> If you expect to be using relayed connections, then you probably want</para>
		/// <para> to call ISteamNetworkingUtils::InitRelayNetworkAccess() when your app initializes</para>
		/// <para>当自定义信号已接收到消息时，当你的信号通道接收到消息时，应该将信封中包含的任何路由信息保存到上下文对象中，然后将有效负载传递给此函数。</para>
		/// <para>接下来可能会发生一些不同的情况，取决于消息内容：</para>
		/// <para>如果信号与现有连接相关联，则会立即处理。如果需要发送任何回复，它们将使用与连接相关的IStmSteamNetworkingConnectionSignaling进行发送。- 如果消息代表连接请求（并且该请求对于现有连接不是冗余的），将创建一个新的连接，并调用您的上下文对象上的ReceivedConnectRequest来确定如何继续。- 否则，消息是针对不存在（或已不再存在）的连接。在这种情况下，我们*可能*会调用您的上下文对象上的SendRejectionReply。</para>
		/// <para>在任何情况下，我们不会保存或访问 pContext 在此函数返回后。</para>
		/// <para>如果消息被解析和分发时没有发生任何异常或可疑情况，则返回 true。如果消息存在导致无法进行普通处理的问题，则返回 false。 (调试输出通常会提供更多信息。)</para>
		/// <para>如果预期使用中继连接，那么您应该在应用程序初始化时调用 ISteamNetworkingUtils::InitRelayNetworkAccess()</para>
		/// </summary>
		public static bool ReceivedP2PCustomSignal(IntPtr pMsg, int cbMsg, out ISteamNetworkingSignalingRecvContext pContext) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_ReceivedP2PCustomSignal(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), pMsg, cbMsg, out pContext);
		}

		/// <summary>
		/// <para> Certificate provision by the application.  On Steam, we normally handle all this automatically</para>
		/// <para> and you will not need to use these advanced functions.</para>
		/// <para> Get blob that describes a certificate request.  You can send this to your game coordinator.</para>
		/// <para> Upon entry, *pcbBlob should contain the size of the buffer.  On successful exit, it will</para>
		/// <para> return the number of bytes that were populated.  You can pass pBlob=NULL to query for the required</para>
		/// <para> size.  (512 bytes is a conservative estimate.)</para>
		/// <para> Pass this blob to your game coordinator and call SteamDatagram_CreateCert.</para>
		/// <para>应用程序提供的证书。在Steam上，我们通常自动处理所有这些，您不需要使用这些高级功能。</para>
		/// <para>获取描述证书请求的 blob。你可以将此信息发送到你的游戏协调器。在进入时，*pcbBlob 应该包含缓冲区的尺寸。在成功退出时，它将返回填充的字节数。你可以通过将 pBlob=NULL 传递来查询所需的尺寸。（512 字节是一个保守的估计。）</para>
		/// <para>Pass this blob to your game coordinator and call SteamDatagram_CreateCert.</para>
		/// </summary>
		public static bool GetCertificateRequest(out int pcbBlob, IntPtr pBlob, out SteamNetworkingErrMsg errMsg) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetCertificateRequest(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), out pcbBlob, pBlob, out errMsg);
		}

		/// <summary>
		/// <para> Set the certificate.  The certificate blob should be the output of</para>
		/// <para> SteamDatagram_CreateCert.</para>
		/// <para>Set the certificate. The certificate blob should be the output of SteamDatagram_CreateCert.</para>
		/// </summary>
		public static bool SetCertificate(IntPtr pCertificate, int cbCertificate, out SteamNetworkingErrMsg errMsg) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_SetCertificate(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), pCertificate, cbCertificate, out errMsg);
		}

		/// <summary>
		/// <para> Reset the identity associated with this instance.</para>
		/// <para> Any open connections are closed.  Any previous certificates, etc are discarded.</para>
		/// <para> You can pass a specific identity that you want to use, or you can pass NULL,</para>
		/// <para> in which case the identity will be invalid until you set it using SetCertificate</para>
		/// <para> NOTE: This function is not actually supported on Steam!  It is included</para>
		/// <para>       for use on other platforms where the active user can sign out and</para>
		/// <para>       a new user can sign in.</para>
		/// <para>重置该实例关联的身份。关闭所有打开的连接。任何先前证书等都将被丢弃。你可以传递一个特定的身份，或者传递NULL，在这种情况下，身份将无效直到你使用SetCertificate设置它。</para>
		/// <para>注意：此功能在Steam上实际上不受支持！它包含在其他平台上使用，这些平台上活跃用户可以登出并新用户可以登录。</para>
		/// </summary>
		public static void ResetIdentity(ref SteamNetworkingIdentity pIdentity) {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamNetworkingSockets_ResetIdentity(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), ref pIdentity);
		}

		/// <summary>
		/// <para> Misc</para>
		/// <para> Invoke all callback functions queued for this interface.</para>
		/// <para> See k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged, etc</para>
		/// <para> You don't need to call this if you are using Steam's callback dispatch</para>
		/// <para> mechanism (SteamAPI_RunCallbacks and SteamGameserver_RunCallbacks).</para>
		/// <para>杂项</para>
		/// <para>调用此接口排队的全部回调函数。例如 k_ESteamNetworkingConfig_Callback_ConnectionStatusChanged 等。</para>
		/// <para>你不需要使用 Steam 的回调派发机制（SteamAPI_RunCallbacks 和 SteamGameserver_RunCallbacks）就来调用它。</para>
		/// </summary>
		public static void RunCallbacks() {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamNetworkingSockets_RunCallbacks(CSteamGameServerAPIContext.GetSteamNetworkingSockets());
		}

		/// <summary>
		/// <para> "FakeIP" system.</para>
		/// <para> A FakeIP is essentially a temporary, arbitrary identifier that</para>
		/// <para> happens to be a valid IPv4 address.  The purpose of this system is to make it</para>
		/// <para> easy to integrate with existing code that identifies hosts using IPv4 addresses.</para>
		/// <para> The FakeIP address will never actually be used to send or receive any packets</para>
		/// <para> on the Internet, it is strictly an identifier.</para>
		/// <para> FakeIP addresses are designed to (hopefully) pass through existing code as</para>
		/// <para> transparently as possible, while conflicting with "real" addresses that might</para>
		/// <para> be in use on networks (both the Internet and LANs) in the same code as little</para>
		/// <para> as possible.  At the time this comment is being written, they come from the</para>
		/// <para> 169.254.0.0/16 range, and the port number will always be &gt;1024.  HOWEVER,</para>
		/// <para> this is subject to change!  Do not make assumptions about these addresses,</para>
		/// <para> or your code might break in the future.  In particular, you should use</para>
		/// <para> functions such as  ISteamNetworkingUtils::IsFakeIP to determine if an IP</para>
		/// <para> address is a "fake" one used by this system.</para>
		/// <para> Begin asynchronous process of allocating a fake IPv4 address that other</para>
		/// <para> peers can use to contact us via P2P.  IP addresses returned by this</para>
		/// <para> function are globally unique for a given appid.</para>
		/// <para> nNumPorts is the numbers of ports you wish to reserve.  This is useful</para>
		/// <para> for the same reason that listening on multiple UDP ports is useful for</para>
		/// <para> different types of traffic.  Because these allocations come from a global</para>
		/// <para> namespace, there is a relatively strict limit on the maximum number of</para>
		/// <para> ports you may request.  (At the time of this writing, the limit is 4.)</para>
		/// <para> The port assignments are *not* guaranteed to have any particular order</para>
		/// <para> or relationship!  Do *not* assume they are contiguous, even though that</para>
		/// <para> may often occur in practice.</para>
		/// <para> Returns false if a request was already in progress, true if a new request</para>
		/// <para> was started.  A SteamNetworkingFakeIPResult_t will be posted when the request</para>
		/// <para> completes.</para>
		/// <para> For gameservers, you *must* call this after initializing the SDK but before</para>
		/// <para> beginning login.  Steam needs to know in advance that FakeIP will be used.</para>
		/// <para> Everywhere your public IP would normally appear (such as the server browser) will be</para>
		/// <para> replaced by the FakeIP, and the fake port at index 0.  The request is actually queued</para>
		/// <para> until the logon completes, so you must not wait until the allocation completes</para>
		/// <para> before logging in.  Except for trivial failures that can be detected locally</para>
		/// <para> (e.g. invalid parameter), a SteamNetworkingFakeIPResult_t callback (whether success or</para>
		/// <para> failure) will not be posted until after we have logged in.  Furthermore, it is assumed</para>
		/// <para> that FakeIP allocation is essential for your application to function, and so failure</para>
		/// <para> will not be reported until *several* retries have been attempted.  This process may</para>
		/// <para> last several minutes.  It is *highly* recommended to treat failure as fatal.</para>
		/// <para> To communicate using a connection-oriented (TCP-style) API:</para>
		/// <para> - Server creates a listen socket using CreateListenSocketP2PFakeIP</para>
		/// <para> - Client connects using ConnectByIPAddress, passing in the FakeIP address.</para>
		/// <para> - The connection will behave mostly like a P2P connection.  The identities</para>
		/// <para>   that appear in SteamNetConnectionInfo_t will be the FakeIP identity until</para>
		/// <para>   we know the real identity.  Then it will be the real identity.  If the</para>
		/// <para>   SteamNetConnectionInfo_t::m_addrRemote is valid, it will be a real IPv4</para>
		/// <para>   address of a NAT-punched connection.  Otherwise, it will not be valid.</para>
		/// <para> To communicate using an ad-hoc sendto/recv from (UDP-style) API,</para>
		/// <para> use CreateFakeUDPPort.</para>
		/// <para>“FakeIP”系统。</para>
		/// <para>一个假IP本质上是一个临时的、任意标识符，恰好是一个有效的 IPv4 地址。该系统的目的是使其易于与使用 IPv4 地址识别主机的现有代码集成。假IP地址永远不会实际用于在 Internet 上发送或接收任何数据包，它仅作为标识符使用。</para>
		/// <para>假IP地址的设计是为了（希望）尽可能透明地通过现有代码，同时与可能在网络中使用（包括互联网和局域网）的“真实”地址冲突，在代码中尽量减少冲突。 在编写此评论时，它们来自 169.254.0.0/16 范围，端口号始终大于 1024。 但是，这可能会发生变化！ 不要对这些地址做出任何假设，否则您的代码可能会在未来中断。 尤其，您应该使用诸如 ISTeamNetworkingUtils::IsFakeIP 之类的函数来确定 IP 地址是否为该系统使用的“假”地址。</para>
		/// <para>开始异步进程，为其他同伴分配一个虚假的 IPv4 地址，以便他们可以通过 P2P 联系我们。该函数返回的 IP 地址在给定 appid 上全局唯一。</para>
		/// <para>nNumPorts 是你希望预留的端口数量。这与监听多个 UDP 端口同样有道理，因为它们可以用于不同类型的流量。由于这些分配来自全局命名空间，因此你可能请求的最大端口数量受到相对严格的限制（在当时写这篇文档时，限制为 4）。端口分配*不*保证具有任何特定的顺序或关系！即使在实践中，也不要假设它们是连续的。</para>
		/// <para>如果请求正在进行中，则返回 false，如果启动了新的请求，则返回 true。当请求完成时，将发布一个 SteamNetworkingFakeIPResult_t。</para>
		/// <para>对于游戏服务器，您*必须*在初始化 SDK 之后，在开始登录之前调用它。Steam 需要提前知道 FakeIP 将被使用。服务器浏览器中通常出现的任何公共 IP 地址都将被 FakeIP 替换，以及索引为 0 的虚假端口。请求实际上会排队直到登录完成，因此您不能在分配完成之前等待登录完成。除了可以本地检测的简单失败（例如无效参数）之外，SteamNetworkingFakeIPResult_t 回调（无论成功与否）都不会在登录完成后发布。此外，假设 FakeIP 分配对您的应用程序的功能至关重要，因此失败将不会在*多次*重试尝试后报告。此过程可能持续数分钟。*强烈建议*将失败视为致命。</para>
		/// <para>使用连接式（TCP 风格）API 进行通信：- 服务器使用 CreateListenSocketP2PFakeIP 创建监听套接字 - 客户端使用 ConnectByIPAddress，传入 FakeIP 地址。- 连接将表现得类似于 P2P 连接。SteamNetConnectionInfo_t 中出现的身份将在我们知道真实身份之前是 FakeIP 身份。然后它将是真实身份。如果 SteamNetConnectionInfo_t::m_addrRemote 有效，它将是 NAT 穿透的真实 IPv4 地址。否则，它将无效。</para>
		/// <para>使用 CreateFakeUDPPort 接口进行 ad-hoc sendto/recv (UDP 风格) API 通信。</para>
		/// </summary>
		public static bool BeginAsyncRequestFakeIP(int nNumPorts) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_BeginAsyncRequestFakeIP(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), nNumPorts);
		}

		/// <summary>
		/// <para> Return info about the FakeIP and port(s) that we have been assigned,</para>
		/// <para> if any.  idxFirstPort is currently reserved and must be zero.</para>
		/// <para> Make sure and check SteamNetworkingFakeIPResult_t::m_eResult</para>
		/// <para>返回关于我们分配的假IP和端口（如果有）的信息。idxFirstPort 目前已被保留，必须为零。请务必检查 SteamNetworkingFakeIPResult_t::m_eResult。</para>
		/// </summary>
		public static void GetFakeIP(int idxFirstPort, out SteamNetworkingFakeIPResult_t pInfo) {
			InteropHelp.TestIfAvailableGameServer();
			NativeMethods.ISteamNetworkingSockets_GetFakeIP(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), idxFirstPort, out pInfo);
		}

		/// <summary>
		/// <para> Create a listen socket that will listen for P2P connections sent</para>
		/// <para> to our FakeIP.  A peer can initiate connections to this listen</para>
		/// <para> socket by calling ConnectByIPAddress.</para>
		/// <para> idxFakePort refers to the *index* of the fake port requested,</para>
		/// <para> not the actual port number.  For example, pass 0 to refer to the</para>
		/// <para> first port in the reservation.  You must call this only after calling</para>
		/// <para> BeginAsyncRequestFakeIP.  However, you do not need to wait for the</para>
		/// <para> request to complete before creating the listen socket.</para>
		/// <para>Create a listen socket that will listen for P2P connections sent to our FakeIP. A peer can initiate connections to this listen socket by calling ConnectByIPAddress. 创建一个监听套接字，监听传入的P2P连接到我们的FakeIP。一个同伴可以通过调用ConnectByIPAddress来连接到此监听套接字。</para>
		/// <para>idxFakePort 指的是 *索引*，而不是实际的端口号。例如，传递 0 指向保留中的第一个端口。您必须在调用 BeginAsyncRequestFakeIP 之后才调用它。但是，您无需在请求完成之前再创建监听套接字。</para>
		/// </summary>
		public static HSteamListenSocket CreateListenSocketP2PFakeIP(int idxFakePort, int nOptions, SteamNetworkingConfigValue_t[] pOptions) {
			InteropHelp.TestIfAvailableGameServer();
			return (HSteamListenSocket)NativeMethods.ISteamNetworkingSockets_CreateListenSocketP2PFakeIP(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), idxFakePort, nOptions, pOptions);
		}

		/// <summary>
		/// <para> If the connection was initiated using the "FakeIP" system, then we</para>
		/// <para> we can get an IP address for the remote host.  If the remote host had</para>
		/// <para> a global FakeIP at the time the connection was established, this</para>
		/// <para> function will return that global IP.  Otherwise, a FakeIP that is</para>
		/// <para> unique locally will be allocated from the local FakeIP address space,</para>
		/// <para> and that will be returned.</para>
		/// <para> The allocation of local FakeIPs attempts to assign addresses in</para>
		/// <para> a consistent manner.  If multiple connections are made to the</para>
		/// <para> same remote host, they *probably* will return the same FakeIP.</para>
		/// <para> However, since the namespace is limited, this cannot be guaranteed.</para>
		/// <para> On failure, returns:</para>
		/// <para> - k_EResultInvalidParam: invalid connection handle</para>
		/// <para> - k_EResultIPNotFound: This connection wasn't made using FakeIP system</para>
		/// <para>如果连接是通过“FakeIP”系统启动的，那么我们可以获取远程主机的IP地址。如果远程主机在连接建立时拥有全局的FakeIP，则此函数将返回该全局IP。否则，将从本地FakeIP地址空间中分配一个独特的本地FakeIP，并返回该FakeIP。</para>
		/// <para>本地假IP的分配试图以一致的方式分配地址。如果多个连接指向同一个远程主机，它们*可能*会返回相同的FakeIP。但是，由于命名空间有限，这无法保证。</para>
		/// <para>在失败时返回：- k_EResultInvalidParam：无效连接句柄 - k_EResultIPNotFound：此连接未使用 FakeIP 系统建立</para>
		/// </summary>
		public static EResult GetRemoteFakeIPForConnection(HSteamNetConnection hConn, out SteamNetworkingIPAddr pOutAddr) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_GetRemoteFakeIPForConnection(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), hConn, out pOutAddr);
		}

		/// <summary>
		/// <para> Get an interface that can be used like a UDP port to send/receive</para>
		/// <para> datagrams to a FakeIP address.  This is intended to make it easy</para>
		/// <para> to port existing UDP-based code to take advantage of SDR.</para>
		/// <para> idxFakeServerPort refers to the *index* of the port allocated using</para>
		/// <para> BeginAsyncRequestFakeIP and is used to create "server" ports.  You may</para>
		/// <para> call this before the allocation has completed.  However, any attempts</para>
		/// <para> to send packets will fail until the allocation has succeeded.  When</para>
		/// <para> the peer receives packets sent from this interface, the from address</para>
		/// <para> of the packet will be the globally-unique FakeIP.  If you call this</para>
		/// <para> function multiple times and pass the same (nonnegative) fake port index,</para>
		/// <para> the same object will be returned, and this object is not reference counted.</para>
		/// <para> To create a "client" port (e.g. the equivalent of an ephemeral UDP port)</para>
		/// <para> pass -1.  In this case, a distinct object will be returned for each call.</para>
		/// <para> When the peer receives packets sent from this interface, the peer will</para>
		/// <para> assign a FakeIP from its own locally-controlled namespace.</para>
		/// <para>获取一个可以像 UDP 端口一样使用，用于向 FakeIP 地址发送/接收数据包的接口。 这样做是为了方便现有基于 UDP 的代码利用 SDR。</para>
		/// <para>idxFakeServerPort 指的是使用 BeginAsyncRequestFakeIP 分配的 *index*，用于创建“server”端口。您可以在分配完成之前调用此函数。但是，任何尝试发送数据包的尝试都会在分配成功之前失败。当同伴接收通过此接口发送的数据包时，数据包的 *from* 地址将是全局唯一的 FakeIP。如果调用此函数多次并传递相同的（非负）虚假端口索引，则将返回相同对象，并且此对象不进行引用计数。</para>
		/// <para>为了创建一个“客户端”端口（例如，一个临时的 UDP 端口），请使用 -1。在这种情况下，每次调用都会返回一个不同的对象。当对端收到通过此接口发送的包时，对端会从其自身控制的命名空间中分配一个 FakeIP。</para>
		/// </summary>
		public static IntPtr CreateFakeUDPPort(int idxFakeServerPort) {
			InteropHelp.TestIfAvailableGameServer();
			return NativeMethods.ISteamNetworkingSockets_CreateFakeUDPPort(CSteamGameServerAPIContext.GetSteamNetworkingSockets(), idxFakeServerPort);
		}
	}
}

#endif // !DISABLESTEAMWORKS
