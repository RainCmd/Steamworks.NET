// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
	#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	public static class SteamNetworkingMessages {
		/// <summary>
		/// <para> Sends a message to the specified host.  If we don't already have a session with that user,</para>
		/// <para> a session is implicitly created.  There might be some handshaking that needs to happen</para>
		/// <para> before we can actually begin sending message data.  If this handshaking fails and we can't</para>
		/// <para> get through, an error will be posted via the callback SteamNetworkingMessagesSessionFailed_t.</para>
		/// <para> There is no notification when the operation succeeds.  (You should have the peer send a reply</para>
		/// <para> for this purpose.)</para>
		/// <para> Sending a message to a host will also implicitly accept any incoming connection from that host.</para>
		/// <para> nSendFlags is a bitmask of k_nSteamNetworkingSend_xxx options</para>
		/// <para> nRemoteChannel is a routing number you can use to help route message to different systems.</para>
		/// <para> You'll have to call ReceiveMessagesOnChannel() with the same channel number in order to retrieve</para>
		/// <para> the data on the other end.</para>
		/// <para> Using different channels to talk to the same user will still use the same underlying</para>
		/// <para> connection, saving on resources.  If you don't need this feature, use 0.</para>
		/// <para> Otherwise, small integers are the most efficient.</para>
		/// <para> It is guaranteed that reliable messages to the same host on the same channel</para>
		/// <para> will be be received by the remote host (if they are received at all) exactly once,</para>
		/// <para> and in the same order that they were sent.</para>
		/// <para> NO other order guarantees exist!  In particular, unreliable messages may be dropped,</para>
		/// <para> received out of order with respect to each other and with respect to reliable data,</para>
		/// <para> or may be received multiple times.  Messages on different channels are *not* guaranteed</para>
		/// <para> to be received in the order they were sent.</para>
		/// <para> A note for those familiar with TCP/IP ports, or converting an existing codebase that</para>
		/// <para> opened multiple sockets:  You might notice that there is only one channel, and with</para>
		/// <para> TCP/IP each endpoint has a port number.  You can think of the channel number as the</para>
		/// <para> *destination* port.  If you need each message to also include a "source port" (so the</para>
		/// <para> recipient can route the reply), then just put that in your message.  That is essentially</para>
		/// <para> how UDP works!</para>
		/// <para> Returns:</para>
		/// <para> - k_EREsultOK on success.</para>
		/// <para> - k_EResultNoConnection, if the session has failed or was closed by the peer and</para>
		/// <para>   k_nSteamNetworkingSend_AutoRestartBrokenSession was not specified.  (You can</para>
		/// <para>   use GetSessionConnectionInfo to get the details.)  In order to acknowledge the</para>
		/// <para>   broken session and start a new one, you must call CloseSessionWithUser, or you may</para>
		/// <para>   repeat the call with k_nSteamNetworkingSend_AutoRestartBrokenSession.  See</para>
		/// <para>   k_nSteamNetworkingSend_AutoRestartBrokenSession for more details.</para>
		/// <para> - See ISteamNetworkingSockets::SendMessageToConnection for more possible return values</para>
		/// <para>向指定主机发送消息。如果尚不具备与该用户的会话，则会隐式创建会话。可能需要进行一些握手才能真正开始发送消息数据。如果握手失败且无法通过，将通过回调 SteamNetworkingMessagesSessionFailed_t 报告错误。不会有任何成功通知。（你应该让同伴为此目的发送回复。）</para>
		/// <para>向主机发送消息也会隐式接受来自该主机的任何传入连接。</para>
		/// <para>nSendFlags 是一个位掩码，包含 k_nSteamNetworkingSend_xxx 选项。</para>
		/// <para>RemoteChannel 是一种路由号码，你可以用来将消息路由到不同的系统。你需要通过调用 ReceiveMessagesOnChannel() 函数，使用相同的频道号码来从另一端检索数据。</para>
		/// <para>使用不同的渠道与同一用户交流仍然会使用相同的底层连接，从而节省资源。如果不需要此功能，请使用 0。否则，较小的整数是最有效的。</para>
		/// <para>如果消息被接收的话，同一台主机同一频道内可靠的消息将被远程主机接收一次且顺序与发送顺序相同。</para>
		/// <para>其他任何订单均不作任何保证！特别是，不可靠的消息可能会丢失、与其它消息顺序错乱，包括与可靠数据，或者可能被多次接收。不同渠道的消息*不*保证按照发送顺序接收。</para>
		/// <para>对于熟悉 TCP/IP 端口或转换现有代码库（该代码库打开了多个套接字的人）：你可能会注意到只有一个通道，并且在 TCP/IP 中，每个端点都有一个端口号。你可以将通道号视为*目标*端口。如果需要每个消息都包含一个“源端口”（以便接收方可以路由回复），则只需在消息中添加它。这基本上就是 UDP 的工作方式！</para>
		/// <para>Returns: - k_EResultOK on success. - k_EResultNoConnection, if the session has failed or was closed by the peer and k_nSteamNetworkingSend_AutoRestartBrokenSession was not specified. (You can use GetSessionConnectionInfo to get the details.) In order to acknowledge the broken session and start a new one, you must call CloseSessionWithUser, or you may repeat the call with k_nSteamNetworkingSend_AutoRestartBrokenSession. See k_nSteamNetworkingSend_AutoRestartBrokenSession for more details. - See ISteamNetworkingSockets::SendMessageToConnection for more possible return values</para>
		/// </summary>
		public static EResult SendMessageToUser(ref SteamNetworkingIdentity identityRemote, IntPtr pubData, uint cubData, int nSendFlags, int nRemoteChannel) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingMessages_SendMessageToUser(CSteamAPIContext.GetSteamNetworkingMessages(), ref identityRemote, pubData, cubData, nSendFlags, nRemoteChannel);
		}

		/// <summary>
		/// <para> Reads the next message that has been sent from another user via SendMessageToUser() on the given channel.</para>
		/// <para> Returns number of messages returned into your list.  (0 if no message are available on that channel.)</para>
		/// <para> When you're done with the message object(s), make sure and call SteamNetworkingMessage_t::Release()!</para>
		/// <para>读取来自其他用户通过 SendMessageToUser() 在给定频道上发送的下一个消息。返回已返回的消息数量（如果该频道上没有可用的消息，则返回 0）。</para>
		/// <para>当你完成消息对象(s) 的使用后，务必调用 SteamNetworkingMessage_t::Release()！</para>
		/// </summary>
		public static int ReceiveMessagesOnChannel(int nLocalChannel, IntPtr[] ppOutMessages, int nMaxMessages) {
			InteropHelp.TestIfAvailableClient();
			if (ppOutMessages != null && ppOutMessages.Length != nMaxMessages) {
				throw new System.ArgumentException("ppOutMessages must be the same size as nMaxMessages!");
			}
			return NativeMethods.ISteamNetworkingMessages_ReceiveMessagesOnChannel(CSteamAPIContext.GetSteamNetworkingMessages(), nLocalChannel, ppOutMessages, nMaxMessages);
		}

		/// <summary>
		/// <para> Call this in response to a SteamNetworkingMessagesSessionRequest_t callback.</para>
		/// <para> SteamNetworkingMessagesSessionRequest_t are posted when a user tries to send you a message,</para>
		/// <para> and you haven't tried to talk to them first.  If you don't want to talk to them, just ignore</para>
		/// <para> the request.  If the user continues to send you messages, SteamNetworkingMessagesSessionRequest_t</para>
		/// <para> callbacks will continue to be posted periodically.</para>
		/// <para> Returns false if there is no session with the user pending or otherwise.  If there is an</para>
		/// <para> existing active session, this function will return true, even if it is not pending.</para>
		/// <para> Calling SendMessageToUser() will implicitly accepts any pending session request to that user.</para>
		/// <para>这是一种对 SteamNetworkingMessagesSessionRequest_t 回调的响应。SteamNetworkingMessagesSessionRequest_t 在用户尝试向你发送消息时发布，而你尚未尝试与他们交流时。如果你不想与他们交流，只需忽略请求。如果用户继续向你发送消息，SteamNetworkingMessagesSessionRequest_t 回调将定期继续发布。</para>
		/// <para>如果存在没有与用户关联的会话或其它情况，则返回false。如果存在有效的活动会话，此函数将返回true，即使该会话没有处于待定状态。</para>
		/// <para>调用 SendMessageToUser() 函数会隐式接受到该用户的任何未决会话请求。</para>
		/// </summary>
		public static bool AcceptSessionWithUser(ref SteamNetworkingIdentity identityRemote) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingMessages_AcceptSessionWithUser(CSteamAPIContext.GetSteamNetworkingMessages(), ref identityRemote);
		}

		/// <summary>
		/// <para> Call this when you're done talking to a user to immediately free up resources under-the-hood.</para>
		/// <para> If the remote user tries to send data to you again, another SteamNetworkingMessagesSessionRequest_t</para>
		/// <para> callback will be posted.</para>
		/// <para> Note that sessions that go unused for a few minutes are automatically timed out.</para>
		/// <para>当与用户结束对话时调用此方法，立即释放后台资源。如果远程用户再次尝试向您发送数据，将会发布另一个 SteamNetworkingMessagesSessionRequest_t 回调。</para>
		/// <para>注意，长时间未使用的会话会自动超时。</para>
		/// </summary>
		public static bool CloseSessionWithUser(ref SteamNetworkingIdentity identityRemote) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingMessages_CloseSessionWithUser(CSteamAPIContext.GetSteamNetworkingMessages(), ref identityRemote);
		}

		/// <summary>
		/// <para> Call this  when you're done talking to a user on a specific channel.  Once all</para>
		/// <para> open channels to a user have been closed, the open session to the user will be</para>
		/// <para> closed, and any new data from this user will trigger a</para>
		/// <para> SteamSteamNetworkingMessagesSessionRequest_t callback</para>
		/// <para>当您完成与特定频道上的用户对话时，请调用此方法。一旦所有指向用户的打开频道都关闭后，用户打开的会话将被关闭，并且来自该用户的任何新数据都将触发一个 SteamSteamNetworkingMessagesSessionRequest_t 回调。</para>
		/// </summary>
		public static bool CloseChannelWithUser(ref SteamNetworkingIdentity identityRemote, int nLocalChannel) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingMessages_CloseChannelWithUser(CSteamAPIContext.GetSteamNetworkingMessages(), ref identityRemote, nLocalChannel);
		}

		/// <summary>
		/// <para> Returns information about the latest state of a connection, if any, with the given peer.</para>
		/// <para> Primarily intended for debugging purposes, but can also be used to get more detailed</para>
		/// <para> failure information.  (See SendMessageToUser and k_nSteamNetworkingSend_AutoRestartBrokenSession.)</para>
		/// <para> Returns the value of SteamNetConnectionInfo_t::m_eState, or k_ESteamNetworkingConnectionState_None</para>
		/// <para> if no connection exists with specified peer.  You may pass nullptr for either parameter if</para>
		/// <para> you do not need the corresponding details.  Note that sessions time out after a while,</para>
		/// <para> so if a connection fails, or SendMessageToUser returns k_EResultNoConnection, you cannot wait</para>
		/// <para> indefinitely to obtain the reason for failure.</para>
		/// <para>返回指定对等方（peer）的连接的最新状态信息，如果存在的话。主要用于调试目的，也可用于获取更详细的故障信息。 (参见 SendMessageToUser 和 k_nSteamNetworkingSend_AutoRestartBrokenSession.)</para>
		/// <para>返回 SteamNetConnectionInfo_t::m_eState 的值，或在没有指定对端连接的情况下返回 k_ESteamNetworkingConnectionState_None。 如果你不需要相应详情，可以传递 nullptr 给任何一个参数。 请注意，会话会在一段时间后超时，因此如果连接失败或 SendMessageToUser 返回 k_EResultNoConnection，你不能无限期地等待以获取失败原因。</para>
		/// </summary>
		public static ESteamNetworkingConnectionState GetSessionConnectionInfo(ref SteamNetworkingIdentity identityRemote, out SteamNetConnectionInfo_t pConnectionInfo, out SteamNetConnectionRealTimeStatus_t pQuickStatus) {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamNetworkingMessages_GetSessionConnectionInfo(CSteamAPIContext.GetSteamNetworkingMessages(), ref identityRemote, out pConnectionInfo, out pQuickStatus);
		}
	}
}

#endif // !DISABLESTEAMWORKS
