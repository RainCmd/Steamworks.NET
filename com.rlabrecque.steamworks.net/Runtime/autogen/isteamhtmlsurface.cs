// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
	#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	public static class SteamHTMLSurface {
		/// <summary>
		/// <para> Must call init and shutdown when starting/ending use of the interface</para>
		/// <para>必须在启动/结束使用接口时调用 init 和 shutdown。</para>
		/// </summary>
		public static bool Init() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTMLSurface_Init(CSteamAPIContext.GetSteamHTMLSurface());
		}

		public static bool Shutdown() {
			InteropHelp.TestIfAvailableClient();
			return NativeMethods.ISteamHTMLSurface_Shutdown(CSteamAPIContext.GetSteamHTMLSurface());
		}

		/// <summary>
		/// <para> Create a browser object for display of a html page, when creation is complete the call handle</para>
		/// <para> will return a HTML_BrowserReady_t callback for the HHTMLBrowser of your new browser.</para>
		/// <para>   The user agent string is a substring to be added to the general user agent string so you can</para>
		/// <para> identify your client on web servers.</para>
		/// <para>   The userCSS string lets you apply a CSS style sheet to every displayed page, leave null if</para>
		/// <para> you do not require this functionality.</para>
		/// <para> YOU MUST HAVE IMPLEMENTED HANDLERS FOR HTML_BrowserReady_t, HTML_StartRequest_t,</para>
		/// <para> HTML_JSAlert_t, HTML_JSConfirm_t, and HTML_FileOpenDialog_t! See the CALLBACKS</para>
		/// <para> section of this interface (AllowStartRequest, etc) for more details. If you do</para>
		/// <para> not implement these callback handlers, the browser may appear to hang instead of</para>
		/// <para> navigating to new pages or triggering javascript popups.</para>
		/// <para>创建一个浏览器对象，用于显示 HTML 页面。创建完成后，`handle` 将返回一个 `HTML_BrowserReady_t` 回调函数，用于你的新浏览器中的 `HHTMLBrowser`。用户代理字符串是一个子字符串，用于添加到通用的用户代理字符串中，以便在 Web 服务器上识别你的客户端。用户CSS 字符串允许你将 CSS 样式表应用于每个显示的页面，如果不需要此功能，则留空。</para>
		/// <para>你必须实现 HANDLERS FOR HTML_BrowserReady_t, HTML_StartRequest_t, HTML_JSAlert_t, HTML_JSConfirm_t, 和 HTML_FileOpenDialog_t！ 参见 INTERFACE 的 CALLBACKS 部分（AllowStartRequest 等）以获取更多详细信息。 如果你不实现这些回调处理程序，浏览器可能会卡住，而不是导航到新页面或触发 JavaScript 弹出窗口。</para>
		/// </summary>
		public static SteamAPICall_t CreateBrowser(string pchUserAgent, string pchUserCSS) {
			InteropHelp.TestIfAvailableClient();
			using (var pchUserAgent2 = new InteropHelp.UTF8StringHandle(pchUserAgent))
			using (var pchUserCSS2 = new InteropHelp.UTF8StringHandle(pchUserCSS)) {
				return (SteamAPICall_t)NativeMethods.ISteamHTMLSurface_CreateBrowser(CSteamAPIContext.GetSteamHTMLSurface(), pchUserAgent2, pchUserCSS2);
			}
		}

		/// <summary>
		/// <para> Call this when you are done with a html surface, this lets us free the resources being used by it</para>
		/// <para>请调用此方法在完成对 HTML 表面处理后，这能释放该表面所使用的资源。</para>
		/// </summary>
		public static void RemoveBrowser(HHTMLBrowser unBrowserHandle) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_RemoveBrowser(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle);
		}

		/// <summary>
		/// <para> Navigate to this URL, results in a HTML_StartRequest_t as the request commences</para>
		/// <para>导航到此 URL，结果生成一个 HTML_StartRequest_t 作为请求开始。</para>
		/// </summary>
		public static void LoadURL(HHTMLBrowser unBrowserHandle, string pchURL, string pchPostData) {
			InteropHelp.TestIfAvailableClient();
			using (var pchURL2 = new InteropHelp.UTF8StringHandle(pchURL))
			using (var pchPostData2 = new InteropHelp.UTF8StringHandle(pchPostData)) {
				NativeMethods.ISteamHTMLSurface_LoadURL(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, pchURL2, pchPostData2);
			}
		}

		/// <summary>
		/// <para> Tells the surface the size in pixels to display the surface</para>
		/// <para>告知表面以像素显示表面的尺寸。</para>
		/// </summary>
		public static void SetSize(HHTMLBrowser unBrowserHandle, uint unWidth, uint unHeight) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_SetSize(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, unWidth, unHeight);
		}

		/// <summary>
		/// <para> Stop the load of the current html page</para>
		/// <para>停止当前 HTML 页面的加载。</para>
		/// </summary>
		public static void StopLoad(HHTMLBrowser unBrowserHandle) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_StopLoad(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle);
		}

		/// <summary>
		/// <para> Reload (most likely from local cache) the current page</para>
		/// <para>重新加载（最可能来自本地缓存）当前页面</para>
		/// </summary>
		public static void Reload(HHTMLBrowser unBrowserHandle) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_Reload(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle);
		}

		/// <summary>
		/// <para> navigate back in the page history</para>
		/// <para>返回页面历史</para>
		/// </summary>
		public static void GoBack(HHTMLBrowser unBrowserHandle) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_GoBack(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle);
		}

		/// <summary>
		/// <para> navigate forward in the page history</para>
		/// <para>前进浏览页面历史</para>
		/// </summary>
		public static void GoForward(HHTMLBrowser unBrowserHandle) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_GoForward(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle);
		}

		/// <summary>
		/// <para> add this header to any url requests from this browser</para>
		/// <para>请提供需要添加的header信息。</para>
		/// </summary>
		public static void AddHeader(HHTMLBrowser unBrowserHandle, string pchKey, string pchValue) {
			InteropHelp.TestIfAvailableClient();
			using (var pchKey2 = new InteropHelp.UTF8StringHandle(pchKey))
			using (var pchValue2 = new InteropHelp.UTF8StringHandle(pchValue)) {
				NativeMethods.ISteamHTMLSurface_AddHeader(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, pchKey2, pchValue2);
			}
		}

		/// <summary>
		/// <para> run this javascript script in the currently loaded page</para>
		/// <para>运行当前页面中的 JavaScript 脚本。</para>
		/// </summary>
		public static void ExecuteJavascript(HHTMLBrowser unBrowserHandle, string pchScript) {
			InteropHelp.TestIfAvailableClient();
			using (var pchScript2 = new InteropHelp.UTF8StringHandle(pchScript)) {
				NativeMethods.ISteamHTMLSurface_ExecuteJavascript(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, pchScript2);
			}
		}

		/// <summary>
		/// <para> Mouse click and mouse movement commands</para>
		/// <para>鼠标点击和鼠标移动命令</para>
		/// </summary>
		public static void MouseUp(HHTMLBrowser unBrowserHandle, EHTMLMouseButton eMouseButton) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_MouseUp(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, eMouseButton);
		}

		public static void MouseDown(HHTMLBrowser unBrowserHandle, EHTMLMouseButton eMouseButton) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_MouseDown(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, eMouseButton);
		}

		public static void MouseDoubleClick(HHTMLBrowser unBrowserHandle, EHTMLMouseButton eMouseButton) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_MouseDoubleClick(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, eMouseButton);
		}

		/// <summary>
		/// <para> x and y are relative to the HTML bounds</para>
		/// <para>x 和 y 是相对于 HTML 界面的。</para>
		/// </summary>
		public static void MouseMove(HHTMLBrowser unBrowserHandle, int x, int y) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_MouseMove(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, x, y);
		}

		/// <summary>
		/// <para> nDelta is pixels of scroll</para>
		/// <para>nDelta 是滚动像素</para>
		/// </summary>
		public static void MouseWheel(HHTMLBrowser unBrowserHandle, int nDelta) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_MouseWheel(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, nDelta);
		}

		/// <summary>
		/// <para> keyboard interactions, native keycode is the virtual key code value from your OS, system key flags the key to not</para>
		/// <para> be sent as a typed character as well as a key down</para>
		/// <para>键盘交互，原生键码是您操作系统中的虚拟键码值，系统键码用于标记键不作为按键字符发送，同时还标记键按下事件。</para>
		/// </summary>
		public static void KeyDown(HHTMLBrowser unBrowserHandle, uint nNativeKeyCode, EHTMLKeyModifiers eHTMLKeyModifiers, bool bIsSystemKey = false) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_KeyDown(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, nNativeKeyCode, eHTMLKeyModifiers, bIsSystemKey);
		}

		public static void KeyUp(HHTMLBrowser unBrowserHandle, uint nNativeKeyCode, EHTMLKeyModifiers eHTMLKeyModifiers) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_KeyUp(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, nNativeKeyCode, eHTMLKeyModifiers);
		}

		/// <summary>
		/// <para> cUnicodeChar is the unicode character point for this keypress (and potentially multiple chars per press)</para>
		/// <para>cUnicodeChar is the Unicode character point for this keypress (and potentially multiple chars per press)</para>
		/// </summary>
		public static void KeyChar(HHTMLBrowser unBrowserHandle, uint cUnicodeChar, EHTMLKeyModifiers eHTMLKeyModifiers) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_KeyChar(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, cUnicodeChar, eHTMLKeyModifiers);
		}

		/// <summary>
		/// <para> programmatically scroll this many pixels on the page</para>
		/// <para>程序性地滚动该数量的像素到页面上。</para>
		/// </summary>
		public static void SetHorizontalScroll(HHTMLBrowser unBrowserHandle, uint nAbsolutePixelScroll) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_SetHorizontalScroll(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, nAbsolutePixelScroll);
		}

		public static void SetVerticalScroll(HHTMLBrowser unBrowserHandle, uint nAbsolutePixelScroll) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_SetVerticalScroll(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, nAbsolutePixelScroll);
		}

		/// <summary>
		/// <para> tell the html control if it has key focus currently, controls showing the I-beam cursor in text controls amongst other things</para>
		/// <para>```html <input type="text" onfocus={() => {   // Add your logic here to handle focus events   console.log("Input control has focus"); }} /> ```</para>
		/// </summary>
		public static void SetKeyFocus(HHTMLBrowser unBrowserHandle, bool bHasKeyFocus) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_SetKeyFocus(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, bHasKeyFocus);
		}

		/// <summary>
		/// <para> open the current pages html code in the local editor of choice, used for debugging</para>
		/// <para>打开当前页面的 HTML 代码在您选择的本地编辑器中，用于调试。</para>
		/// </summary>
		public static void ViewSource(HHTMLBrowser unBrowserHandle) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_ViewSource(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle);
		}

		/// <summary>
		/// <para> copy the currently selected text on the html page to the local clipboard</para>
		/// <para>复制当前选中文本到本地剪贴板</para>
		/// </summary>
		public static void CopyToClipboard(HHTMLBrowser unBrowserHandle) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_CopyToClipboard(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle);
		}

		/// <summary>
		/// <para> paste from the local clipboard to the current html page</para>
		/// <para>复制从本地剪贴板到当前 HTML 页面</para>
		/// </summary>
		public static void PasteFromClipboard(HHTMLBrowser unBrowserHandle) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_PasteFromClipboard(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle);
		}

		/// <summary>
		/// <para> find this string in the browser, if bCurrentlyInFind is true then instead cycle to the next matching element</para>
		/// <para>查找该字符串在浏览器中，如果 bCurrentlyInFind 为 true 则循环到下一个匹配元素</para>
		/// </summary>
		public static void Find(HHTMLBrowser unBrowserHandle, string pchSearchStr, bool bCurrentlyInFind, bool bReverse) {
			InteropHelp.TestIfAvailableClient();
			using (var pchSearchStr2 = new InteropHelp.UTF8StringHandle(pchSearchStr)) {
				NativeMethods.ISteamHTMLSurface_Find(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, pchSearchStr2, bCurrentlyInFind, bReverse);
			}
		}

		/// <summary>
		/// <para> cancel a currently running find</para>
		/// <para>取消当前正在进行的find</para>
		/// </summary>
		public static void StopFind(HHTMLBrowser unBrowserHandle) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_StopFind(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle);
		}

		/// <summary>
		/// <para> return details about the link at position x,y on the current page</para>
		/// <para>返回当前页面上位置 x, y 的链接的详细信息。</para>
		/// </summary>
		public static void GetLinkAtPosition(HHTMLBrowser unBrowserHandle, int x, int y) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_GetLinkAtPosition(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, x, y);
		}

		/// <summary>
		/// <para> set a webcookie for the hostname in question</para>
		/// <para>设置一个网站Cookie，用于指定该主机名。</para>
		/// </summary>
		public static void SetCookie(string pchHostname, string pchKey, string pchValue, string pchPath = "/", uint nExpires = 0, bool bSecure = false, bool bHTTPOnly = false) {
			InteropHelp.TestIfAvailableClient();
			using (var pchHostname2 = new InteropHelp.UTF8StringHandle(pchHostname))
			using (var pchKey2 = new InteropHelp.UTF8StringHandle(pchKey))
			using (var pchValue2 = new InteropHelp.UTF8StringHandle(pchValue))
			using (var pchPath2 = new InteropHelp.UTF8StringHandle(pchPath)) {
				NativeMethods.ISteamHTMLSurface_SetCookie(CSteamAPIContext.GetSteamHTMLSurface(), pchHostname2, pchKey2, pchValue2, pchPath2, nExpires, bSecure, bHTTPOnly);
			}
		}

		/// <summary>
		/// <para> Zoom the current page by flZoom ( from 0.0 to 2.0, so to zoom to 120% use 1.2 ), zooming around point X,Y in the page (use 0,0 if you don't care)</para>
		/// <para>放大当前页面，使用 flZoom (从 0.0 到 2.0 缩放，使用 1.2 达到 120% 缩放)，围绕点 X,Y 缩放 (使用 0,0 如果不关心)</para>
		/// </summary>
		public static void SetPageScaleFactor(HHTMLBrowser unBrowserHandle, float flZoom, int nPointX, int nPointY) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_SetPageScaleFactor(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, flZoom, nPointX, nPointY);
		}

		/// <summary>
		/// <para> Enable/disable low-resource background mode, where javascript and repaint timers are throttled, resources are</para>
		/// <para> more aggressively purged from memory, and audio/video elements are paused. When background mode is enabled,</para>
		/// <para> all HTML5 video and audio objects will execute ".pause()" and gain the property "._steam_background_paused = 1".</para>
		/// <para> When background mode is disabled, any video or audio objects with that property will resume with ".play()".</para>
		/// <para>启用/禁用低资源背景模式，其中 JavaScript 和回车定时器会受到限制，内存会更积极地从缓存中清除，音频/视频元素会被暂停。当背景模式启用时，所有 HTML5 视频和音频对象都会执行 ".pause()" 并获得 "_steam_background_paused = 1" 属性。当背景模式禁用时，具有该属性的任何视频或音频对象都会恢复执行 ".play()"。</para>
		/// </summary>
		public static void SetBackgroundMode(HHTMLBrowser unBrowserHandle, bool bBackgroundMode) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_SetBackgroundMode(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, bBackgroundMode);
		}

		/// <summary>
		/// <para> Scale the output display space by this factor, this is useful when displaying content on high dpi devices.</para>
		/// <para> Specifies the ratio between physical and logical pixels.</para>
		/// <para>调整输出显示空间，按此比例进行缩放，这在显示高 DPI 设备上的内容时非常有用。指定物理像素与逻辑像素之间的比率。</para>
		/// </summary>
		public static void SetDPIScalingFactor(HHTMLBrowser unBrowserHandle, float flDPIScaling) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_SetDPIScalingFactor(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, flDPIScaling);
		}

		/// <summary>
		/// <para> Open HTML/JS developer tools</para>
		/// <para>打开 HTML/JS 开发者工具</para>
		/// </summary>
		public static void OpenDeveloperTools(HHTMLBrowser unBrowserHandle) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_OpenDeveloperTools(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle);
		}

		/// <summary>
		/// <para> CALLBACKS</para>
		/// <para>  These set of functions are used as responses to callback requests</para>
		/// <para> You MUST call this in response to a HTML_StartRequest_t callback</para>
		/// <para>  Set bAllowed to true to allow this navigation, false to cancel it and stay</para>
		/// <para> on the current page. You can use this feature to limit the valid pages</para>
		/// <para> allowed in your HTML surface.</para>
		/// <para>回调函数</para>
		/// <para>这些函数组被用作回调请求的响应。</para>
		/// <para>您必须通过调用 HTML_StartRequest_t 回调函数时，将 bAllowed 设置为 true 以允许此导航，false 以取消它并停留在当前页面。您可以使用此功能来限制允许的有效页面在您的 HTML 表面中。</para>
		/// </summary>
		public static void AllowStartRequest(HHTMLBrowser unBrowserHandle, bool bAllowed) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_AllowStartRequest(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, bAllowed);
		}

		/// <summary>
		/// <para> You MUST call this in response to a HTML_JSAlert_t or HTML_JSConfirm_t callback</para>
		/// <para>  Set bResult to true for the OK option of a confirm, use false otherwise</para>
		/// <para>必须在对 confirm 确认对话框的 OK 选项使用时，将 bResult 设置为 true，否则设置为 false。</para>
		/// </summary>
		public static void JSDialogResponse(HHTMLBrowser unBrowserHandle, bool bResult) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_JSDialogResponse(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, bResult);
		}

		/// <summary>
		/// <para> You MUST call this in response to a HTML_FileOpenDialog_t callback</para>
		/// <para>您必须响应此回调。</para>
		/// </summary>
		public static void FileLoadDialogResponse(HHTMLBrowser unBrowserHandle, IntPtr pchSelectedFiles) {
			InteropHelp.TestIfAvailableClient();
			NativeMethods.ISteamHTMLSurface_FileLoadDialogResponse(CSteamAPIContext.GetSteamHTMLSurface(), unBrowserHandle, pchSelectedFiles);
		}
	}
}

#endif // !DISABLESTEAMWORKS
