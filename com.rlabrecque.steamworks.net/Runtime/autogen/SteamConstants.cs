// This file is provided under The MIT License as part of Steamworks.NET.
// Copyright (c) 2013-2022 Riley Labrecque
// Please see the included LICENSE.txt for additional information.

// This file is automatically generated.
// Changes to this file will be reverted when you update Steamworks.NET

#if !(UNITY_STANDALONE_WIN || UNITY_STANDALONE_LINUX || UNITY_STANDALONE_OSX || STEAMWORKS_WIN || STEAMWORKS_LIN_OSX)
	#define DISABLESTEAMWORKS
#endif

#if !DISABLESTEAMWORKS

using System.Runtime.InteropServices;
using IntPtr = System.IntPtr;

namespace Steamworks {
	public static class Constants {
		public const string STEAMAPPS_INTERFACE_VERSION = "STEAMAPPS_INTERFACE_VERSION008";
		public const string STEAMAPPTICKET_INTERFACE_VERSION = "STEAMAPPTICKET_INTERFACE_VERSION001";
		public const string STEAMCLIENT_INTERFACE_VERSION = "SteamClient021";
		public const string STEAMFRIENDS_INTERFACE_VERSION = "SteamFriends017";
		public const string STEAMGAMECOORDINATOR_INTERFACE_VERSION = "SteamGameCoordinator001";
		public const string STEAMGAMESERVER_INTERFACE_VERSION = "SteamGameServer015";
		public const string STEAMGAMESERVERSTATS_INTERFACE_VERSION = "SteamGameServerStats001";
		public const string STEAMHTMLSURFACE_INTERFACE_VERSION = "STEAMHTMLSURFACE_INTERFACE_VERSION_005";
		public const string STEAMHTTP_INTERFACE_VERSION = "STEAMHTTP_INTERFACE_VERSION003";
		public const string STEAMINPUT_INTERFACE_VERSION = "SteamInput006";
		public const string STEAMINVENTORY_INTERFACE_VERSION = "STEAMINVENTORY_INTERFACE_V003";
		public const string STEAMMATCHMAKING_INTERFACE_VERSION = "SteamMatchMaking009";
		public const string STEAMMATCHMAKINGSERVERS_INTERFACE_VERSION = "SteamMatchMakingServers002";
		public const string STEAMGAMESEARCH_INTERFACE_VERSION = "SteamMatchGameSearch001";
		public const string STEAMPARTIES_INTERFACE_VERSION = "SteamParties002";
		public const string STEAMMUSIC_INTERFACE_VERSION = "STEAMMUSIC_INTERFACE_VERSION001";
		public const string STEAMMUSICREMOTE_INTERFACE_VERSION = "STEAMMUSICREMOTE_INTERFACE_VERSION001";
		public const string STEAMNETWORKING_INTERFACE_VERSION = "SteamNetworking006";
		public const string STEAMNETWORKINGMESSAGES_INTERFACE_VERSION = "SteamNetworkingMessages002";
		// Silence some warnings
		// 关闭一些警告
		public const string STEAMNETWORKINGSOCKETS_INTERFACE_VERSION = "SteamNetworkingSockets012";
		// Silence some warnings
		// 关闭一些警告
		public const string STEAMNETWORKINGUTILS_INTERFACE_VERSION = "SteamNetworkingUtils004";
		public const string STEAMPARENTALSETTINGS_INTERFACE_VERSION = "STEAMPARENTALSETTINGS_INTERFACE_VERSION001";
		public const string STEAMREMOTEPLAY_INTERFACE_VERSION = "STEAMREMOTEPLAY_INTERFACE_VERSION002";
		public const string STEAMREMOTESTORAGE_INTERFACE_VERSION = "STEAMREMOTESTORAGE_INTERFACE_VERSION016";
		public const string STEAMSCREENSHOTS_INTERFACE_VERSION = "STEAMSCREENSHOTS_INTERFACE_VERSION003";
		public const string STEAMTIMELINE_INTERFACE_VERSION = "STEAMTIMELINE_INTERFACE_V004";
		public const string STEAMUGC_INTERFACE_VERSION = "STEAMUGC_INTERFACE_VERSION020";
		public const string STEAMUSER_INTERFACE_VERSION = "SteamUser023";
		public const string STEAMUSERSTATS_INTERFACE_VERSION = "STEAMUSERSTATS_INTERFACE_VERSION013";
		public const string STEAMUTILS_INTERFACE_VERSION = "SteamUtils010";
		public const string STEAMVIDEO_INTERFACE_VERSION = "STEAMVIDEO_INTERFACE_V007";
		public const int k_cubAppProofOfPurchaseKeyMax = 240; // max supported length of a legacy cd key 旧式 CD 密钥的最大支持长度
		// maximum length of friend group name (not including terminating nul!)
		// 好友组名称的最大长度（不包括终止零字符！）
		public const int k_cchMaxFriendsGroupName = 64;
		// maximum number of groups a single user is allowed
		// 单个用户允许的最大组数
		public const int k_cFriendsGroupLimit = 100;
		public const int k_cEnumerateFollowersMax = 50;
		// special values for FriendGameInfo_t::m_usQueryPort
		// FriendGameInfo_t::m_usQueryPort 的特殊值
		public const ushort k_usFriendGameInfoQueryPort_NotInitialized = 0xFFFF; // We haven't asked the GS for this query port's actual value yet.  Was #define QUERY_PORT_NOT_INITIALIZED in older versions of Steamworks SDK. 我们尚未为此查询端口的实际值向GS请求。 以前的Steamworks SDK版本中是否定义了#define QUERY_PORT_NOT_INITIALIZED？
		public const ushort k_usFriendGameInfoQueryPort_Error = 0xFFFE; // We were unable to get the query port for this server.  Was #define QUERY_PORT_ERROR in older versions of Steamworks SDK. 我们无法获取此服务器的查询端口。 以前的 Steamworks SDK 版本中定义了 #define QUERY_PORT_ERROR。
		// maximum number of characters in a user's name. Two flavors; one for UTF-8 and one for UTF-16.
		// The UTF-8 version has to be very generous to accomodate characters that get large when encoded
		// in UTF-8.
		// 用户姓名中字符的最大数量。有两款版本：一种用于 UTF-8，另一种用于 UTF-16。UTF-8 版本必须非常宽泛，以容纳在 UTF-8 中编码时会变得很大的字符。
		public const int k_cchPersonaNameMax = 128;
		public const int k_cwchPersonaNameMax = 32;
		// size limit on chat room or member metadata
		// 聊天室或成员元数据大小限制
		public const int k_cubChatMetadataMax = 8192;
		// size limits on Rich Presence data
		// 富人存在数据大小限制
		public const int k_cchMaxRichPresenceKeys = 30;
		public const int k_cchMaxRichPresenceKeyLength = 64;
		public const int k_cchMaxRichPresenceValueLength = 256;
		// game server flags
		// 游戏服务器标志
		public const int k_unFavoriteFlagNone = 0x00;
		public const int k_unFavoriteFlagFavorite = 0x01; // this game favorite entry is for the favorites list 这个游戏是添加到收藏列表中的一个作品。
		public const int k_unFavoriteFlagHistory = 0x02; // this game favorite entry is for the history list 这款游戏是历史列表中的最爱。
		//-----------------------------------------------------------------------------
		// Purpose: Defines the largest allowed file size. Cloud files cannot be written
		// in a single chunk over 100MB (and cannot be over 200MB total.)
		//-----------------------------------------------------------------------------
		// 目的：定义允许的最大文件大小。云文件不能以单个大于100MB的块写入（且总大小不能超过200MB）。
		public const int k_unMaxCloudFileChunkSize = 100 * 1024 * 1024;
		public const int k_cchPublishedDocumentTitleMax = 128 + 1;
		public const int k_cchPublishedDocumentDescriptionMax = 8000;
		public const int k_cchPublishedDocumentChangeDescriptionMax = 8000;
		public const int k_unEnumeratePublishedFilesMaxResults = 50;
		public const int k_cchTagListMax = 1024 + 1;
		public const int k_cchFilenameMax = 260;
		public const int k_cchPublishedFileURLMax = 256;
		public const int k_nScreenshotMaxTaggedUsers = 32;
		public const int k_nScreenshotMaxTaggedPublishedFiles = 32;
		public const int k_cubUFSTagTypeMax = 255;
		public const int k_cubUFSTagValueMax = 255;
		// Required with of a thumbnail provided to AddScreenshotToLibrary.  If you do not provide a thumbnail
		// one will be generated.
		// 需要提供缩略图的范围，请提供到 AddScreenshotToLibrary。如果未提供缩略图，将自动生成一个。
		public const int k_ScreenshotThumbWidth = 200;
		public const int k_unMaxTimelinePriority = 1000;
		public const int k_unTimelinePriority_KeepCurrentValue = 1000000; // Use with UpdateRangeTimelineEvent to not change the priority 使用 UpdateRangeTimelineEvent 以不更改优先级的方式。
		public const float k_flMaxTimelineEventDuration = 600.0f;
		public const int k_cchMaxPhaseIDLength = 64;
		public const int kNumUGCResultsPerPage = 50;
		public const int k_cchDeveloperMetadataMax = 5000;
		public const int k_nCubTicketMaxLength = 2560;
		// size limit on stat or achievement name (UTF-8 encoded)
		// 状态或成就名称大小限制（UTF-8 编码）
		public const int k_cchStatNameMax = 128;
		// maximum number of bytes for a leaderboard name (UTF-8 encoded)
		// 排行榜名称的最大字节数（UTF-8 编码）
		public const int k_cchLeaderboardNameMax = 128;
		// maximum number of details int32's storable for a single leaderboard entry
		// 一个排行榜条目可存储的最大 int32 细节数量
		public const int k_cLeaderboardDetailsMax = 64;
		//
		// Max size (in bytes of UTF-8 data, not in characters) of server fields, including null terminator.
		// WARNING: These cannot be changed easily, without breaking clients using old interfaces.
		//
		// 服务器字段的最大大小（以 UTF-8 数据的字节为单位，而不是字符数），包括空终止符。警告：更改这些值比较困难，否则会破坏使用旧接口的客户端。
		public const int k_cbMaxGameServerGameDir = 32;
		public const int k_cbMaxGameServerMapName = 32;
		public const int k_cbMaxGameServerGameDescription = 64;
		public const int k_cbMaxGameServerName = 64;
		public const int k_cbMaxGameServerTags = 128;
		public const int k_cbMaxGameServerGameData = 2048;
		// A fixed size buffer to receive an error message that is returned by some API
		// calls.
		// 一个固定大小的缓冲区，用于接收由某些API调用返回的错误消息。
		public const int k_cchMaxSteamErrMsg = 1024;
		// Forward declare types
		//-----------------------------------------------------------------------------
		// Purpose: Base values for callback identifiers, each callback must
		//			have a unique ID.
		//-----------------------------------------------------------------------------
		// 前置声明类型
		// 目的：回调标识符的基础值，每个回调都必须具有唯一的ID。
		public const int k_iSteamUserCallbacks = 100;
		public const int k_iSteamGameServerCallbacks = 200;
		public const int k_iSteamFriendsCallbacks = 300;
		public const int k_iSteamBillingCallbacks = 400;
		public const int k_iSteamMatchmakingCallbacks = 500;
		public const int k_iSteamContentServerCallbacks = 600;
		public const int k_iSteamUtilsCallbacks = 700;
		public const int k_iSteamAppsCallbacks = 1000;
		public const int k_iSteamUserStatsCallbacks = 1100;
		public const int k_iSteamNetworkingCallbacks = 1200;
		public const int k_iSteamNetworkingSocketsCallbacks = 1220;
		public const int k_iSteamNetworkingMessagesCallbacks = 1250;
		public const int k_iSteamNetworkingUtilsCallbacks = 1280;
		public const int k_iSteamRemoteStorageCallbacks = 1300;
		public const int k_iSteamGameServerItemsCallbacks = 1500;
		public const int k_iSteamGameCoordinatorCallbacks = 1700;
		public const int k_iSteamGameServerStatsCallbacks = 1800;
		public const int k_iSteam2AsyncCallbacks = 1900;
		public const int k_iSteamGameStatsCallbacks = 2000;
		public const int k_iSteamHTTPCallbacks = 2100;
		public const int k_iSteamScreenshotsCallbacks = 2300;
		// NOTE: 2500-2599 are reserved
		// 注意：2500-2599 已保留。
		public const int k_iSteamStreamLauncherCallbacks = 2600;
		public const int k_iSteamControllerCallbacks = 2800;
		public const int k_iSteamUGCCallbacks = 3400;
		public const int k_iSteamStreamClientCallbacks = 3500;
		public const int k_iSteamMusicCallbacks = 4000;
		public const int k_iSteamMusicRemoteCallbacks = 4100;
		public const int k_iSteamGameNotificationCallbacks = 4400;
		public const int k_iSteamHTMLSurfaceCallbacks = 4500;
		public const int k_iSteamVideoCallbacks = 4600;
		public const int k_iSteamInventoryCallbacks = 4700;
		public const int k_ISteamParentalSettingsCallbacks = 5000;
		public const int k_iSteamGameSearchCallbacks = 5200;
		public const int k_iSteamPartiesCallbacks = 5300;
		public const int k_iSteamSTARCallbacks = 5500;
		public const int k_iSteamRemotePlayCallbacks = 5700;
		public const int k_iSteamChatCallbacks = 5900;
		public const int k_iSteamTimelineCallbacks = 6000;
		// Pass to SteamGameServer_Init to indicate that the same UDP port will be used for game traffic
		// UDP queries for server browser pings and LAN discovery.  In this case, Steam will not open up a
		// socket to handle server browser queries, and you must use ISteamGameServer::HandleIncomingPacket
		// and ISteamGameServer::GetNextOutgoingPacket to handle packets related to server discovery on your socket.
		// 将 `Pass to SteamGameServer_Init` 指示使用相同的 UDP 端口将用于游戏流量 UDP 查询，包括服务器浏览器 ping 和 LAN 发现。在这种情况下，Steam 不会打开套接字来处理服务器浏览器查询，您必须使用 `ISteamGameServer::HandleIncomingPacket` 和 `ISteamGameServer::GetNextOutgoingPacket` 来处理与服务器发现相关的套接字上的数据包。
		public const ushort STEAMGAMESERVER_QUERY_PORT_SHARED = 0xffff;
		public const int k_unSteamAccountIDMask = -1;
		public const int k_unSteamAccountInstanceMask = 0x000FFFFF;
		public const int k_unSteamUserDefaultInstance = 1; // fixed instance for all individual users 为所有独立用户固定实例
		public const int k_cchGameExtraInfoMax = 64;
		public const int k_nSteamEncryptedAppTicketSymmetricKeyLen = 32;
		// Port number(s) assigned to us.  Only the first entries will contain
		// nonzero values.  Entries corresponding to ports beyond what was
		// allocated for you will be zero.
		//
		// (NOTE: At the time of this writing, the maximum number of ports you may
		// request is 4.)
		// 分配给我们的端口号（们）。只有第一个条目包含非零值。对应于您分配的端口数超过的条目将为零。
		// （请注意：在撰写本文时，您可以请求的最大端口数量为4。）
		public const int k_nMaxReturnPorts = 8;
		// Max length of diagnostic error message
		// 诊断错误消息的最大长度
		public const int k_cchMaxSteamNetworkingErrMsg = 1024;
		// Max length, in bytes (including null terminator) of the reason string
		// when a connection is closed.
		// 最大长度，以字节为单位（包括空终止符），当连接关闭时，原因字符串的长度。
		public const int k_cchSteamNetworkingMaxConnectionCloseReason = 128;
		// Max length, in bytes (include null terminator) of debug description
		// of a connection.
		// 调试描述的连接的最大长度，以字节为单位（包括空终止符）。
		public const int k_cchSteamNetworkingMaxConnectionDescription = 128;
		// Max length of the app's part of the description
		// 应用部分描述的最大长度
		public const int k_cchSteamNetworkingMaxConnectionAppName = 32;
		public const int k_nSteamNetworkConnectionInfoFlags_Unauthenticated = 1; // We don't have a certificate for the remote host. 我们没有为远程主机颁发证书。
		public const int k_nSteamNetworkConnectionInfoFlags_Unencrypted = 2; // Information is being sent out over a wire unencrypted (by this library) 数据正在通过一根未加密的电线发送（由该库执行）。
		public const int k_nSteamNetworkConnectionInfoFlags_LoopbackBuffers = 4; // Internal loopback buffers.  Won't be true for localhost.  (You can check the address to determine that.)  This implies k_nSteamNetworkConnectionInfoFlags_FastLAN 内部循环缓冲。对于 localhost 将不适用。（你可以检查地址以确定这一点。）这暗示了 k_nSteamNetworkConnectionInfoFlags_FastLAN
		public const int k_nSteamNetworkConnectionInfoFlags_Fast = 8; // The connection is "fast" and "reliable".  Either internal/localhost (check the address to find out), or the peer is on the same LAN.  (Probably.  It's based on the address and the ping time, this is actually hard to determine unambiguously). 连接是“快速”和“可靠”的。 可能是内部/localhost（请查看地址以确定），或者同LAN上的同伴。（大概吧。它基于地址和ping时间，实际上很难明确判断）。
		public const int k_nSteamNetworkConnectionInfoFlags_Relayed = 16; // The connection is relayed somehow (SDR or TURN). 连接以某种方式进行中继（SDR或TURN）。
		public const int k_nSteamNetworkConnectionInfoFlags_DualWifi = 32; // We're taking advantage of dual-wifi multi-path 我们正在利用双WiFi多路径。
		//
		// Network messages
		//
		// Max size of a single message that we can SEND.
		// Note: We might be wiling to receive larger messages,
		// and our peer might, too.
		// 网络消息
		// 单条可以发送的消息最大大小。请注意：我们可能愿意接收更大的消息，我们的同伴也可能愿意。
		public const int k_cbMaxSteamNetworkingSocketsMessageSizeSend = 512 * 1024;
		//
		// Flags used to set options for message sending
		//
		// Send the message unreliably. Can be lost.  Messages *can* be larger than a
		// single MTU (UDP packet), but there is no retransmission, so if any piece
		// of the message is lost, the entire message will be dropped.
		//
		// The sending API does have some knowledge of the underlying connection, so
		// if there is no NAT-traversal accomplished or there is a recognized adjustment
		// happening on the connection, the packet will be batched until the connection
		// is open again.
		//
		// Migration note: This is not exactly the same as k_EP2PSendUnreliable!  You
		// probably want k_ESteamNetworkingSendType_UnreliableNoNagle
		// 用于设置消息发送选项的标志
		// 发送消息不可靠。可能丢失。消息*可以*大于单个MTU（UDP数据包），但没有重传，因此如果任何部分的消息丢失，整个消息将被丢弃。
		// 发送API确实对底层连接有一定的了解，如果未完成NAT穿透或连接上发生了已识别的调整，则该包将被批量处理，直到连接重新打开。
		// 迁移说明：这与 k_EP2PSendUnreliable 不完全相同！你可能想要 k_ESteamNetworkingSendType_UnreliableNoNagle
		public const int k_nSteamNetworkingSend_Unreliable = 0;
		// Disable Nagle's algorithm.
		// By default, Nagle's algorithm is applied to all outbound messages.  This means
		// that the message will NOT be sent immediately, in case further messages are
		// sent soon after you send this, which can be grouped together.  Any time there
		// is enough buffered data to fill a packet, the packets will be pushed out immediately,
		// but partially-full packets not be sent until the Nagle timer expires.  See
		// ISteamNetworkingSockets::FlushMessagesOnConnection, ISteamNetworkingMessages::FlushMessagesToUser
		//
		// NOTE: Don't just send every message without Nagle because you want packets to get there
		// quicker.  Make sure you understand the problem that Nagle is solving before disabling it.
		// If you are sending small messages, often many at the same time, then it is very likely that
		// it will be more efficient to leave Nagle enabled.  A typical proper use of this flag is
		// when you are sending what you know will be the last message sent for a while (e.g. the last
		// in the server simulation tick to a particular client), and you use this flag to flush all
		// messages.
		// 禁用 Nagle 算法。 默认情况下，Nagle 算法应用于所有发送消息。 这意味着消息将不会立即发送，如果很快又发送了其他消息，它们可以被分组在一起。 只要有足够的缓冲数据来填充一个数据包，数据包将被立即发送出去，但部分填充的数据包将在 Nagle 计时器到期时才发送。 参见 ISteamNetworkingSockets::FlushMessagesOnConnection, ISteamNetworkingMessages::FlushMessagesToUser
		// 注意：不要发送所有消息而不启用Nagle，因为你希望数据包更快地到达。 确保你理解Nagle解决的问题后再禁用它。 如果你发送的是小消息，并且通常一次发送很多，那么启用Nagle可能更有效。 这种标志的典型用法是在你发送已知将是最后一条消息一段时间内的消息时（例如，服务器模拟节拍中的最后一条消息发送给特定客户端），并使用此标志来刷新所有消息。
		public const int k_nSteamNetworkingSend_NoNagle = 1;
		// Send a message unreliably, bypassing Nagle's algorithm for this message and any messages
		// currently pending on the Nagle timer.  This is equivalent to using k_ESteamNetworkingSend_Unreliable
		// and then immediately flushing the messages using ISteamNetworkingSockets::FlushMessagesOnConnection
		// or ISteamNetworkingMessages::FlushMessagesToUser.  (But using this flag is more efficient since you
		// only make one API call.)
		// 发送消息时，不依赖可靠传输，绕过Nagle算法，针对此消息以及当前在Nagle计时器上排队的消息。 这等效于使用 k_ESteamNetworkingSend_Unreliable 标志，然后立即使用 ISteamNetworkingSockets::FlushMessagesOnConnection 或 ISteamNetworkingMessages::FlushMessagesToUser 刷新消息。 (但使用此标志更有效，因为它只需要一个API调用。)
		public const int k_nSteamNetworkingSend_UnreliableNoNagle = k_nSteamNetworkingSend_Unreliable|k_nSteamNetworkingSend_NoNagle;
		// If the message cannot be sent very soon (because the connection is still doing some initial
		// handshaking, route negotiations, etc), then just drop it.  This is only applicable for unreliable
		// messages.  Using this flag on reliable messages is invalid.
		// 如果消息无法很快发送（因为连接仍在进行一些初始握手、路由协商等操作），则直接丢弃它。这仅适用于不可靠的消息。在可靠消息上使用此标志无效。
		public const int k_nSteamNetworkingSend_NoDelay = 4;
		// Send an unreliable message, but if it cannot be sent relatively quickly, just drop it instead of queuing it.
		// This is useful for messages that are not useful if they are excessively delayed, such as voice data.
		// NOTE: The Nagle algorithm is not used, and if the message is not dropped, any messages waiting on the
		// Nagle timer are immediately flushed.
		//
		// A message will be dropped under the following circumstances:
		// - the connection is not fully connected.  (E.g. the "Connecting" or "FindingRoute" states)
		// - there is a sufficiently large number of messages queued up already such that the current message
		//   will not be placed on the wire in the next ~200ms or so.
		//
		// If a message is dropped for these reasons, k_EResultIgnored will be returned.
		// 发送不可靠的消息，但如果不能相对快速地发送，则直接丢弃它，而不是排队等待。这对于在过度延迟后变得无用的消息很有用，例如语音数据。注意：Nagle 算法未被使用，如果消息未被丢弃，等待在 Nagle 计时器上的所有消息将被立即刷新。
		// 以下情况会触发消息丢失：  - 连接未完全建立（例如，“连接中”或“查找路由”状态）。 - 已经排队了足够多的消息，使得当前消息在接下来大约200毫秒内都不会被放置在传输线上。
		// 如果消息因这些原因丢失，将返回 k_EResultIgnored。
		public const int k_nSteamNetworkingSend_UnreliableNoDelay = k_nSteamNetworkingSend_Unreliable|k_nSteamNetworkingSend_NoDelay|k_nSteamNetworkingSend_NoNagle;
		// Reliable message send. Can send up to k_cbMaxSteamNetworkingSocketsMessageSizeSend bytes in a single message.
		// Does fragmentation/re-assembly of messages under the hood, as well as a sliding window for
		// efficient sends of large chunks of data.
		//
		// The Nagle algorithm is used.  See notes on k_ESteamNetworkingSendType_Unreliable for more details.
		// See k_ESteamNetworkingSendType_ReliableNoNagle, ISteamNetworkingSockets::FlushMessagesOnConnection,
		// ISteamNetworkingMessages::FlushMessagesToUser
		//
		// Migration note: This is NOT the same as k_EP2PSendReliable, it's more like k_EP2PSendReliableWithBuffering
		// 可靠的消息发送。可以单次发送最多 k_cbMaxSteamNetworkingSocketsMessageSizeSend 字节的消息。在底层进行消息分段/重组，以及滑动窗口，以高效地发送大量数据。
		// 使用 Nagle 算法。 参见 k_ESteamNetworkingSendType_Unreliable 关于更多细节的说明。 参见 k_ESteamNetworkingSendType_ReliableNoNagle, ISteamNetworkingSockets::FlushMessagesOnConnection, ISteamNetworkingMessages::FlushMessagesToUser
		// 迁移说明：这与 k_EP2PSendReliable 不同，更像是 k_EP2PSendReliableWithBuffering
		public const int k_nSteamNetworkingSend_Reliable = 8;
		// Send a message reliably, but bypass Nagle's algorithm.
		//
		// Migration note: This is equivalent to k_EP2PSendReliable
		// 可靠地发送消息，但绕过Nagle算法。
		// 迁移说明：这与 k_EP2PSendReliable 相当。
		public const int k_nSteamNetworkingSend_ReliableNoNagle = k_nSteamNetworkingSend_Reliable|k_nSteamNetworkingSend_NoNagle;
		// By default, message sending is queued, and the work of encryption and talking to
		// the operating system sockets, etc is done on a service thread.  This is usually a
		// a performance win when messages are sent from the "main thread".  However, if this
		// flag is set, and data is ready to be sent immediately (either from this message
		// or earlier queued data), then that work will be done in the current thread, before
		// the current call returns.  If data is not ready to be sent (due to rate limiting
		// or Nagle), then this flag has no effect.
		//
		// This is an advanced flag used to control performance at a very low level.  For
		// most applications running on modern hardware with more than one CPU core, doing
		// the work of sending on a service thread will yield the best performance.  Only
		// use this flag if you have a really good reason and understand what you are doing.
		// Otherwise you will probably just make performance worse.
		// 默认情况下，消息发送会排队，加密和与操作系统套接字等通信的工作将在服务线程中进行。这通常在消息从“主线程”发送时是一个性能优势。但是，如果设置此标志，并且数据已准备好立即发送（无论是来自此消息还是先前排队的任何数据），则该工作将在当前线程中完成，在当前调用返回之前。如果数据未准备好发送（由于速率限制或Nagle），则此标志没有效果。
		// 这是一个高级标志，用于在非常低级别控制性能。对于在现代硬件上运行，并且具有多个CPU核心的多数应用程序，在服务线程上执行工作将获得最佳性能。 只有在你确实有充分的理由并且理解你在做什么的情况下才使用此标志。 否则你很可能只会使性能变差。
		public const int k_nSteamNetworkingSend_UseCurrentThread = 16;
		// When sending a message using ISteamNetworkingMessages, automatically re-establish
		// a broken session, without returning k_EResultNoConnection.  Without this flag,
		// if you attempt to send a message, and the session was proactively closed by the
		// peer, or an error occurred that disrupted communications, then you must close the
		// session using ISteamNetworkingMessages::CloseSessionWithUser before attempting to
		// send another message.  (Or you can simply add this flag and retry.)  In this way,
		// the disruption cannot go unnoticed, and a more clear order of events can be
		// ascertained. This is especially important when reliable messages are used, since
		// if the connection is disrupted, some of those messages will not have been delivered,
		// and it is in general not possible to know which.  Although a
		// SteamNetworkingMessagesSessionFailed_t callback will be posted when an error occurs
		// to notify you that a failure has happened, callbacks are asynchronous, so it is not
		// possible to tell exactly when it happened.  And because the primary purpose of
		// ISteamNetworkingMessages is to be like UDP, there is no notification when a peer closes
		// the session.
		//
		// If you are not using any reliable messages (e.g. you are using ISteamNetworkingMessages
		// exactly as a transport replacement for UDP-style datagrams only), you may not need to
		// know when an underlying connection fails, and so you may not need this notification.
		// 当使用IStreamNetworkingMessages发送消息时，自动重新建立断开的会话，无需返回k_EResultNoConnection。如果没有此标志，如果尝试发送消息，并且会话被同伴主动关闭，或者发生导致通信中断的错误，则必须使用IStreamNetworkingMessages::CloseSessionWithUser关闭会话，然后再尝试发送其他消息。 (或者，只需添加此标志并重试)。 这样可以防止中断被忽略，并可以确定更清晰的事件顺序。 这在可靠消息的使用中尤其重要，因为如果连接中断，其中一些消息将无法传递，而且通常无法知道哪些消息没有传递。 尽管当发生错误时，会发布SteamNetworkingMessagesSessionFailed_t回调以通知您已发生失败，但回调是异步的，因此无法准确知道何时发生。 并且因为IStreamNetworkingMessages的主要目的是像UDP一样，当同伴关闭会话时不会有通知。
		// 如果你没有使用任何可靠的消息（例如，你正在使用ISteamNetworkingMessages作为UDP风格数据包的传输方式），你可能不需要知道底层连接失败时，因此你可能不需要这个通知。
		public const int k_nSteamNetworkingSend_AutoRestartBrokenSession = 32;
		// Max possible length of a ping location, in string format.  This is
		// an extremely conservative worst case value which leaves room for future
		// syntax enhancements.  Most strings in practice are a lot shorter.
		// If you are storing many of these, you will very likely benefit from
		// using dynamic memory.
		// 最大可能的 ping 位置长度，以字符串格式。这是一个极其保守的极端情况值，为未来的语法增强提供了余地。在实践中，大多数字符串的长度会远小于这个值。如果您存储了大量的这些字符串，您很可能受益于使用动态内存。
		public const int k_cchMaxSteamNetworkingPingLocationString = 1024;
		// Special values that are returned by some functions that return a ping.
		// 返回某些返回延迟的函数的特殊值。
		public const int k_nSteamNetworkingPing_Failed = -1;
		public const int k_nSteamNetworkingPing_Unknown = -2;
		// Bitmask of types to share
		// 共享的类型位掩码
		public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Default = -1; // Special value - use user defaults 特殊值 - 使用用户默认值
		public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Disable = 0; // Do not do any ICE work at all or share any IP addresses with peer 请勿进行任何ICE工作，也不要与同伴共享任何IP地址。
		public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Relay = 1; // Relayed connection via TURN server. 通过 TURN 服务器转发连接。
		public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Private = 2; // host addresses that appear to be link-local or RFC1918 addresses 链接本地或 RFC1918 地址
		public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_Public = 4; // STUN reflexive addresses, or host address that isn't a "private" address STUN 反射地址，或非“私有”地址的主机地址
		public const int k_nSteamNetworkingConfig_P2P_Transport_ICE_Enable_All = 0x7fffffff;
		public const ulong k_ulPartyBeaconIdInvalid = 0;
		public const int INVALID_HTTPREQUEST_HANDLE		= 0;
		public const int STEAM_INPUT_MAX_COUNT = 16;
		public const int STEAM_INPUT_MAX_ANALOG_ACTIONS = 24;
		public const int STEAM_INPUT_MAX_DIGITAL_ACTIONS = 256;
		public const int STEAM_INPUT_MAX_ORIGINS = 8;
		public const int STEAM_INPUT_MAX_ACTIVE_LAYERS = 16;
		// When sending an option to a specific controller handle, you can send to all devices via this command
		// 当将选项发送到特定控制器句柄时，可以使用此命令通过所有设备发送。
		public const ulong STEAM_INPUT_HANDLE_ALL_CONTROLLERS = 0xFFFFFFFFFFFFFFFF;
		public const float STEAM_INPUT_MIN_ANALOG_ACTION_DATA = -1.0f;
		public const float STEAM_INPUT_MAX_ANALOG_ACTION_DATA = 1.0f;
		// maximum number of characters a lobby metadata key can be
		// Lobby元数据键的最大字符数
		public const byte k_nMaxLobbyKeyLength = 255;
		public const int k_SteamMusicNameMaxLength = 255;
		public const int k_SteamMusicPNGMaxLength = 65535;
	}
}

#endif // !DISABLESTEAMWORKS
